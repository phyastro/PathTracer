#include <vulkan/vulkan.h>
#include <glslang/Public/ShaderLang.h>
#include <glslang/Public/ResourceLimits.h>
#include <glslang/SPIRV/GlslangToSpv.h>
#include <GLFW/glfw3.h>
#include <imgui.h>
#include <imgui_internal.h>
#include <imgui_impl_glfw.h>
#include <imgui_impl_vulkan.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <json/json.hpp>
#include <portable-file-dialogs/portable-file-dialogs.h>

#include <iostream>
#include <stdexcept>
#include <cstdlib>
#include <vector>
#include <string>
#include <map>
#include <optional>
#include <set>
#include <cstdint>
#include <limits>
#include <algorithm>
#include <fstream>
#include <array>
#include <cmath>

const unsigned int WIDTH = 1280;
const unsigned int HEIGHT = 720;
const int MAX_FRAMES_IN_FLIGHT = 2;
const bool OFFSCREENRENDER = false;
const float MINFRAMETIME = 0.0f;
const int TONEMAP = 3; // 0 - None,  1 - Reinhard, 2 - ACES Film, 3 - DEUCES

#define DEBUGMODE
//#define LAUNCHFROMEXECUTABLES
#define MAX_OBJECTS_SIZE 1024
#define MAX_SDFS_SIZE 768
#define MAX_MATERIALS_SIZE 783
#define MAX_LIGHTS_SIZE 128
#define MAX_LIGHTIDS_SIZE 64

#ifdef DEBUGMODE
const bool isValidationLayersEnabled = true;
#else
const bool isValidationLayersEnabled = false;
#endif

#ifdef LAUNCHFROMEXECUTABLES
const bool isRunFromExecutables = true;
#else
const bool isRunFromExecutables = false;
#endif

struct QueueFamilyIndices {
	std::optional<uint32_t> graphicsComputeFamily;
	std::optional<uint32_t> presentFamily;

	bool IsComplete() {
		return graphicsComputeFamily.has_value() && presentFamily.has_value();
	}
};

struct SwapChainSupportDetails {
	VkSurfaceCapabilitiesKHR capabilities;
	std::vector<VkSurfaceFormatKHR> formats;
	std::vector<VkPresentModeKHR> presentModes;
};

struct colorFormatName {
	VkFormat format;
	const char* name;
};

struct colorSpaceName {
	VkColorSpaceKHR space;
	const char* name;
};

struct presentModeName {
	VkPresentModeKHR mode;
	const char* name;
};

struct Vertex {
	glm::vec2 pos;

	static VkVertexInputBindingDescription getBindingDescription() {
		VkVertexInputBindingDescription bindingDescription{};
		bindingDescription.binding = 0; // Only 1 Vertex Array, So Index Is 0
		bindingDescription.stride = sizeof(Vertex);
		bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

		return bindingDescription;
	}

	static VkVertexInputAttributeDescription getAttributeDescription() {
		VkVertexInputAttributeDescription attributeDescription{};
		attributeDescription.binding = 0;
		attributeDescription.location = 0; // location Directive In Vertex Shader
		attributeDescription.format = VK_FORMAT_R32G32_SFLOAT;
		attributeDescription.offset = offsetof(Vertex, pos);

		return attributeDescription;
	}
};

struct sphere {
	float pos[3];
	float radius;
	int materialID;
	int lightID;
};

struct plane {
	float pos[3];
	int materialID;
	int lightID;
};

struct box {
	float pos[3];
	float rotation[3];
	float size[3];
	int materialID;
	int lightID;
};

struct lens {
	float pos[3];
	float rotation[3];
	float radius;
	float focalLength;
	float thickness;
	bool isConverging;
	int materialID;
	int lightID;
};

struct cyclide {
	float pos[3];
	float rotation[3];
	float scale[3];
	float a;
	float b;
	float c;
	float d;
	float brad;
	int materialID;
	int lightID;
};

struct sdf {
	float pos[3];
	float size[3];
	std::string glsl;
};

struct material {
	float reflection[3];
};

struct light {
	float emission[2];
};

struct Camera {
	glm::vec3 pos;
	glm::vec2 angle;
	int ISO;
	float size;
	float apertureSize;
	float apertureDist;
	float lensRadius;
	float lensFocalLength;
	float lensThickness;
	float lensDistance;
};

struct CameraShot {
    glm::vec3 pos;
    glm::vec2 angle;
};

struct UniformBufferObject {
	float numObjects[7];
	float packedObjects[MAX_OBJECTS_SIZE];
	float packedSdfs[MAX_SDFS_SIZE];
	float packedMaterials[MAX_MATERIALS_SIZE];
	float packedLights[MAX_LIGHTS_SIZE];
	float packedLightIDs[MAX_LIGHTIDS_SIZE];
	float CIEXYZ1931[1323];
};

struct PushConstantValues {
	glm::ivec2 resolution;
	int frame;
	int currentSamples;
	int samplesPerFrame;
	float FPS;
	float persistence;
	int pathLength;
	glm::vec2 cameraAngle;
	float cameraPosX;
	float cameraPosY;
	float cameraPosZ;
	int ISO;
	float cameraSize;
	float apertureSize;
	float apertureDist;
	float lensRadius;
	float lensFocalLength;
	float lensThickness;
	float lensDistance;
	int tonemap;
};

const std::vector<const char*> validationLayers = {
	"VK_LAYER_KHRONOS_validation"
};

const std::vector<const char*> instanceExtensions = {};

const std::vector<const char*> deviceExtensions = {
	VK_KHR_SWAPCHAIN_EXTENSION_NAME,
	VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME
};

const std::vector<colorFormatName> colorFormats = {
	{VK_FORMAT_R4G4_UNORM_PACK8, "VK_FORMAT_R4G4_UNORM_PACK8"},
	{VK_FORMAT_R4G4B4A4_UNORM_PACK16, "VK_FORMAT_R4G4B4A4_UNORM_PACK16"},
	{VK_FORMAT_B4G4R4A4_UNORM_PACK16, "VK_FORMAT_B4G4R4A4_UNORM_PACK16"},
	{VK_FORMAT_R5G6B5_UNORM_PACK16, "VK_FORMAT_R5G6B5_UNORM_PACK16"},
	{VK_FORMAT_B5G6R5_UNORM_PACK16, "VK_FORMAT_B5G6R5_UNORM_PACK16"},
	{VK_FORMAT_R5G5B5A1_UNORM_PACK16, "VK_FORMAT_R5G5B5A1_UNORM_PACK16"},
	{VK_FORMAT_B5G5R5A1_UNORM_PACK16, "VK_FORMAT_B5G5R5A1_UNORM_PACK16"},
	{VK_FORMAT_A1R5G5B5_UNORM_PACK16, "VK_FORMAT_A1R5G5B5_UNORM_PACK16"},
	{VK_FORMAT_R8_UNORM, "VK_FORMAT_R8_UNORM"},
	{VK_FORMAT_R8_SNORM, "VK_FORMAT_R8_SNORM"},
	{VK_FORMAT_R8_USCALED, "VK_FORMAT_R8_USCALED"},
	{VK_FORMAT_R8_SSCALED, "VK_FORMAT_R8_SSCALED"},
	{VK_FORMAT_R8_UINT, "VK_FORMAT_R8_UINT"},
	{VK_FORMAT_R8_SINT, "VK_FORMAT_R8_SINT"},
	{VK_FORMAT_R8_SRGB, "VK_FORMAT_R8_SRGB"},
	{VK_FORMAT_R8G8_UNORM, "VK_FORMAT_R8G8_UNORM"},
	{VK_FORMAT_R8G8_SNORM, "VK_FORMAT_R8G8_SNORM"},
	{VK_FORMAT_R8G8_USCALED, "VK_FORMAT_R8G8_USCALED"},
	{VK_FORMAT_R8G8_SSCALED, "VK_FORMAT_R8G8_SSCALED"},
	{VK_FORMAT_R8G8_UINT, "VK_FORMAT_R8G8_UINT"},
	{VK_FORMAT_R8G8_SINT, "VK_FORMAT_R8G8_SINT"},
	{VK_FORMAT_R8G8_SRGB, "VK_FORMAT_R8G8_SRGB"},
	{VK_FORMAT_R8G8B8_UNORM, "VK_FORMAT_R8G8B8_UNORM"},
	{VK_FORMAT_R8G8B8_SNORM, "VK_FORMAT_R8G8B8_SNORM"},
	{VK_FORMAT_R8G8B8_USCALED, "VK_FORMAT_R8G8B8_USCALED"},
	{VK_FORMAT_R8G8B8_SSCALED, "VK_FORMAT_R8G8B8_SSCALED"},
	{VK_FORMAT_R8G8B8_UINT, "VK_FORMAT_R8G8B8_UINT"},
	{VK_FORMAT_R8G8B8_SINT, "VK_FORMAT_R8G8B8_SINT"},
	{VK_FORMAT_R8G8B8_SRGB, "VK_FORMAT_R8G8B8_SRGB"},
	{VK_FORMAT_B8G8R8_UNORM, "VK_FORMAT_B8G8R8_UNORM"},
	{VK_FORMAT_B8G8R8_SNORM, "VK_FORMAT_B8G8R8_SNORM"},
	{VK_FORMAT_B8G8R8_USCALED, "VK_FORMAT_B8G8R8_USCALED"},
	{VK_FORMAT_B8G8R8_SSCALED, "VK_FORMAT_B8G8R8_SSCALED"},
	{VK_FORMAT_B8G8R8_UINT, "VK_FORMAT_B8G8R8_UINT"},
	{VK_FORMAT_B8G8R8_SINT, "VK_FORMAT_B8G8R8_SINT"},
	{VK_FORMAT_B8G8R8_SRGB, "VK_FORMAT_B8G8R8_SRGB"},
	{VK_FORMAT_R8G8B8A8_UNORM, "VK_FORMAT_R8G8B8A8_UNORM"},
	{VK_FORMAT_R8G8B8A8_SNORM, "VK_FORMAT_R8G8B8A8_SNORM"},
	{VK_FORMAT_R8G8B8A8_USCALED, "VK_FORMAT_R8G8B8A8_USCALED"},
	{VK_FORMAT_R8G8B8A8_SSCALED, "VK_FORMAT_R8G8B8A8_SSCALED"},
	{VK_FORMAT_R8G8B8A8_UINT, "VK_FORMAT_R8G8B8A8_UINT"},
	{VK_FORMAT_R8G8B8A8_SINT, "VK_FORMAT_R8G8B8A8_SINT"},
	{VK_FORMAT_R8G8B8A8_SRGB, "VK_FORMAT_R8G8B8A8_SRGB"},
	{VK_FORMAT_B8G8R8A8_UNORM, "VK_FORMAT_B8G8R8A8_UNORM"},
	{VK_FORMAT_B8G8R8A8_SNORM, "VK_FORMAT_B8G8R8A8_SNORM"},
	{VK_FORMAT_B8G8R8A8_USCALED, "VK_FORMAT_B8G8R8A8_USCALED"},
	{VK_FORMAT_B8G8R8A8_SSCALED, "VK_FORMAT_B8G8R8A8_SSCALED"},
	{VK_FORMAT_B8G8R8A8_UINT, "VK_FORMAT_B8G8R8A8_UINT"},
	{VK_FORMAT_B8G8R8A8_SINT, "VK_FORMAT_B8G8R8A8_SINT"},
	{VK_FORMAT_B8G8R8A8_SRGB, "VK_FORMAT_B8G8R8A8_SRGB"},
	{VK_FORMAT_A8B8G8R8_UNORM_PACK32, "VK_FORMAT_A8B8G8R8_UNORM_PACK32"},
	{VK_FORMAT_A8B8G8R8_SNORM_PACK32, "VK_FORMAT_A8B8G8R8_SNORM_PACK32"},
	{VK_FORMAT_A8B8G8R8_USCALED_PACK32, "VK_FORMAT_A8B8G8R8_USCALED_PACK32"},
	{VK_FORMAT_A8B8G8R8_SSCALED_PACK32, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"},
	{VK_FORMAT_A8B8G8R8_UINT_PACK32, "VK_FORMAT_A8B8G8R8_UINT_PACK32"},
	{VK_FORMAT_A8B8G8R8_SINT_PACK32, "VK_FORMAT_A8B8G8R8_SINT_PACK32"},
	{VK_FORMAT_A8B8G8R8_SRGB_PACK32, "VK_FORMAT_A8B8G8R8_SRGB_PACK32"},
	{VK_FORMAT_A2R10G10B10_UNORM_PACK32, "VK_FORMAT_A2R10G10B10_UNORM_PACK32"},
	{VK_FORMAT_A2R10G10B10_SNORM_PACK32, "VK_FORMAT_A2R10G10B10_SNORM_PACK32"},
	{VK_FORMAT_A2R10G10B10_USCALED_PACK32, "VK_FORMAT_A2R10G10B10_USCALED_PACK32"},
	{VK_FORMAT_A2R10G10B10_SSCALED_PACK32, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"},
	{VK_FORMAT_A2R10G10B10_UINT_PACK32, "VK_FORMAT_A2R10G10B10_UINT_PACK32"},
	{VK_FORMAT_A2R10G10B10_SINT_PACK32, "VK_FORMAT_A2R10G10B10_SINT_PACK32"},
	{VK_FORMAT_A2B10G10R10_UNORM_PACK32, "VK_FORMAT_A2B10G10R10_UNORM_PACK32"},
	{VK_FORMAT_A2B10G10R10_SNORM_PACK32, "VK_FORMAT_A2B10G10R10_SNORM_PACK32"},
	{VK_FORMAT_A2B10G10R10_USCALED_PACK32, "VK_FORMAT_A2B10G10R10_USCALED_PACK32"},
	{VK_FORMAT_A2B10G10R10_SSCALED_PACK32, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"},
	{VK_FORMAT_A2B10G10R10_UINT_PACK32, "VK_FORMAT_A2B10G10R10_UINT_PACK32"},
	{VK_FORMAT_A2B10G10R10_SINT_PACK32, "VK_FORMAT_A2B10G10R10_SINT_PACK32"},
	{VK_FORMAT_R16_UNORM, "VK_FORMAT_R16_UNORM"},
	{VK_FORMAT_R16_SNORM, "VK_FORMAT_R16_SNORM"},
	{VK_FORMAT_R16_USCALED, "VK_FORMAT_R16_USCALED"},
	{VK_FORMAT_R16_SSCALED, "VK_FORMAT_R16_SSCALED"},
	{VK_FORMAT_R16_UINT, "VK_FORMAT_R16_UINT"},
	{VK_FORMAT_R16_SINT, "VK_FORMAT_R16_SINT"},
	{VK_FORMAT_R16_SFLOAT, "VK_FORMAT_R16_SFLOAT"},
	{VK_FORMAT_R16G16_UNORM, "VK_FORMAT_R16G16_UNORM"},
	{VK_FORMAT_R16G16_SNORM, "VK_FORMAT_R16G16_SNORM"},
	{VK_FORMAT_R16G16_USCALED, "VK_FORMAT_R16G16_USCALED"},
	{VK_FORMAT_R16G16_SSCALED, "VK_FORMAT_R16G16_SSCALED"},
	{VK_FORMAT_R16G16_UINT, "VK_FORMAT_R16G16_UINT"},
	{VK_FORMAT_R16G16_SINT, "VK_FORMAT_R16G16_SINT"},
	{VK_FORMAT_R16G16_SFLOAT, "VK_FORMAT_R16G16_SFLOAT"},
	{VK_FORMAT_R16G16B16_UNORM, "VK_FORMAT_R16G16B16_UNORM"},
	{VK_FORMAT_R16G16B16_SNORM, "VK_FORMAT_R16G16B16_SNORM"},
	{VK_FORMAT_R16G16B16_USCALED, "VK_FORMAT_R16G16B16_USCALED"},
	{VK_FORMAT_R16G16B16_SSCALED, "VK_FORMAT_R16G16B16_SSCALED"},
	{VK_FORMAT_R16G16B16_UINT, "VK_FORMAT_R16G16B16_UINT"},
	{VK_FORMAT_R16G16B16_SINT, "VK_FORMAT_R16G16B16_SINT"},
	{VK_FORMAT_R16G16B16_SFLOAT, "VK_FORMAT_R16G16B16_SFLOAT"},
	{VK_FORMAT_R16G16B16A16_UNORM, "VK_FORMAT_R16G16B16A16_UNORM"},
	{VK_FORMAT_R16G16B16A16_SNORM, "VK_FORMAT_R16G16B16A16_SNORM"},
	{VK_FORMAT_R16G16B16A16_USCALED, "VK_FORMAT_R16G16B16A16_USCALED"},
	{VK_FORMAT_R16G16B16A16_SSCALED, "VK_FORMAT_R16G16B16A16_SSCALED"},
	{VK_FORMAT_R16G16B16A16_UINT, "VK_FORMAT_R16G16B16A16_UINT"},
	{VK_FORMAT_R16G16B16A16_SINT, "VK_FORMAT_R16G16B16A16_SINT"},
	{VK_FORMAT_R16G16B16A16_SFLOAT, "VK_FORMAT_R16G16B16A16_SFLOAT"},
	{VK_FORMAT_R32_UINT, "VK_FORMAT_R32_UINT"},
	{VK_FORMAT_R32_SINT, "VK_FORMAT_R32_SINT"},
	{VK_FORMAT_R32_SFLOAT, "VK_FORMAT_R32_SFLOAT"},
	{VK_FORMAT_R32G32_UINT, "VK_FORMAT_R32G32_UINT"},
	{VK_FORMAT_R32G32_SINT, "VK_FORMAT_R32G32_SINT"},
	{VK_FORMAT_R32G32_SFLOAT, "VK_FORMAT_R32G32_SFLOAT"},
	{VK_FORMAT_R32G32B32_UINT, "VK_FORMAT_R32G32B32_UINT"},
	{VK_FORMAT_R32G32B32_SINT, "VK_FORMAT_R32G32B32_SINT"},
	{VK_FORMAT_R32G32B32_SFLOAT, "VK_FORMAT_R32G32B32_SFLOAT"},
	{VK_FORMAT_R32G32B32A32_UINT, "VK_FORMAT_R32G32B32A32_UINT"},
	{VK_FORMAT_R32G32B32A32_SINT, "VK_FORMAT_R32G32B32A32_SINT"},
	{VK_FORMAT_R32G32B32A32_SFLOAT, "VK_FORMAT_R32G32B32A32_SFLOAT"},
	{VK_FORMAT_R64_UINT, "VK_FORMAT_R64_UINT"},
	{VK_FORMAT_R64_SINT, "VK_FORMAT_R64_SINT"},
	{VK_FORMAT_R64_SFLOAT, "VK_FORMAT_R64_SFLOAT"},
	{VK_FORMAT_R64G64_UINT, "VK_FORMAT_R64G64_UINT"},
	{VK_FORMAT_R64G64_SINT, "VK_FORMAT_R64G64_SINT"},
	{VK_FORMAT_R64G64_SFLOAT, "VK_FORMAT_R64G64_SFLOAT"},
	{VK_FORMAT_R64G64B64_UINT, "VK_FORMAT_R64G64B64_UINT"},
	{VK_FORMAT_R64G64B64_SINT, "VK_FORMAT_R64G64B64_SINT"},
	{VK_FORMAT_R64G64B64_SFLOAT, "VK_FORMAT_R64G64B64_SFLOAT"},
	{VK_FORMAT_R64G64B64A64_UINT, "VK_FORMAT_R64G64B64A64_UINT"},
	{VK_FORMAT_R64G64B64A64_SINT, "VK_FORMAT_R64G64B64A64_SINT"},
	{VK_FORMAT_R64G64B64A64_SFLOAT, "VK_FORMAT_R64G64B64A64_SFLOAT"},
	{VK_FORMAT_B10G11R11_UFLOAT_PACK32, "VK_FORMAT_B10G11R11_UFLOAT_PACK32"}
};

const std::vector<colorSpaceName> colorSpaces = {
	{VK_COLOR_SPACE_SRGB_NONLINEAR_KHR, "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"},
	{VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT, "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT, "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"},
	{VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT, "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT"},
	{VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT, "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_BT709_LINEAR_EXT, "VK_COLOR_SPACE_BT709_LINEAR_EXT"},
	{VK_COLOR_SPACE_BT709_NONLINEAR_EXT, "VK_COLOR_SPACE_BT709_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_BT2020_LINEAR_EXT, "VK_COLOR_SPACE_BT2020_LINEAR_EXT"},
	{VK_COLOR_SPACE_HDR10_ST2084_EXT, "VK_COLOR_SPACE_HDR10_ST2084_EXT"},
	{VK_COLOR_SPACE_DOLBYVISION_EXT, "VK_COLOR_SPACE_DOLBYVISION_EXT"},
	{VK_COLOR_SPACE_HDR10_HLG_EXT, "VK_COLOR_SPACE_HDR10_HLG_EXT"},
	{VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT, "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"},
	{VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT, "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_PASS_THROUGH_EXT, "VK_COLOR_SPACE_PASS_THROUGH_EXT"},
	{VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT, "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_DISPLAY_NATIVE_AMD, "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD"},
	{VK_COLOR_SPACE_MAX_ENUM_KHR, "VK_COLOR_SPACE_MAX_ENUM_KHR"}
};

const std::vector<presentModeName> presentModes = {
	{VK_PRESENT_MODE_IMMEDIATE_KHR, "VK_PRESENT_MODE_IMMEDIATE_KHR"},
	{VK_PRESENT_MODE_MAILBOX_KHR, "VK_PRESENT_MODE_MAILBOX_KHR"},
	{VK_PRESENT_MODE_FIFO_KHR, "VK_PRESENT_MODE_FIFO_KHR"},
	{VK_PRESENT_MODE_FIFO_RELAXED_KHR, "VK_PRESENT_MODE_FIFO_RELAXED_KHR"},
	{VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR, "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"},
	{VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"},
	{VK_PRESENT_MODE_MAX_ENUM_KHR, "VK_PRESENT_MODE_MAX_ENUM_KHR"}
};

const std::vector<Vertex> vertices = {
	{{-1.0f, -1.0f}},
	{{1.0f, -1.0f}},
	{{1.0f, 1.0f}},
	{{-1.0f, 1.0f}}
};

const std::vector<uint16_t> indices = {
	0, 1, 2, 2, 3, 0
};

// Table For CIE 1931 XYZ Colour Matching Functions 2 Degree Cone Fundamentals
// 360 nm To 800 nm
// https://cie.co.at/datatable/cie-1931-colour-matching-functions-2-degree-observer
const float CIEXYZ1931[1323] = {
    0.000129900000f, 0.000003917000f, 0.000606100017f,
    0.000145847007f, 0.000004393581f, 0.000680879224f,
    0.000163802106f, 0.000004929604f, 0.000765145582f,
    0.000184003700f, 0.000005532136f, 0.000860012427f,
    0.000206690194f, 0.000006208245f, 0.000966592808f,
    0.000232100007f, 0.000006965000f, 0.001086000004f,
    0.000260728004f, 0.000007813219f, 0.001220586011f,
    0.000293074991f, 0.000008767336f, 0.001372728962f,
    0.000329388015f, 0.000009839844f, 0.001543579041f,
    0.000369913992f, 0.000011043230f, 0.001734285965f,
    0.000414899987f, 0.000012390000f, 0.001946000033f,
    0.000464158686f, 0.000013886410f, 0.002177777002f,
    0.000518986024f, 0.000015557280f, 0.002435809001f,
    0.000581854023f, 0.000017442961f, 0.002731953049f,
    0.000655234675f, 0.000019583749f, 0.003078063950f,
    0.000741600001f, 0.000022020000f, 0.003486000001f,
    0.000845029601f, 0.000024839650f, 0.003975227010f,
    0.000964526786f, 0.000028041261f, 0.004540880211f,
    0.001094948966f, 0.000031531039f, 0.005158320069f,
    0.001231153961f, 0.000035215209f, 0.005802907050f,
    0.001368000056f, 0.000038999999f, 0.006450001150f,
    0.001502049970f, 0.000042826399f, 0.007083216216f,
    0.001642327989f, 0.000046914600f, 0.007745488081f,
    0.001802381943f, 0.000051589599f, 0.008501151577f,
    0.001995756989f, 0.000057176399f, 0.009414544329f,
    0.002236000029f, 0.000064000000f, 0.010549990460f,
    0.002535385080f, 0.000072344214f, 0.011965800077f,
    0.002892602934f, 0.000082212238f, 0.013655870222f,
    0.003300829092f, 0.000093508163f, 0.015588049777f,
    0.003753236029f, 0.000106136104f, 0.017730150372f,
    0.004242999945f, 0.000119999997f, 0.020050009713f,
    0.004762389231f, 0.000134984002f, 0.022511359304f,
    0.005330048036f, 0.000151492000f, 0.025202879682f,
    0.005978711881f, 0.000170208004f, 0.028279719874f,
    0.006741117220f, 0.000191815998f, 0.031897038221f,
    0.007650000043f, 0.000216999993f, 0.036210000515f,
    0.008751372807f, 0.000246906711f, 0.041437711567f,
    0.010028880090f, 0.000281240005f, 0.047503720969f,
    0.011421700008f, 0.000318520004f, 0.054119881243f,
    0.012869009748f, 0.000357266690f, 0.060998030007f,
    0.014310000464f, 0.000395999989f, 0.067850008607f,
    0.015704430640f, 0.000433714711f, 0.074486322701f,
    0.017147440463f, 0.000473024003f, 0.081361562014f,
    0.018781220540f, 0.000517876004f, 0.089153639972f,
    0.020748009905f, 0.000572218676f, 0.098540477455f,
    0.023189999163f, 0.000639999984f, 0.110200002789f,
    0.026207359508f, 0.000724559999f, 0.124613299966f,
    0.029782479629f, 0.000825499999f, 0.141701698303f,
    0.033880919218f, 0.000941160019f, 0.161303505301f,
    0.038468241692f, 0.001069879974f, 0.183256804943f,
    0.043510001153f, 0.001210000017f, 0.207399994135f,
    0.048995599151f, 0.001362091047f, 0.233692094684f,
    0.055022601038f, 0.001530752052f, 0.262611389160f,
    0.061718799174f, 0.001720368047f, 0.294774591923f,
    0.069211997092f, 0.001935323002f, 0.330798506737f,
    0.077629998326f, 0.002180000069f, 0.371300011873f,
    0.086958110332f, 0.002454800066f, 0.416209101677f,
    0.097176723182f, 0.002764000092f, 0.465464204550f,
    0.108406297863f, 0.003117799992f, 0.519694805145f,
    0.120767198503f, 0.003526400076f, 0.579530298710f,
    0.134379997849f, 0.004000000190f, 0.645600020885f,
    0.149358198047f, 0.004546239972f, 0.718483805656f,
    0.165395706892f, 0.005159319844f, 0.796713292599f,
    0.181983098388f, 0.005829279777f, 0.877845883369f,
    0.198611006141f, 0.006546160206f, 0.959438979626f,
    0.214770004153f, 0.007300000172f, 1.039050102234f,
    0.230186805129f, 0.008086507209f, 1.115367293358f,
    0.244879692793f, 0.008908719756f, 1.188497066498f,
    0.258777290583f, 0.009767680429f, 1.258123278618f,
    0.271807909012f, 0.010664430447f, 1.323929548264f,
    0.283899992704f, 0.011599999852f, 1.385599970818f,
    0.294943809509f, 0.012573169544f, 1.442635178566f,
    0.304896503687f, 0.013582720421f, 1.494803547859f,
    0.313787311316f, 0.014629679732f, 1.542190313339f,
    0.321645408869f, 0.015715090558f, 1.584880709648f,
    0.328500002623f, 0.016839999706f, 1.622959971428f,
    0.334351301193f, 0.018007360399f, 1.656404852867f,
    0.339210093021f, 0.019214479253f, 1.685295939445f,
    0.343121290207f, 0.020453920588f, 1.709874510765f,
    0.346129596233f, 0.021718239412f, 1.730382084846f,
    0.348280012608f, 0.023000000045f, 1.747059941292f,
    0.349599897861f, 0.024294609204f, 1.760044574738f,
    0.350147396326f, 0.025610240176f, 1.769623279572f,
    0.350012987852f, 0.026958569884f, 1.776263713837f,
    0.349287003279f, 0.028351249173f, 1.780433416367f,
    0.348060011864f, 0.029799999669f, 1.782600045204f,
    0.346373289824f, 0.031310830265f, 1.782968163490f,
    0.344262391329f, 0.032883681357f, 1.781699776649f,
    0.341808795929f, 0.034521121532f, 1.779198169708f,
    0.339094102383f, 0.036225710064f, 1.775867104530f,
    0.336199998856f, 0.037999998778f, 1.772109985352f,
    0.333197712898f, 0.039846669883f, 1.768258929253f,
    0.330041110516f, 0.041767999530f, 1.764039039612f,
    0.326635688543f, 0.043765999377f, 1.758943796158f,
    0.322886794806f, 0.045842669904f, 1.752466320992f,
    0.318699985743f, 0.048000000417f, 1.744099974632f,
    0.314025104046f, 0.050243679434f, 1.733559489250f,
    0.308883994818f, 0.052573040128f, 1.720858097076f,
    0.303290396929f, 0.054980561137f, 1.705936908722f,
    0.297257900238f, 0.057458721101f, 1.688737154007f,
    0.290800005198f, 0.059999998659f, 1.669199943542f,
    0.283970087767f, 0.062601968646f, 1.647528648376f,
    0.276721388102f, 0.065277516842f, 1.623412728310f,
    0.268917798996f, 0.068042077124f, 1.596022248268f,
    0.260422706604f, 0.070911087096f, 1.564527988434f,
    0.251100003719f, 0.073899999261f, 1.528100013733f,
    0.240847498178f, 0.077016003430f, 1.486111402512f,
    0.229851201177f, 0.080266401172f, 1.439521551132f,
    0.218407198787f, 0.083666801453f, 1.389879941940f,
    0.206811502576f, 0.087232798338f, 1.338736176491f,
    0.195360004902f, 0.090980000794f, 1.287639975548f,
    0.184213593602f, 0.094917550683f, 1.237422347069f,
    0.173327296972f, 0.099045842886f, 1.187824249268f,
    0.162688106298f, 0.103367403150f, 1.138761043549f,
    0.152283295989f, 0.107884600759f, 1.090147972107f,
    0.142100006342f, 0.112599998713f, 1.041900038719f,
    0.132178604603f, 0.117531999946f, 0.994197607040f,
    0.122569598258f, 0.122674398124f, 0.947347283363f,
    0.113275200129f, 0.127992793918f, 0.901453077793f,
    0.104297898710f, 0.133452802896f, 0.856619298458f,
    0.095640003681f, 0.139019995928f, 0.812950074673f,
    0.087299548090f, 0.144676402211f, 0.770517289639f,
    0.079308040440f, 0.150469303131f, 0.729444801807f,
    0.071717761457f, 0.156461894512f, 0.689913570881f,
    0.064580991864f, 0.162717700005f, 0.652104914188f,
    0.057950008661f, 0.169300004840f, 0.616199970245f,
    0.051862109452f, 0.176243096590f, 0.582328617573f,
    0.046281520277f, 0.183558106422f, 0.550416171551f,
    0.041150879115f, 0.191273495555f, 0.520337581635f,
    0.036412831396f, 0.199417993426f, 0.491967290640f,
    0.032010000199f, 0.208020001650f, 0.465180009604f,
    0.027917200699f, 0.217119902372f, 0.439924597740f,
    0.024144399911f, 0.226734504104f, 0.416183590889f,
    0.020687000826f, 0.236857101321f, 0.393882185221f,
    0.017540400848f, 0.247481197119f, 0.372945904732f,
    0.014700000174f, 0.258599996567f, 0.353300005198f,
    0.012161790393f, 0.270184904337f, 0.334857791662f,
    0.009919960052f, 0.282293885946f, 0.317552089691f,
    0.007967240177f, 0.295050501823f, 0.301337510347f,
    0.006296345964f, 0.308578014374f, 0.286168605089f,
    0.004900000058f, 0.323000013828f, 0.272000014782f,
    0.003777173115f, 0.338402092457f, 0.258817106485f,
    0.002945319982f, 0.354685813189f, 0.246483802795f,
    0.002424879931f, 0.371698588133f, 0.234771803021f,
    0.002236292930f, 0.389287501574f, 0.223453298211f,
    0.002400000114f, 0.407299995422f, 0.212300002575f,
    0.002925520064f, 0.425629913807f, 0.201169192791f,
    0.003836560063f, 0.444309592247f, 0.190119594336f,
    0.005174839869f, 0.463394403458f, 0.179225400090f,
    0.006982080173f, 0.482939511538f, 0.168560802937f,
    0.009300000034f, 0.503000020981f, 0.158199995756f,
    0.012149490416f, 0.523569285870f, 0.148138299584f,
    0.015535879880f, 0.544511973858f, 0.138375803828f,
    0.019477520138f, 0.565689980984f, 0.128994196653f,
    0.023992769420f, 0.586965322495f, 0.120075099170f,
    0.029100000858f, 0.608200013638f, 0.111699998379f,
    0.034814849496f, 0.629345595837f, 0.103904798627f,
    0.041120160371f, 0.650306820869f, 0.096667483449f,
    0.047985039651f, 0.670875191689f, 0.089982718229f,
    0.055378608406f, 0.690842390060f, 0.083845309913f,
    0.063270002604f, 0.709999978542f, 0.078249990940f,
    0.071635007858f, 0.728185176849f, 0.073208987713f,
    0.080462239683f, 0.745463609695f, 0.068678162992f,
    0.089739963412f, 0.761969387531f, 0.064567841589f,
    0.099456451833f, 0.777836799622f, 0.060788348317f,
    0.109600000083f, 0.793200016022f, 0.057250011712f,
    0.120167396963f, 0.808110415936f, 0.053904350847f,
    0.131114497781f, 0.822496175766f, 0.050746638328f,
    0.142367899418f, 0.836306810379f, 0.047752760351f,
    0.153854206204f, 0.849491596222f, 0.044898588210f,
    0.165500000119f, 0.861999988556f, 0.042160000652f,
    0.177257105708f, 0.873810827732f, 0.039507281035f,
    0.189140006900f, 0.884962379932f, 0.036935638636f,
    0.201169401407f, 0.895493626595f, 0.034458361566f,
    0.213365793228f, 0.905443191528f, 0.032088719308f,
    0.225749894977f, 0.914850115776f, 0.029839999974f,
    0.238320901990f, 0.923734784126f, 0.027711810544f,
    0.251066803932f, 0.932092428207f, 0.025694439188f,
    0.263992190361f, 0.939922571182f, 0.023787159473f,
    0.277101695538f, 0.947225213051f, 0.021989250556f,
    0.290399998426f, 0.953999996185f, 0.020300000906f,
    0.303891211748f, 0.960256099701f, 0.018718050793f,
    0.317572593689f, 0.966007411480f, 0.017240360379f,
    0.331438392401f, 0.971260607243f, 0.015863640234f,
    0.345482796431f, 0.976022481918f, 0.014584610239f,
    0.359699994326f, 0.980300009251f, 0.013399999589f,
    0.374083906412f, 0.984092414379f, 0.012307230383f,
    0.388639599085f, 0.987418174744f, 0.011301879771f,
    0.403378397226f, 0.990312814713f, 0.010377920233f,
    0.418311506510f, 0.992811620235f, 0.009529305622f,
    0.433449894190f, 0.994950115681f, 0.008749999106f,
    0.448795288801f, 0.996710777283f, 0.008035199717f,
    0.464336007833f, 0.998098313808f, 0.007381599862f,
    0.480064004660f, 0.999112010002f, 0.006785400212f,
    0.495971292257f, 0.999748170376f, 0.006242800038f,
    0.512050092220f, 1.000000000000f, 0.005749999080f,
    0.528295874596f, 0.999856710434f, 0.005303599872f,
    0.544691622257f, 0.999304592609f, 0.004899799824f,
    0.561209380627f, 0.998325526714f, 0.004534199834f,
    0.577821493149f, 0.996898710728f, 0.004202399869f,
    0.594500005245f, 0.995000004768f, 0.003899999894f,
    0.611220896244f, 0.992600500584f, 0.003623200115f,
    0.627975821495f, 0.989742577076f, 0.003370600054f,
    0.644760191441f, 0.986444413662f, 0.003141399939f,
    0.661569714546f, 0.982724070549f, 0.002934799995f,
    0.678399980068f, 0.978600025177f, 0.002749999054f,
    0.695239186287f, 0.974083721638f, 0.002585199894f,
    0.712058603764f, 0.969171226025f, 0.002438599942f,
    0.728828370571f, 0.963856816292f, 0.002309399890f,
    0.745518803596f, 0.958134889603f, 0.002196799964f,
    0.762099981308f, 0.952000021935f, 0.002099999925f,
    0.778543174267f, 0.945450425148f, 0.002017732942f,
    0.794825613499f, 0.938499212265f, 0.001948200050f,
    0.810926377773f, 0.931162774563f, 0.001889799954f,
    0.826824784279f, 0.923457622528f, 0.001840932993f,
    0.842499971390f, 0.915400028229f, 0.001799999969f,
    0.857932507992f, 0.907006382942f, 0.001766267000f,
    0.873081624508f, 0.898277223110f, 0.001737799961f,
    0.887894392014f, 0.889204800129f, 0.001711199991f,
    0.902318120003f, 0.879781603813f, 0.001683066948f,
    0.916299998760f, 0.870000004768f, 0.001650001039f,
    0.929799497128f, 0.859861314297f, 0.001610132982f,
    0.942798376083f, 0.849391996861f, 0.001564400038f,
    0.955277621746f, 0.838621973991f, 0.001513600000f,
    0.967217922211f, 0.827581286430f, 0.001458532992f,
    0.978600025177f, 0.816299974918f, 0.001399999950f,
    0.989385604858f, 0.804794728756f, 0.001336666988f,
    0.999548792839f, 0.793081998825f, 0.001270000008f,
    1.009089231491f, 0.781192004681f, 0.001204999979f,
    1.018006443977f, 0.769154727459f, 0.001146667055f,
    1.026299953461f, 0.757000029087f, 0.001099999994f,
    1.033982753754f, 0.744754076004f, 0.001068799989f,
    1.040985941887f, 0.732422411442f, 0.001049399958f,
    1.047188043594f, 0.720003604889f, 0.001035599969f,
    1.052466750145f, 0.707496523857f, 0.001021199976f,
    1.056699991226f, 0.694899976254f, 0.001000000047f,
    1.059794425964f, 0.682219207287f, 0.000968639972f,
    1.061799168587f, 0.669471621513f, 0.000929920003f,
    1.062806844711f, 0.656674385071f, 0.000886879978f,
    1.062909603119f, 0.643844783306f, 0.000842560024f,
    1.062199950218f, 0.630999982357f, 0.000799999980f,
    1.060735225677f, 0.618155479431f, 0.000760959985f,
    1.058443546295f, 0.605314373970f, 0.000723680016f,
    1.055224418640f, 0.592475593090f, 0.000685920008f,
    1.050976753235f, 0.579637885094f, 0.000645440014f,
    1.045600056648f, 0.566799998283f, 0.000600000028f,
    1.039036870003f, 0.553961098194f, 0.000547866686f,
    1.031360745430f, 0.541137218475f, 0.000491600018f,
    1.022666215897f, 0.528352797031f, 0.000435399998f,
    1.013047695160f, 0.515632271767f, 0.000383466686f,
    1.002599954605f, 0.503000020981f, 0.000339999999f,
    0.991367518902f, 0.490468800068f, 0.000307253300f,
    0.979331374168f, 0.478030413389f, 0.000283160014f,
    0.966491580009f, 0.465677589178f, 0.000265440001f,
    0.952847898006f, 0.453403204679f, 0.000251813297f,
    0.938399970531f, 0.441199988127f, 0.000239999994f,
    0.923193991184f, 0.429080009460f, 0.000229546698f,
    0.907244026661f, 0.417035996914f, 0.000220639995f,
    0.890501976013f, 0.405032008886f, 0.000211959996f,
    0.872919976711f, 0.393032014370f, 0.000202186697f,
    0.854449927807f, 0.381000012159f, 0.000190000006f,
    0.835084021091f, 0.368918389082f, 0.000174213303f,
    0.814945995808f, 0.356827199459f, 0.000155639995f,
    0.794185996056f, 0.344776809216f, 0.000135959999f,
    0.772953987122f, 0.332817614079f, 0.000116853298f,
    0.751399993896f, 0.321000009775f, 0.000099999997f,
    0.729583621025f, 0.309338092804f, 0.000086133332f,
    0.707588791847f, 0.297850400209f, 0.000074600001f,
    0.685602188110f, 0.286593586206f, 0.000065000000f,
    0.663810372353f, 0.275624513626f, 0.000056933332f,
    0.642400026321f, 0.264999985695f, 0.000049999991f,
    0.621514916420f, 0.254763185978f, 0.000044159999f,
    0.601113796234f, 0.244889602065f, 0.000039480001f,
    0.581105172634f, 0.235334396362f, 0.000035720001f,
    0.561397671700f, 0.226052805781f, 0.000032640000f,
    0.541899979115f, 0.216999992728f, 0.000029999999f,
    0.522599518299f, 0.208161607385f, 0.000027653330f,
    0.503546416759f, 0.199548795819f, 0.000025560001f,
    0.484743595123f, 0.191155195236f, 0.000023639999f,
    0.466193914413f, 0.182974398136f, 0.000021813330f,
    0.447899997234f, 0.174999997020f, 0.000019999999f,
    0.429861307144f, 0.167223498225f, 0.000018133331f,
    0.412097990513f, 0.159646406770f, 0.000016200000f,
    0.394643992186f, 0.152277603745f, 0.000014200000f,
    0.377533286810f, 0.145125895739f, 0.000012133330f,
    0.360799998045f, 0.138199999928f, 0.000010000000f,
    0.344456285238f, 0.131500303745f, 0.000007733333f,
    0.328516811132f, 0.125024795532f, 0.000005400000f,
    0.313019186258f, 0.118779197335f, 0.000003200000f,
    0.298001110554f, 0.112769097090f, 0.000001333333f,
    0.283499985933f, 0.107000000775f, 0.000000000000f,
    0.269544810057f, 0.101476199925f, 0.000000000000f,
    0.256118386984f, 0.096188642085f, 0.000000000000f,
    0.243189603090f, 0.091122962534f, 0.000000000000f,
    0.230727195740f, 0.086264848709f, 0.000000000000f,
    0.218700006604f, 0.081600002944f, 0.000000000000f,
    0.207097098231f, 0.077120639384f, 0.000000000000f,
    0.195923194289f, 0.072825521231f, 0.000000000000f,
    0.185170799494f, 0.068710081279f, 0.000000000000f,
    0.174832299352f, 0.064769759774f, 0.000000000000f,
    0.164900004864f, 0.061000000685f, 0.000000000000f,
    0.155366703868f, 0.057396210730f, 0.000000000000f,
    0.146229997277f, 0.053955040872f, 0.000000000000f,
    0.137490004301f, 0.050673760474f, 0.000000000000f,
    0.129146695137f, 0.047549650073f, 0.000000000000f,
    0.121200002730f, 0.044580001384f, 0.000000000000f,
    0.113639697433f, 0.041758719832f, 0.000000000000f,
    0.106464996934f, 0.039084959775f, 0.000000000000f,
    0.099690437317f, 0.036563839763f, 0.000000000000f,
    0.093330606818f, 0.034200478345f, 0.000000000000f,
    0.087399996817f, 0.032000001520f, 0.000000000000f,
    0.081900961697f, 0.029962610453f, 0.000000000000f,
    0.076804280281f, 0.028076639399f, 0.000000000000f,
    0.072077117860f, 0.026329360902f, 0.000000000000f,
    0.067686639726f, 0.024708049372f, 0.000000000000f,
    0.063600003719f, 0.023199999705f, 0.000000000000f,
    0.059806849808f, 0.021800769493f, 0.000000000000f,
    0.056282158941f, 0.020501120016f, 0.000000000000f,
    0.052971038967f, 0.019281079993f, 0.000000000000f,
    0.049818608910f, 0.018120689318f, 0.000000000000f,
    0.046769998968f, 0.017000000924f, 0.000000000000f,
    0.043784048408f, 0.015903789550f, 0.000000000000f,
    0.040875360370f, 0.014837180264f, 0.000000000000f,
    0.038072638214f, 0.013810680248f, 0.000000000000f,
    0.035404611379f, 0.012834779918f, 0.000000000000f,
    0.032900001854f, 0.011920000426f, 0.000000000000f,
    0.030564190820f, 0.011068309657f, 0.000000000000f,
    0.028380559757f, 0.010273390450f, 0.000000000000f,
    0.026344839483f, 0.009533311240f, 0.000000000000f,
    0.024452749640f, 0.008846157230f, 0.000000000000f,
    0.022700000554f, 0.008209999651f, 0.000000000000f,
    0.021084289998f, 0.007623780984f, 0.000000000000f,
    0.019599879161f, 0.007085423917f, 0.000000000000f,
    0.018237320706f, 0.006591476034f, 0.000000000000f,
    0.016987169161f, 0.006138484925f, 0.000000000000f,
    0.015839999542f, 0.005723000038f, 0.000000000000f,
    0.014790640213f, 0.005343059078f, 0.000000000000f,
    0.013831320219f, 0.004995795898f, 0.000000000000f,
    0.012948679738f, 0.004676403943f, 0.000000000000f,
    0.012129199691f, 0.004380074795f, 0.000000000000f,
    0.011359159835f, 0.004102000035f, 0.000000000000f,
    0.010629350320f, 0.003838452976f, 0.000000000000f,
    0.009938846342f, 0.003589099040f, 0.000000000000f,
    0.009288421832f, 0.003354219021f, 0.000000000000f,
    0.008678854443f, 0.003134093015f, 0.000000000000f,
    0.008110916242f, 0.002928999951f, 0.000000000000f,
    0.007582387887f, 0.002738138894f, 0.000000000000f,
    0.007088745944f, 0.002559876069f, 0.000000000000f,
    0.006627312861f, 0.002393244067f, 0.000000000000f,
    0.006195407826f, 0.002237275010f, 0.000000000000f,
    0.005790345836f, 0.002091000089f, 0.000000000000f,
    0.005409826059f, 0.001953586936f, 0.000000000000f,
    0.005052582826f, 0.001824580017f, 0.000000000000f,
    0.004717512056f, 0.001703580027f, 0.000000000000f,
    0.004403506871f, 0.001590186963f, 0.000000000000f,
    0.004109457135f, 0.001484000008f, 0.000000000000f,
    0.003833913011f, 0.001384495990f, 0.000000000000f,
    0.003575748065f, 0.001291268039f, 0.000000000000f,
    0.003334342036f, 0.001204092056f, 0.000000000000f,
    0.003109074896f, 0.001122744055f, 0.000000000000f,
    0.002899327083f, 0.001047000056f, 0.000000000000f,
    0.002704347949f, 0.000976589625f, 0.000000000000f,
    0.002523019910f, 0.000911108800f, 0.000000000000f,
    0.002354168100f, 0.000850133190f, 0.000000000000f,
    0.002196616028f, 0.000793238403f, 0.000000000000f,
    0.002049189992f, 0.000739999989f, 0.000000000000f,
    0.001910959953f, 0.000690082728f, 0.000000000000f,
    0.001781438012f, 0.000643310021f, 0.000000000000f,
    0.001660109963f, 0.000599496008f, 0.000000000000f,
    0.001546459040f, 0.000558454718f, 0.000000000000f,
    0.001439971034f, 0.000520000001f, 0.000000000000f,
    0.001340041985f, 0.000483913609f, 0.000000000000f,
    0.001246275031f, 0.000450052787f, 0.000000000000f,
    0.001158470986f, 0.000418345211f, 0.000000000000f,
    0.001076429966f, 0.000388718414f, 0.000000000000f,
    0.000999949290f, 0.000361100014f, 0.000000000000f,
    0.000928735826f, 0.000335383491f, 0.000000000000f,
    0.000862433226f, 0.000311440410f, 0.000000000000f,
    0.000800750277f, 0.000289165589f, 0.000000000000f,
    0.000743395998f, 0.000268453907f, 0.000000000000f,
    0.000690078596f, 0.000249200006f, 0.000000000000f,
    0.000640515587f, 0.000231301907f, 0.000000000000f,
    0.000594502082f, 0.000214685599f, 0.000000000000f,
    0.000551864621f, 0.000199288406f, 0.000000000000f,
    0.000512428989f, 0.000185047495f, 0.000000000000f,
    0.000476021291f, 0.000171899999f, 0.000000000000f,
    0.000442453602f, 0.000159778094f, 0.000000000000f,
    0.000411511690f, 0.000148604406f, 0.000000000000f,
    0.000382981409f, 0.000138301606f, 0.000000000000f,
    0.000356649107f, 0.000128792497f, 0.000000000000f,
    0.000332301104f, 0.000119999997f, 0.000000000000f,
    0.000309758587f, 0.000111859503f, 0.000000000000f,
    0.000288887095f, 0.000104322397f, 0.000000000000f,
    0.000269539392f, 0.000097335600f, 0.000000000000f,
    0.000251568214f, 0.000090845868f, 0.000000000000f,
    0.000234826104f, 0.000084799998f, 0.000000000000f,
    0.000219170994f, 0.000079146666f, 0.000000000000f,
    0.000204525801f, 0.000073857998f, 0.000000000000f,
    0.000190840496f, 0.000068916001f, 0.000000000000f,
    0.000178065398f, 0.000064302672f, 0.000000000000f,
    0.000166150494f, 0.000059999998f, 0.000000000000f,
    0.000155023605f, 0.000055981869f, 0.000000000000f,
    0.000144621896f, 0.000052225601f, 0.000000000000f,
    0.000134909802f, 0.000048718401f, 0.000000000000f,
    0.000125852006f, 0.000045447468f, 0.000000000000f,
    0.000117413001f, 0.000042399999f, 0.000000000000f,
    0.000109551504f, 0.000039561040f, 0.000000000000f,
    0.000102224498f, 0.000036915120f, 0.000000000000f,
    0.000095394447f, 0.000034448680f, 0.000000000000f,
    0.000089023903f, 0.000032148160f, 0.000000000000f,
    0.000083075269f, 0.000029999999f, 0.000000000000f,
    0.000077512690f, 0.000027991249f, 0.000000000000f,
    0.000072313043f, 0.000026113559f, 0.000000000000f,
    0.000067457782f, 0.000024360241f, 0.000000000000f,
    0.000062928440f, 0.000022724609f, 0.000000000000f,
    0.000058706519f, 0.000021200000f, 0.000000000000f,
    0.000054770280f, 0.000019778550f, 0.000000000000f,
    0.000051099181f, 0.000018452851f, 0.000000000000f,
    0.000047676542f, 0.000017216869f, 0.000000000000f,
    0.000044485671f, 0.000016064590f, 0.000000000000f,
    0.000041509938f, 0.000014990000f, 0.000000000000f,
    0.000038733240f, 0.000013987280f, 0.000000000000f,
    0.000036142032f, 0.000013051550f, 0.000000000000f,
    0.000033723521f, 0.000012178180f, 0.000000000000f,
    0.000031464871f, 0.000011362540f, 0.000000000000f,
    0.000029353259f, 0.000010600000f, 0.000000000000f,
    0.000027375730f, 0.000009885877f, 0.000000000000f,
    0.000025524330f, 0.000009217304f, 0.000000000000f,
    0.000023793760f, 0.000008592362f, 0.000000000000f,
    0.000022178700f, 0.000008009133f, 0.000000000000f,
    0.000020673830f, 0.000007465700f, 0.000000000000f,
    0.000019272260f, 0.000006959567f, 0.000000000000f,
    0.000017966400f, 0.000006487995f, 0.000000000000f,
    0.000016749909f, 0.000006048699f, 0.000000000000f,
    0.000015616481f, 0.000005639396f, 0.000000000000f,
    0.000014559770f, 0.000005257800f, 0.000000000000f,
    0.000013573870f, 0.000004901771f, 0.000000000000f,
    0.000012654360f, 0.000004569720f, 0.000000000000f,
    0.000011797230f, 0.000004260194f, 0.000000000000f,
    0.000010998440f, 0.000003971739f, 0.000000000000f,
    0.000010253980f, 0.000003702900f, 0.000000000000f
};

std::string vertexShaderCode{};
std::string fragmentShaderCode{};
std::string computeShaderCode{};

VkResult CreateDebugUtilsMessengerEXT(VkInstance instance,
const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo,
const VkAllocationCallbacks *pAllocator,
VkDebugUtilsMessengerEXT *pDebugMessenger) {
	PFN_vkCreateDebugUtilsMessengerEXT func = (PFN_vkCreateDebugUtilsMessengerEXT)
	vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
	if (func != nullptr) {
		return func(instance, pCreateInfo, pAllocator, pDebugMessenger);
	} else {
		return VK_ERROR_EXTENSION_NOT_PRESENT;
	}
}

void DestoryDebugUtilsMessengerEXT(VkInstance instance,
VkDebugUtilsMessengerEXT debugMessenger,
const VkAllocationCallbacks* pAllocator) {
	PFN_vkDestroyDebugUtilsMessengerEXT func = (PFN_vkDestroyDebugUtilsMessengerEXT)
	vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
	if (func != nullptr) {
		func(instance, debugMessenger, pAllocator);
	}
}

std::string ReadFile(const std::string& fileDir) {
	std::ifstream file(fileDir, std::ios::ate | std::ios::binary);

	if (!file.is_open()) {
		std::string error;
		error.append("Failed To Open The File With Directory ");
		error.append(fileDir.c_str());

		throw std::runtime_error(error);
	}

	size_t fileSize = (size_t)file.tellg();
	std::string buffer;
	buffer.resize(fileSize);

	file.seekg(0);
	file.read(buffer.data(), fileSize);
	file.close();

	return buffer;
}

nlohmann::ordered_json ReadJSON(const std::string& fileDir) {
	std::ifstream file(fileDir);

	if (!file.is_open()) {
		std::string error;
		error.append("Failed To Open The JSON File With Directory ");
		error.append(fileDir.c_str());

		throw std::runtime_error(error);
	}

	nlohmann::ordered_json json;
	file >> json;

	return json;
}

void SaveFile(const std::string& fileDir, const std::string& File) {
	std::ofstream file(fileDir, std::ios::binary);

	file << File;

	file.close();
}

void SavePPM(const std::string& filename, int width, int height, char* data) {
	std::ofstream file;
	file.open(filename, std::ios::out | std::ios::binary);

	file << "P6" << "\n" << width << "\n" << height << "\n" << "255" << "\n";

	file.write(data, static_cast<size_t>(width * height * 3));

	if (file.fail()) {
		throw std::runtime_error("Couldn't Save The Image File!");
	} else {
		std::cout << "Successfully Saved The Image File." << std::endl;
	}

	file.close();
}

double RoundDecimal(double number, double precision) {
	if (number >= 0.0) {
		number = static_cast<int>(number * precision + 0.5);
	} else {
		number = static_cast<int>(number * precision - 0.5);
	}

	return number / precision;
}

bool IsInRange(int x, int a, int b) {
	return (x >= a) && (x <= b) && (b >= a);
}

float SpectralPowerDistribution(float l, float l_peak, float d, float invert) {
	// Spectral Power Distribution Function Calculated On The Basis Of Peak Wavelength And Standard Deviation
	// Using Gaussian Function To Predict Spectral Radiance
	// In Reality, Spectral Radiance Function Has Different Shapes For Different Objects Also Looks Much Different Than This
	float x = (l - l_peak) / (2.0f * d * d);
	float radiance = exp(-x * x);
	radiance = glm::mix(radiance, 1.0f - radiance, invert);

	return radiance;
}

float BlackBodyRadiation(float l, float T) {
	// Plank's Law
	return (1.1910429724e-16f * pow(l, -5.0f)) / (exp(0.014387768775f / (l * T)) - 1.0f);
}

float BlackBodyRadiationPeak(float T) {
	// Derived By Substituting Wien's Displacement Law On Plank's Law
	return 4.0956746759e-6f * pow(T, 5.0f);
}

// http://www.brucelindbloom.com/Eqn_ChromAdapt.html
glm::vec3 IlluminantEToD65(glm::vec3 XYZ) {
    // Bradford Chromatic Adaptation From Reference White Illuminant E To Illuminant D65
    glm::mat3 m = glm::mat3(0.9531874, -0.0265906, 0.0238731,
            -0.0382467, 1.0288406, 0.0094060,
            0.0026068, -0.0030332, 1.0892565);
    return XYZ * m;
}

// http://www.brucelindbloom.com/Eqn_RGB_XYZ_Matrix.html
glm::vec3 XYZToRGB(glm::vec3 XYZ) {
    // Transformation From XYZ To sRGB Color Space With Illuminant D65 As Reference White
    glm::mat3 m = glm::mat3(3.2404542, -1.5371385, -0.4985314,
            -0.9692660, 1.8760108, 0.0415560,
            0.0556434, -0.2040259, 1.0572252);
    return XYZ * m;
}

float Reinhard(float x) {
	// x / (1 + x)
	return x / (1.0f + x);
}

glm::vec3 Reinhard(glm::vec3 x) {
	// x / (1 + x)
	return x / (1.0f + x);
}

// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
float ACESFilm(float x) {
	// x(ax + b) / (x(cx + d) + e)
	float a = 2.51f;
	float b = 0.03f;
	float c = 2.43f;
	float d = 0.59f;
	float e = 0.14f;

	return x * (a * x + b) / (x * (c * x + d) + e);
}

// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
glm::vec3 ACESFilm(glm::vec3 x) {
	// x(ax + b) / (x(cx + d) + e)
	float a = 2.51f;
	float b = 0.03f;
	float c = 2.43f;
	float d = 0.59f;
	float e = 0.14f;

	return x * (a * x + b) / (x * (c * x + d) + e);
}

// DEUCES Biophotometric Tonemap by Ted(Kerdek)
float DEUCESBioPhotometric(float x) {
	// e^(-0.25 / x)
	return exp(-0.25f / x);
}

// DEUCES Biophotometric Tonemap by Ted(Kerdek)
glm::vec3 DEUCESBioPhotometric(glm::vec3 x) {
    // e^(-0.25 / x)
    return glm::exp(-0.25f / x);
}

float tonemapping(float x, int tonemap) {
	if (tonemap == 1) {
		x = Reinhard(x);
	}
	if (tonemap == 2) {
		x = ACESFilm(x);
	}
	if (tonemap == 3) {
		x = DEUCESBioPhotometric(x);
	}

	return x;
}

glm::vec3 tonemapping(glm::vec3 x, int tonemap) {
	if (tonemap == 1) {
		x = Reinhard(x);
	}
	if (tonemap == 2) {
		x = ACESFilm(x);
	}
	if (tonemap == 3) {
		x = DEUCESBioPhotometric(x);
	}

	return x;
}

float sRGBCompanding(float x) {
    // Companding For sRGB Displays
    x = std::clamp(x, 0.0f, 1.0f);
    if (x <= 0.0031308f) {
        x = 12.92f * x;
    } else {
        x = 1.055f * pow(x, 1.0f / 2.4f) - 0.055f;
    }
    return x;
}

class App {
public:
    void run() {
        InitWindow();
		glslang::InitializeProcess();
        InitVulkan();
		if (!OFFSCREENRENDER) {
			InitImGui();
		}
        MainLoop();
		glslang::FinalizeProcess();
        CleanUp();
    }
private:
    GLFWwindow* window;
	int W = WIDTH;
	int H = HEIGHT;
	bool VSync = false;

	VkInstance instance;
	VkDebugUtilsMessengerEXT debugMessenger;
	VkSurfaceKHR surface;

	VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
	VkDevice device;

	VkQueue graphicsQueue;
	VkQueue computeQueue;
	VkQueue presentQueue;

	VkSwapchainKHR swapChain;
	std::vector<VkImage> swapChainImages;
	VkFormat swapChainImageFormat;
	std::vector<VkImageView> swapChainImageViews;

	VkRenderPass renderPass;

	VkDescriptorSetLayout descriptorSetLayout;
	std::vector<VkShaderModule> shaderModules;

	VkPipelineLayout graphicsPipelineLayout;
	VkPipeline graphicsPipeline;

	VkPipelineLayout computePipelineLayout;
	VkPipeline computePipeline;

	VkCommandPool commandPool;

	VkBuffer vertexBuffer;
	VkDeviceMemory vertexBufferMemory;
	VkBuffer indexBuffer;
	VkDeviceMemory indexBufferMemory;

	std::vector<VkBuffer> uniformBuffers;
	std::vector<VkDeviceMemory> uniformBuffersMemory;
	std::vector<void*> uniformBuffersMapped;
	UniformBufferObject ubo;

	VkBuffer texelBuffer;
	VkDeviceMemory texelBufferMemory;
	VkFormat texelBufferFormat = VK_FORMAT_R32G32B32A32_SFLOAT;
	VkBufferView texelBufferView;

	std::vector<VkFramebuffer> framebuffers;

	VkDescriptorPool descriptorPool;
	std::vector<VkDescriptorSet> descriptorSets;

	PushConstantValues pushConstant;

	std::vector<VkCommandBuffer> graphicsCommandBuffers;
	std::vector<VkCommandBuffer> computeCommandBuffers;

	std::vector<VkSemaphore> imageAvailableSemaphores;
	std::vector<VkSemaphore> renderFinishedSemaphores;
	std::vector<VkFence> inFlightFences;

	std::vector<VkSemaphore> computeFinishedSemaphores;
	std::vector<VkFence> computeInFlightFences;

	VkDescriptorPool imguiDescriptorPool;
	ImGuiIO* io;

	bool isWindowMinimized = false;
	bool isVSyncChanged = false;
	bool isCameraLocked = false;
	bool isReset = false;
	bool isUpdateUBO = true;
	bool isRecompile = false;

	uint32_t currentFrame = 0;
	int samplesPerFrame = 1;
	int frame = 0;
	int currentSamples = 0;
	int numSamples = 1000;
	float frameTime = 0.0166f;
	float minFrameTime = MINFRAMETIME;
	int cameraShotIndex = 1;

	float persistence = 0.0625f;
	int pathLength = 5;
	int tonemap = TONEMAP;


	nlohmann::ordered_json scene;
	bool isLoadScene = false;
	bool isSaveScene = false;
	bool isLoadSDF = false;
	bool isSaveSDF = false;
	bool isSaveRender = false;

	Camera camera{};
	std::vector<CameraShot> cameraShots;
	std::vector<sphere> spheres;
	std::vector<plane> planes;
	std::vector<box> boxes;
	std::vector<lens> lenses;
	std::vector<cyclide> cyclides;
	std::vector<sdf> sdfs;
	std::vector<material> materials;
	std::vector<light> lights;

	bool isImGuiWindowFocused = false;
	int shotSelection = 0;
	int objectSelection = 0;
	int sdfSelection = 0;
	int materialSelection = 0;
	int lightSelection = 0;

    void InitWindow() {
		glfwInit();

		glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);

		if (OFFSCREENRENDER) {
			glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);
		} else {
			glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE);
			glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
		}

		window = glfwCreateWindow(W, H, "Path Tracer", nullptr, nullptr);

		GLFWmonitor* monitor = glfwGetPrimaryMonitor();
		int monitorX = 0;
		int monitorY = 0;
		int monitorWidth = 0;
		int monitorHeight = 0;

		glfwGetMonitorWorkarea(monitor, &monitorX, &monitorY, &monitorWidth, &monitorHeight);

		glfwSetWindowPos(window, monitorX + (monitorWidth - W) / 2, monitorY + (monitorHeight - H) / 2);
    }

	bool CheckValidationLayerSupport() {
		uint32_t layersCount;
		vkEnumerateInstanceLayerProperties(&layersCount, nullptr);
		std::vector<VkLayerProperties> availableLayers(layersCount);
		vkEnumerateInstanceLayerProperties(&layersCount, availableLayers.data());

		for(const char* layerName : validationLayers) {
			bool layerFound = false;
			for(const VkLayerProperties &layerProperties : availableLayers) {
				if (strcmp(layerName, layerProperties.layerName) == 0) {
					layerFound = true;
					break;
				}
			}

			if (!layerFound) {
				return false;
			}
		}
		return true;
	}

	void AvailableInstanceExtensions() {
		uint32_t availableExtensionsCount = 0;
		vkEnumerateInstanceExtensionProperties(nullptr, &availableExtensionsCount, nullptr);
		std::vector<VkExtensionProperties> availableExtensions(availableExtensionsCount);
		vkEnumerateInstanceExtensionProperties(nullptr, &availableExtensionsCount, availableExtensions.data());

		std::cout << "Available Instance Extensions:" << std::endl;
		for(const VkExtensionProperties &extension : availableExtensions) {
			std::cout << "\t" << extension.extensionName << std::endl;
		}
	}

	std::vector<const char*> GetRequiredInstanceExtensions() {
		uint32_t glfwExtensionsCount = 0;
		const char** glfwExtensions;
		glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionsCount);

		std::vector<const char*> extensions(glfwExtensionsCount);
		for (uint32_t i = 0; i < glfwExtensionsCount; i++) {
			extensions[i] = glfwExtensions[i];
		}

		if (isValidationLayersEnabled) {
			extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); // Require Extension VK_EXT_debug_utils
		}

		for (const char* instanceExtension : instanceExtensions) {
			extensions.push_back(instanceExtension);
		}

		std::cout << "Required Instance Extensions:" << std::endl;
		for(const char* extension : extensions) {
			//std::cout << "\t" << extension << std::endl;
		}

		return extensions;
	}

	void CreateInstance() {
		if (isValidationLayersEnabled && !CheckValidationLayerSupport()) {
			throw std::runtime_error("Validation Layers Are Requested But Not Available!");
		}

		VkApplicationInfo appInfo{};
		appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
		appInfo.pApplicationName = "Vulkan App";
		appInfo.applicationVersion = VK_MAKE_API_VERSION(0, 1, 0, 0);
		appInfo.pEngineName = "No Engine";
		appInfo.engineVersion = VK_MAKE_API_VERSION(0, 1, 0, 0);
		appInfo.apiVersion = VK_API_VERSION_1_3;

		VkInstanceCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
		createInfo.pApplicationInfo = &appInfo;

		AvailableInstanceExtensions();

		std::vector<const char*> extensions = GetRequiredInstanceExtensions();
		createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());
		createInfo.ppEnabledExtensionNames = extensions.data();

		if (isValidationLayersEnabled) {
			createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
			createInfo.ppEnabledLayerNames = validationLayers.data();
		} else {
			createInfo.enabledLayerCount = 0;
		}

		if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
			throw std::runtime_error("Instance Creation Failed!");
		}
	}

	static VKAPI_ATTR VkBool32 VKAPI_CALL DebugCallback(
	VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
	VkDebugUtilsMessageTypeFlagsEXT messageType,
	const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData,
	void *pUserData) {
		std::cerr << "Validation Layer: " << pCallbackData->pMessage << std::endl;

		return VK_FALSE;
	}

	void SetupDebugMessenger() {
		if (!isValidationLayersEnabled) {
			return;
		}

		VkDebugUtilsMessengerCreateInfoEXT createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
		createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
		VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
		createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
		VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
		VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
		createInfo.pfnUserCallback = DebugCallback;

		if (CreateDebugUtilsMessengerEXT(instance, &createInfo, nullptr, &debugMessenger) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Set Up Debug Messenger!");
		}
	}

	void CreateSurface() {
		if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
			throw std::runtime_error("Window Surface Creation Failed!");
		}
	}

	QueueFamilyIndices FindQueueFamilies(VkPhysicalDevice device) {
		QueueFamilyIndices indices;
		uint32_t queueFamilyCount = 0;
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);
		std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

		int i = 0;
		for (const VkQueueFamilyProperties &queueFamily : queueFamilies) {
			if ((queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) &&
				(queueFamily.queueFlags & VK_QUEUE_COMPUTE_BIT)) {
				indices.graphicsComputeFamily = i;
			}

			VkBool32 presentSupport = false;
			vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);
			if (presentSupport) {
				indices.presentFamily = i;
			}

			if (indices.IsComplete()) {
				break;
			}
			i++;
		}

		return indices;
	}

	SwapChainSupportDetails QuerySwapChainSupport(VkPhysicalDevice device) {
		SwapChainSupportDetails details;
		vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities);

		uint32_t formatCount;
		vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr);
		if (formatCount != 0) {
			details.formats.resize(formatCount);
			vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data());
		}

		uint32_t presentModeCount;
		vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr);
		if (presentModeCount != 0) {
			details.presentModes.resize(presentModeCount);
			vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data());
		}

		return details;
	}

	bool CheckDeviceExtensionsSupport(VkPhysicalDevice device) {
		uint32_t extensionCount;
		vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);
		std::vector<VkExtensionProperties> availableExtensions(extensionCount);
		vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data());

		std::cout << "Available Device Extensions:" << std::endl;
		for (const VkExtensionProperties& availableExtension : availableExtensions) {
			//std::cout << "\t" << availableExtension.extensionName << std::endl;
		}

		std::cout << "Required Device Extensions:" << std::endl;
		for (const char* deviceExtension : deviceExtensions) {
			//std::cout << "\t" << deviceExtension << std::endl;
		}

		std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());
		for (const VkExtensionProperties& extension : availableExtensions) {
			requiredExtensions.erase(extension.extensionName);
		}

		return requiredExtensions.empty();
	}

	bool IsDeviceSuitable(VkPhysicalDevice device) {
		QueueFamilyIndices indices = FindQueueFamilies(device);

		bool isExtensionsSupported = CheckDeviceExtensionsSupport(device);

		bool isSwapChainAdequate = false;
		if (isExtensionsSupported) {
			SwapChainSupportDetails swapChainSupport = QuerySwapChainSupport(device);
			isSwapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
		}

		return indices.IsComplete() && isExtensionsSupported && isSwapChainAdequate;
	}

	int RateDeviceSuitability(VkPhysicalDevice device) {
		int score = 0;
		VkPhysicalDeviceProperties deviceProperties;
		vkGetPhysicalDeviceProperties(device, &deviceProperties);
		VkPhysicalDeviceFeatures deviceFeatures;
		vkGetPhysicalDeviceFeatures(device, &deviceFeatures);

		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU) {
			score = 100;
		}
		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU) {
			score = 300;
		}
		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
			score = 1000;
		}

		if (!IsDeviceSuitable(device)) {
			return 0;
		}

		return score;
	}

	void PickPhysicalDevice() {
		uint32_t devicesCount;
		vkEnumeratePhysicalDevices(instance, &devicesCount, nullptr);
		if (devicesCount == 0) {
			throw std::runtime_error("Failed To Find GPUs With Vulkan Support!");
		}

		std::vector<VkPhysicalDevice> devices(devicesCount);
		vkEnumeratePhysicalDevices(instance, &devicesCount, devices.data());

		std::multimap<int, VkPhysicalDevice> deviceScores;
		for (const VkPhysicalDevice &device : devices) {
			int score = RateDeviceSuitability(device);
			deviceScores.insert(std::make_pair(score, device));
		}

		if (deviceScores.rbegin()->first > 0) {
			physicalDevice = deviceScores.rbegin()->second;
		} else {
			throw std::runtime_error("Failed To Find A Suitable GPU!");
		}
	}

	void CreateLogicalDevice() {
		QueueFamilyIndices indices = FindQueueFamilies(physicalDevice);

		std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
		std::set<uint32_t> uniqueQueueFamilies = {indices.graphicsComputeFamily.value(), indices.presentFamily.value()};

		float queuePriority = 1.0f;
		for (uint32_t queueFamily : uniqueQueueFamilies) {
			VkDeviceQueueCreateInfo queueCreateInfo{};
			queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
			queueCreateInfo.queueFamilyIndex = queueFamily;
			queueCreateInfo.queueCount = 1;
			queueCreateInfo.pQueuePriorities = &queuePriority;
			queueCreateInfos.push_back(queueCreateInfo);
		}

		VkPhysicalDeviceFeatures deviceFeatures{};

		VkPhysicalDeviceUniformBufferStandardLayoutFeatures UBOLayoutFeatures{};
		UBOLayoutFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
		UBOLayoutFeatures.uniformBufferStandardLayout = VK_TRUE;

		VkDeviceCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
		createInfo.pNext = &UBOLayoutFeatures;
		createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
		createInfo.pQueueCreateInfos = queueCreateInfos.data();
		createInfo.pEnabledFeatures = &deviceFeatures;
		createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size());
		createInfo.ppEnabledExtensionNames = deviceExtensions.data();

		if (isValidationLayersEnabled) {
			createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
			createInfo.ppEnabledLayerNames = validationLayers.data();
		} else {
			createInfo.enabledLayerCount = 0;
		}

		if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) {
			throw std::runtime_error("Logical Device Creation Failed!");
		}

		vkGetDeviceQueue(device, indices.graphicsComputeFamily.value(), 0, &graphicsQueue);
		vkGetDeviceQueue(device, indices.graphicsComputeFamily.value(), 0, &computeQueue);
		vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &presentQueue);
	}

	VkSurfaceFormatKHR ChooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) {
		std::cout << "Available Surface Formats:" << std::endl;
		for (const VkSurfaceFormatKHR& availableFormat : availableFormats) {
			for (const colorSpaceName& colorSpace : colorSpaces) {
				if (availableFormat.colorSpace == colorSpace.space) {
					for (const colorFormatName& colorFormat : colorFormats) {
						if (availableFormat.format == colorFormat.format) {
							//std::cout << "\t" << colorFormat.name << ", " << colorSpace.name << std::endl;
						}
					}
				}
			}
		}

		VkSurfaceFormatKHR surfaceFormat;
		for (const VkSurfaceFormatKHR& availableFormat : availableFormats) {
			if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM) {
				surfaceFormat = availableFormat;
				for (const colorSpaceName& colorSpace : colorSpaces) {
					if (surfaceFormat.colorSpace == colorSpace.space) {
						std::cout << "Using VK_FORMAT_B8G8R8A8_UNORM Format With " << colorSpace.name << " Color Space" << std::endl;
						return surfaceFormat;
					}
				}
			}
		}

		throw std::runtime_error("Failed To Choose Appropriate Surface Format!");
	}

	VkPresentModeKHR ChooseSwapPresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes) {
		std::vector<presentModeName> availablePresentModesNames;
		std::cout << "Available Presentation Modes:" << std::endl;
		for (const VkPresentModeKHR& availablePresentMode : availablePresentModes) {
			for (const presentModeName& presentMode : presentModes) {
				if (availablePresentMode == presentMode.mode) {
					//std::cout << "\t" << presentMode.name << std::endl;
					availablePresentModesNames.push_back(presentMode);
					break;
				}
			}
		}

		if (VSync) {
			for (const presentModeName& availablePresentModeName : availablePresentModesNames) {
				if (availablePresentModeName.mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR) {
					std::cout << "Using Presentation Mode VK_PRESENT_MODE_FIFO_RELAXED_KHR" << std::endl;
					return availablePresentModeName.mode;
				}
			}

			std::cout << "Using Presentation Mode VK_PRESENT_MODE_FIFO_KHR" << std::endl;
			return VK_PRESENT_MODE_FIFO_KHR;
		} else {
			for (const presentModeName& availablePresentModeName : availablePresentModesNames) {
				if (availablePresentModeName.mode == VK_PRESENT_MODE_MAILBOX_KHR) {
					std::cout << "Using Presentation Mode VK_PRESENT_MODE_MAILBOX_KHR" << std::endl;
					return availablePresentModeName.mode;
				}
			}

			for (const presentModeName& availablePresentModeName : availablePresentModesNames) {
				if (availablePresentModeName.mode == VK_PRESENT_MODE_IMMEDIATE_KHR) {
					std::cout << "Using Presentation Mode VK_PRESENT_MODE_IMMEDIATE_KHR" << std::endl;
					return availablePresentModeName.mode;
				}
			}

			throw std::runtime_error("Disabling VSync Is Not Supported!");
		}
	}

	VkExtent2D ChooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {
		if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
			W = capabilities.currentExtent.width;
			H = capabilities.currentExtent.height;
			return capabilities.currentExtent;
		} else {
			glfwGetWindowSize(window, &W, &H);
			VkExtent2D actualExtent = {
				static_cast<uint32_t>(W),
				static_cast<uint32_t>(H)
			};
			actualExtent.width = std::clamp(actualExtent.width,
				capabilities.minImageExtent.width,
				capabilities.maxImageExtent.width);
			actualExtent.height = std::clamp(actualExtent.height,
				capabilities.minImageExtent.height,
				capabilities.maxImageExtent.height);

			return actualExtent;
		}
	}

	void CreateSwapChain() {
		SwapChainSupportDetails swapChainSupport = QuerySwapChainSupport(physicalDevice);

		VkSurfaceFormatKHR surfaceFormat = ChooseSwapSurfaceFormat(swapChainSupport.formats);
		VkPresentModeKHR presentMode = ChooseSwapPresentMode(swapChainSupport.presentModes);
		VkExtent2D extent = ChooseSwapExtent(swapChainSupport.capabilities);

		uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 2;
		if ((swapChainSupport.capabilities.maxImageCount > 0) && (imageCount > swapChainSupport.capabilities.maxImageCount)) {
			imageCount = swapChainSupport.capabilities.maxImageCount;
		}

		VkSwapchainCreateInfoKHR createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
		createInfo.surface = surface;
		createInfo.minImageCount = imageCount;
		createInfo.imageFormat = surfaceFormat.format;
		createInfo.imageColorSpace = surfaceFormat.colorSpace;
		createInfo.imageExtent = extent;
		createInfo.imageArrayLayers = 1;
		createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

		QueueFamilyIndices indices = FindQueueFamilies(physicalDevice);
		uint32_t queueFamilyIndices[] = {indices.graphicsComputeFamily.value(), indices.presentFamily.value()};

		if (indices.graphicsComputeFamily != indices.presentFamily) {
			createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; // Slower
			createInfo.queueFamilyIndexCount = 2;
			createInfo.pQueueFamilyIndices = queueFamilyIndices;
		} else {
			createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; // Faster
			createInfo.queueFamilyIndexCount = 0; // Optional
			createInfo.pQueueFamilyIndices = nullptr; // Optional
		}

		createInfo.preTransform = swapChainSupport.capabilities.currentTransform; // No Transformation To Images
		createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; // Ignore Alpha Channels
		createInfo.presentMode = presentMode;
		createInfo.clipped = VK_FALSE; // We Need To Care About Pixels Which Are Not Visible So, VK_FALSE

		createInfo.oldSwapchain = VK_NULL_HANDLE; // TODO, We Need This To Be Enabled To Resize Window, Etc.

		if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Swap Chain!");
		}

		vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr);
		swapChainImages.resize(imageCount);
		vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data());

		swapChainImageFormat = surfaceFormat.format;
	}

	void CreateSwapChainImageViews() {
		VkImageViewCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
		createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
		createInfo.format = swapChainImageFormat;
		createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
		createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
		createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
		createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;

		swapChainImageViews.resize(swapChainImages.size());

		for (size_t i = 0; i < swapChainImages.size(); i++) {
			createInfo.image = swapChainImages[i];
			createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
			createInfo.subresourceRange.baseMipLevel = 0;
			createInfo.subresourceRange.levelCount = 1;
			createInfo.subresourceRange.baseArrayLayer = 0;
			createInfo.subresourceRange.layerCount = 1;

			if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Create Image Views!");
			}
		}
	}

	void CreateRenderPass() {
		std::vector<VkAttachmentDescription> colorAttachments{};
		VkAttachmentReference subpass1ColorAttachmentRefs{};
		VkAttachmentReference subpass2ColorAttachmentRef{};
		std::vector<VkSubpassDescription> subpass{};
		std::vector<VkSubpassDependency> dependency{};
		VkRenderPassCreateInfo createInfo{};

		colorAttachments.resize(2);
		subpass.resize(2);
		dependency.resize(2);

		colorAttachments[0].format = swapChainImageFormat;
		colorAttachments[0].samples = VK_SAMPLE_COUNT_1_BIT;
		colorAttachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
		colorAttachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
		colorAttachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
		colorAttachments[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
		colorAttachments[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
		colorAttachments[0].finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		colorAttachments[1].format = swapChainImageFormat;
		colorAttachments[1].samples = VK_SAMPLE_COUNT_1_BIT;
		colorAttachments[1].loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
		colorAttachments[1].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
		colorAttachments[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
		colorAttachments[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
		colorAttachments[1].initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
		colorAttachments[1].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

		subpass1ColorAttachmentRefs.attachment = 0;
		subpass1ColorAttachmentRefs.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		subpass2ColorAttachmentRef.attachment = 1;
		subpass2ColorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		subpass[0].pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
		subpass[0].colorAttachmentCount = 1;
		subpass[0].pColorAttachments = &subpass1ColorAttachmentRefs;

		subpass[1].pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
		subpass[1].colorAttachmentCount = 1;
		subpass[1].pColorAttachments = &subpass2ColorAttachmentRef;

		dependency[0].srcSubpass = VK_SUBPASS_EXTERNAL;
		dependency[0].dstSubpass = 0;
		dependency[0].srcStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
		dependency[0].dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		dependency[0].srcAccessMask = 0;
		dependency[0].dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
		dependency[0].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;

		dependency[1].srcSubpass = 0;
		dependency[1].dstSubpass = 1;
		dependency[1].srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		dependency[1].dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		dependency[1].srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
		dependency[1].dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
		dependency[1].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;

		createInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
		createInfo.attachmentCount = static_cast<uint32_t>(colorAttachments.size());
		createInfo.pAttachments = colorAttachments.data();
		createInfo.subpassCount = static_cast<uint32_t>(subpass.size());
		createInfo.pSubpasses = subpass.data();
		createInfo.dependencyCount = static_cast<uint32_t>(dependency.size());
		createInfo.pDependencies = dependency.data();

		if (vkCreateRenderPass(device, &createInfo, nullptr, &renderPass) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Render Pass!");
		}
	}

	void CreateDescriptorSetLayout() {
		std::array<VkDescriptorSetLayoutBinding, 2> layoutBinding{};
		VkDescriptorSetLayoutCreateInfo layoutInfo{};

		layoutBinding[0].binding = 0;
		layoutBinding[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		layoutBinding[0].descriptorCount = 1;
		layoutBinding[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
		layoutBinding[0].pImmutableSamplers = nullptr;

		layoutBinding[1].binding = 1;
		layoutBinding[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
		layoutBinding[1].descriptorCount = 1;
		layoutBinding[1].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
		layoutBinding[1].pImmutableSamplers = nullptr;

		layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
		layoutInfo.bindingCount = static_cast<uint32_t>(layoutBinding.size());
		layoutInfo.pBindings = layoutBinding.data();
		layoutInfo.flags = 0;

		if (vkCreateDescriptorSetLayout(device, &layoutInfo, nullptr, &descriptorSetLayout) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Descriptor Set Layout!");
		}
	}

	std::vector<uint32_t> GLSLToSPIRV(const std::string& code, const EShLanguage stage) {
		glslang::TShader shader(stage);

		const char* codes[] = {code.c_str()};
		const char* const* ptrCodes = codes;
		shader.setStrings(ptrCodes, 1);

		shader.setEnvInput(glslang::EShSourceGlsl, stage, glslang::EShClientVulkan, 100);
		shader.setEnvClient(glslang::EShClientVulkan, glslang::EShTargetVulkan_1_3);
		shader.setEnvTarget(glslang::EshTargetSpv, glslang::EShTargetSpv_1_6);

		shader.parse(GetDefaultResources(), 100, false, EShMsgDefault);

		std::string shaderLog;
		shaderLog.append(shader.getInfoLog());
		if (stage == EShLangFragment) {
			std::cout << "Parsing Fragment Shader: ";
		}
		if (stage == EShLangVertex) {
			std::cout << "Parsing Vertex Shader: ";
		}
		if (stage == EShLangCompute) {
			std::cout << "Parsing Compute Shader: ";
		}
		if (shaderLog.size() > 0) {
			std::cout << shaderLog << std::endl;
		} else {
			std::cout << "Success" << std::endl;
		}

		glslang::TProgram program;
		program.addShader(&shader);
		program.link(EShMsgDefault);

		std::string programLog;
		programLog.append(program.getInfoLog());
		if (stage == EShLangFragment) {
			std::cout << "Linking Fragment Program: ";
		}
		if (stage == EShLangVertex) {
			std::cout << "Linking Vertex Program: ";
		}
		if (stage == EShLangCompute) {
			std::cout << "Linking Compute Program: ";
		}
		if (programLog.size() > 0) {
			std::cout << programLog << std::endl;
		} else {
			std::cout << "Success" << std::endl;
		}

		glslang::TIntermediate* intermediate = program.getIntermediate(stage);

		std::vector<uint32_t> spirv;
		glslang::GlslangToSpv(*intermediate, spirv);

		return spirv;
	}

	VkShaderModule CreateShaderModule(const std::vector<uint32_t>& code) {
		VkShaderModuleCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
		createInfo.codeSize = code.size() * sizeof(uint32_t);
		createInfo.pCode = code.data();

		VkShaderModule shaderModule;
		if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Shader Module!");
		}

		return shaderModule;
	}

	VkPipelineShaderStageCreateInfo CreateShaderStageInfo(VkShaderModule module, VkShaderStageFlagBits stage, const char* pName) {
		shaderModules.push_back(module);

		VkPipelineShaderStageCreateInfo shaderStageInfo{};
		shaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
		shaderStageInfo.stage = stage;
		shaderStageInfo.module = module;
		shaderStageInfo.pName = pName;
		shaderStageInfo.pSpecializationInfo = nullptr; // For Specifying Different Constants Instead Of Doing It In Runtime

		return shaderStageInfo;
	}

	void CreateGraphicsPipeline() {
		vertexShaderCode = ReadFile("../src/shader.vert");
		if (isRunFromExecutables) {
		vertexShaderCode = ReadFile("./src/shader.vert");
		}
		fragmentShaderCode = ReadFile("../src/shader.frag");
		if (isRunFromExecutables) {
		fragmentShaderCode = ReadFile("./src/shader.frag");
		}

		std::array<VkPipelineShaderStageCreateInfo, 2> shaderStages;

		shaderStages[0] = CreateShaderStageInfo(CreateShaderModule(GLSLToSPIRV(vertexShaderCode, EShLangVertex)), VK_SHADER_STAGE_VERTEX_BIT, "main");
		shaderStages[1] = CreateShaderStageInfo(CreateShaderModule(GLSLToSPIRV(fragmentShaderCode, EShLangFragment)), VK_SHADER_STAGE_FRAGMENT_BIT, "main");

		VkVertexInputBindingDescription bindingDescription = Vertex::getBindingDescription();
		VkVertexInputAttributeDescription attributeDescription = Vertex::getAttributeDescription();
		VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
		vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
		vertexInputInfo.vertexBindingDescriptionCount = 1;
		vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
		vertexInputInfo.vertexAttributeDescriptionCount = 1;
		vertexInputInfo.pVertexAttributeDescriptions = &attributeDescription;

		VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
		inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
		inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
		inputAssembly.primitiveRestartEnable = VK_FALSE;

		VkPipelineViewportStateCreateInfo viewportState{};
		viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
		viewportState.viewportCount = 1;
		viewportState.scissorCount = 1;

		VkPipelineRasterizationStateCreateInfo rasterizer{};
		rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
		rasterizer.depthClampEnable = VK_FALSE;
		rasterizer.rasterizerDiscardEnable = VK_FALSE;
		rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
		rasterizer.lineWidth = 1.0f;
		rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
		rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
		rasterizer.depthBiasEnable = VK_FALSE;

		VkPipelineMultisampleStateCreateInfo multisampling{};
		multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
		multisampling.sampleShadingEnable = VK_FALSE;
		multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

		VkPipelineColorBlendAttachmentState colorBlendAttachment{};
		colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
		VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
		colorBlendAttachment.blendEnable = VK_FALSE;

		VkPipelineColorBlendStateCreateInfo colorBlending{};
		colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
		colorBlending.logicOpEnable = VK_FALSE;
		colorBlending.attachmentCount = 1;
		colorBlending.pAttachments = &colorBlendAttachment;

		std::vector<VkDynamicState> dynamicStates = {
			VK_DYNAMIC_STATE_VIEWPORT,
			VK_DYNAMIC_STATE_SCISSOR
		};
		VkPipelineDynamicStateCreateInfo dynamicState{};
		dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
		dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
		dynamicState.pDynamicStates = dynamicStates.data();

		VkPushConstantRange pushConstantRange{};
		pushConstantRange.offset = 0;
		pushConstantRange.size = sizeof(PushConstantValues);
		pushConstantRange.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;

		// Uniforms And Push Values
		VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
		pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
		pipelineLayoutInfo.setLayoutCount = 1;
		pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout;
		pipelineLayoutInfo.pushConstantRangeCount = 1;
		pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;

		if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &graphicsPipelineLayout) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Graphics Pipeline Layout!");
		}

		VkGraphicsPipelineCreateInfo pipelineInfo{};
		pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
		pipelineInfo.stageCount = static_cast<uint32_t>(shaderStages.size());
		pipelineInfo.pStages = shaderStages.data();
		pipelineInfo.pVertexInputState = &vertexInputInfo;
		pipelineInfo.pInputAssemblyState = &inputAssembly;
		pipelineInfo.pViewportState = &viewportState;
		pipelineInfo.pRasterizationState = &rasterizer;
		pipelineInfo.pMultisampleState = &multisampling;
		pipelineInfo.pDepthStencilState = nullptr;
		pipelineInfo.pColorBlendState = &colorBlending;
		pipelineInfo.pDynamicState = &dynamicState;
		pipelineInfo.renderPass = renderPass;
		pipelineInfo.subpass = 0;
		pipelineInfo.layout = graphicsPipelineLayout;

		if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Graphics Pipeline!");
		}
	}

	void InsertSDF() {
		for (int i = (sdfs.size() - 1); i >= 0; i--) {
			std::string sdf = sdfs[i].glsl;
			std::string SDFName = "SDF";
			std::string SDFFunction = "\n    if ((set";
			std::string SDFMATERIALFunction;
			std::string SDFPos;
			std::string SDFNum = std::to_string(i + 1);
			std::string SDFCode = std::to_string(int(pow(2, i % 32)));

			SDFName.append(SDFNum);
			sdf.replace(sdf.find("sdf"), 3, SDFName);
			SDFName.append("MATERIAL");
			sdf.replace(sdf.find("sdfmaterial"), 11, SDFName);
			sdf.append("\n");

			SDFPos.append("(p - vec3(sdfs[");
			SDFPos.append(std::to_string(6 * i));
			SDFPos.append("], sdfs[");
			SDFPos.append(std::to_string(6 * i + 1));
			SDFPos.append("], sdfs[");
			SDFPos.append(std::to_string(6 * i + 2));
			SDFPos.append("]))");

			SDFFunction.append(std::to_string(((i - (i % 32)) / 32) + 1));
			SDFFunction.append(" & ");
			SDFFunction.append(SDFCode);
			SDFFunction.append(") == ");
			SDFFunction.append(SDFCode);
			SDFFunction.append(") sdf");
			SDFMATERIALFunction = SDFFunction;
			SDFFunction.append(" = min(sdf, SDF");
			SDFFunction.append(SDFNum);
			SDFFunction.append(SDFPos);
			SDFFunction.append(");");

			SDFMATERIALFunction.append("material = minMaterial(sdf, SDF");
			SDFMATERIALFunction.append(SDFNum);
			SDFMATERIALFunction.append(SDFPos);
			SDFMATERIALFunction.append(", sdfmaterial, SDF");
			SDFMATERIALFunction.append(SDFNum);
			SDFMATERIALFunction.append("MATERIAL");
			SDFMATERIALFunction.append(SDFPos);
			SDFMATERIALFunction.append(");");

			computeShaderCode.insert(computeShaderCode.find("// Put SDF Functions Here") + 26, SDFFunction);
			computeShaderCode.insert(computeShaderCode.find("// Put SDFMATERIAL Functions Here") + 34, SDFFunction);
			computeShaderCode.insert(computeShaderCode.find("// Put SDFMATERIAL Functions Here") + 34, SDFMATERIALFunction);
			computeShaderCode.insert(computeShaderCode.find("// All SDF Are Inserted Here") + 31, sdf);
		}
	}

	void CreateComputePipeline() {
		computeShaderCode = ReadFile("../src/shader.comp");
		if (isRunFromExecutables) {
		computeShaderCode = ReadFile("./src/shader.comp");
		}

		InsertSDF();

		VkPipelineShaderStageCreateInfo computeShaderStage{};
		computeShaderStage = CreateShaderStageInfo(CreateShaderModule(GLSLToSPIRV(computeShaderCode, EShLangCompute)), VK_SHADER_STAGE_COMPUTE_BIT, "main");

		VkPushConstantRange pushConstantRange{};
		pushConstantRange.offset = 0;
		pushConstantRange.size = sizeof(PushConstantValues);
		pushConstantRange.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;

		// Uniforms And Push Values
		VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
		pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
		pipelineLayoutInfo.setLayoutCount = 1;
		pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout;
		pipelineLayoutInfo.pushConstantRangeCount = 1;
		pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;

		if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &computePipelineLayout) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Compute Pipeline Layout!");
		}

		VkComputePipelineCreateInfo pipelineInfo{};
		pipelineInfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
		pipelineInfo.layout = computePipelineLayout;
		pipelineInfo.stage = computeShaderStage;

		if (vkCreateComputePipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &computePipeline) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Compute Pipeline!");
		}
	}

	void CreateCommandPool() {
		QueueFamilyIndices queueFamilyIndices = FindQueueFamilies(physicalDevice);

		VkCommandPoolCreateInfo poolInfo{};
		poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
		poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
		poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsComputeFamily.value();

		if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Command Pool!");
		}
	}

	uint32_t FindMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
		VkPhysicalDeviceMemoryProperties memoryProperties;
		vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memoryProperties);

		for (uint32_t i = 0; i < memoryProperties.memoryTypeCount; i++) {
			if ((typeFilter & (1 << i)) && ((memoryProperties.memoryTypes[i].propertyFlags & properties) == properties)) {
				return i;
			}
		}

		throw std::runtime_error("Failed To Find Suitable Memory Type!");
	}

	void CreateBuffer(VkDeviceSize size, VkBufferUsageFlags usage,
	VkMemoryPropertyFlags properties, VkBuffer& buffer, VkDeviceMemory& bufferMemory) {
		VkBufferCreateInfo bufferInfo{};
		bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
		bufferInfo.size = size;
		bufferInfo.usage = usage;
		bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

		if (vkCreateBuffer(device, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Buffer!");
		}

		VkMemoryRequirements memoryRequirements;
		vkGetBufferMemoryRequirements(device, buffer, &memoryRequirements);

		VkMemoryAllocateInfo allocateInfo{};
		allocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
		allocateInfo.allocationSize = memoryRequirements.size;
		allocateInfo.memoryTypeIndex = FindMemoryType(memoryRequirements.memoryTypeBits, properties);

		if (vkAllocateMemory(device, &allocateInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Allocate Buffer Memory!");
		}

		vkBindBufferMemory(device, buffer, bufferMemory, 0);
	}

	void CopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
		VkCommandBufferAllocateInfo allocateInfo{};
		allocateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
		allocateInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocateInfo.commandPool = commandPool;
		allocateInfo.commandBufferCount = 1;

		VkCommandBuffer commandBuffer;
		vkAllocateCommandBuffers(device, &allocateInfo, &commandBuffer);

		VkCommandBufferBeginInfo beginInfo{};
		beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
		beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

		vkBeginCommandBuffer(commandBuffer, &beginInfo);

		VkBufferCopy copyRegion{};
		copyRegion.srcOffset = 0;
		copyRegion.dstOffset = 0;
		copyRegion.size = size;
		vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

		vkEndCommandBuffer(commandBuffer);

		VkSubmitInfo submitInfo{};
		submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		submitInfo.commandBufferCount = 1;
		submitInfo.pCommandBuffers = &commandBuffer;

		vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE);
		vkQueueWaitIdle(graphicsQueue);

		vkFreeCommandBuffers(device, commandPool, 1, &commandBuffer);
	}

	void CreateVertexBuffer() {
		VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();

		VkBuffer stagingBuffer;
		VkDeviceMemory stagingBufferMemory;
		CreateBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
		stagingBuffer, stagingBufferMemory);

		void* data;
		vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
		memcpy(data, vertices.data(), (size_t)bufferSize);
		vkUnmapMemory(device, stagingBufferMemory);

		CreateBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT |
		VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
		vertexBuffer, vertexBufferMemory);

		CopyBuffer(stagingBuffer, vertexBuffer, bufferSize);

		vkDestroyBuffer(device, stagingBuffer, nullptr);
		vkFreeMemory(device, stagingBufferMemory, nullptr);
	}

	void CreateIndexBuffer() {
		VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

		VkBuffer stagingBuffer;
		VkDeviceMemory stagingBufferMemory;
		CreateBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
		stagingBuffer, stagingBufferMemory);

		void* data;
		vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
		memcpy(data, indices.data(), (size_t)bufferSize);
		vkUnmapMemory(device, stagingBufferMemory);

		CreateBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT |
		VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
		indexBuffer, indexBufferMemory);

		CopyBuffer(stagingBuffer, indexBuffer, bufferSize);

		vkDestroyBuffer(device, stagingBuffer, nullptr);
		vkFreeMemory(device, stagingBufferMemory, nullptr);
	}

	void CreateUniformBuffer() {
		for (int i = 0; i < std::size(CIEXYZ1931); i++) {
			ubo.CIEXYZ1931[i] = CIEXYZ1931[i];
		}

		VkDeviceSize bufferSize = sizeof(UniformBufferObject);

		uniformBuffers.resize(MAX_FRAMES_IN_FLIGHT);
		uniformBuffersMemory.resize(MAX_FRAMES_IN_FLIGHT);
		uniformBuffersMapped.resize(MAX_FRAMES_IN_FLIGHT);

		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			CreateBuffer(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
			VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
			uniformBuffers[i], uniformBuffersMemory[i]);

			vkMapMemory(device, uniformBuffersMemory[i], 0, bufferSize, 0, &uniformBuffersMapped[i]);
		}
	}

	void CreateTexelBuffer() {
		VkDeviceSize bufferSize = W * H * 4 * 4;

		CreateBuffer(bufferSize, VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
		VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, texelBuffer, texelBufferMemory);
	}

	void CreateTexelBufferView() {
		VkBufferViewCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
		createInfo.flags = 0;
		createInfo.buffer = texelBuffer;
		createInfo.format = texelBufferFormat;
		createInfo.offset = 0;
		createInfo.range = VK_WHOLE_SIZE;

		if (vkCreateBufferView(device, &createInfo, nullptr, &texelBufferView) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Texel Buffer View!");
		}
	}

	void CreateFramebuffers() {
		framebuffers.resize(swapChainImageViews.size());

		for (size_t i = 0; i < framebuffers.size(); i++) {
			std::vector<VkImageView> attachments;
			attachments.push_back(swapChainImageViews[i]);
			attachments.push_back(swapChainImageViews[i]);

			VkFramebufferCreateInfo createInfo{};
			createInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
			createInfo.renderPass = renderPass;
			createInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
			createInfo.pAttachments = attachments.data();
			createInfo.width = static_cast<uint32_t>(W);
			createInfo.height = static_cast<uint32_t>(H);
			createInfo.layers = 1;

			if (vkCreateFramebuffer(device, &createInfo, nullptr, &framebuffers[i]) != VK_SUCCESS) {
				std::runtime_error("Failed To Create Framebuffers!");
			}
		}
	}

	void CreateDescriptorPool() {
		std::array<VkDescriptorPoolSize, 2> poolSize{};
		VkDescriptorPoolCreateInfo poolInfo{};

		poolSize[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		poolSize[0].descriptorCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);

		poolSize[1].type = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
		poolSize[1].descriptorCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);

		poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
		poolInfo.poolSizeCount = static_cast<uint32_t>(poolSize.size());
		poolInfo.pPoolSizes = poolSize.data();
		poolInfo.maxSets = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);

		if (vkCreateDescriptorPool(device, &poolInfo, nullptr, &descriptorPool) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Descriptor Pool!");
		}
	}

	void UpdateDescriptorSet() {
		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			std::array<VkWriteDescriptorSet, 2> descriptorWrite{};

			VkDescriptorBufferInfo bufferInfo{};
			bufferInfo.buffer = uniformBuffers[i];
			bufferInfo.offset = 0;
			bufferInfo.range = sizeof(UniformBufferObject);

			descriptorWrite[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
			descriptorWrite[0].dstSet = descriptorSets[i];
			descriptorWrite[0].dstBinding = 0;
			descriptorWrite[0].dstArrayElement = 0;
			descriptorWrite[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
			descriptorWrite[0].descriptorCount = 1;
			descriptorWrite[0].pBufferInfo = &bufferInfo;
			descriptorWrite[0].pImageInfo = nullptr;
			descriptorWrite[0].pTexelBufferView = nullptr;

			VkDescriptorBufferInfo texelBufferInfo{};
			texelBufferInfo.buffer = texelBuffer;
			texelBufferInfo.offset = 0;
			texelBufferInfo.range = W * H * 4 * 4;

			descriptorWrite[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
			descriptorWrite[1].dstSet = descriptorSets[i];
			descriptorWrite[1].dstBinding = 1;
			descriptorWrite[1].dstArrayElement = 0;
			descriptorWrite[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
			descriptorWrite[1].descriptorCount = 1;
			descriptorWrite[1].pBufferInfo = &texelBufferInfo;
			descriptorWrite[1].pImageInfo = nullptr;
			descriptorWrite[1].pTexelBufferView = &texelBufferView;

			vkUpdateDescriptorSets(device, static_cast<uint32_t>(descriptorWrite.size()), descriptorWrite.data(), 0, nullptr);
		}
	}

	void CreateDescriptorSet() {
		VkDescriptorSetAllocateInfo allocateInfo{};
		allocateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
		allocateInfo.descriptorPool = descriptorPool;
		allocateInfo.descriptorSetCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);
		std::vector<VkDescriptorSetLayout> layouts(MAX_FRAMES_IN_FLIGHT, descriptorSetLayout);
		allocateInfo.pSetLayouts = layouts.data();

		descriptorSets.resize(MAX_FRAMES_IN_FLIGHT);
		if (vkAllocateDescriptorSets(device, &allocateInfo, descriptorSets.data()) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Allocate Descriptor Sets!");
		}

		UpdateDescriptorSet();
	}

	void CreateCommandBuffer() {
		graphicsCommandBuffers.resize(MAX_FRAMES_IN_FLIGHT);
		computeCommandBuffers.resize(MAX_FRAMES_IN_FLIGHT);

		std::array<VkCommandBufferAllocateInfo, 2> allocateInfo{};

		allocateInfo[0].sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
		allocateInfo[0].commandPool = commandPool;
		allocateInfo[0].level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocateInfo[0].commandBufferCount = static_cast<uint32_t>(graphicsCommandBuffers.size());

		allocateInfo[1].sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
		allocateInfo[1].commandPool = commandPool;
		allocateInfo[1].level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocateInfo[1].commandBufferCount = static_cast<uint32_t>(computeCommandBuffers.size());

		if (!OFFSCREENRENDER) {
		    if (vkAllocateCommandBuffers(device, &allocateInfo[0], graphicsCommandBuffers.data()) != VK_SUCCESS) {
		    	throw std::runtime_error("Failed To Allocate Graphics Command Buffers!");
		    }
		}

		if (vkAllocateCommandBuffers(device, &allocateInfo[1], computeCommandBuffers.data()) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Allocate Compute Command Buffers!");
		}
	}

	void CreateSyncObjects() {
		imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
		renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
		inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

		computeFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
		computeInFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

		VkSemaphoreCreateInfo semaphoreInfo{};
		semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

		VkFenceCreateInfo fenceInfo{};
		fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
		fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			if ((vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphores[i]) != VK_SUCCESS) ||
			(vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphores[i]) != VK_SUCCESS) ||
			(vkCreateFence(device, &fenceInfo, nullptr, &inFlightFences[i]) != VK_SUCCESS)) {
				throw std::runtime_error("Failed To Create Graphics Sync Objects For A Frame!");
			}

			if ((vkCreateSemaphore(device, &semaphoreInfo, nullptr, &computeFinishedSemaphores[i]) != VK_SUCCESS) ||
			(vkCreateFence(device, &fenceInfo, nullptr, &computeInFlightFences[i]) != VK_SUCCESS)) {
				throw std::runtime_error("Failed To Create Compute Sync Objects For A Frame!");
			}
		}
	}

    void InitVulkan() {
        CreateInstance();
		SetupDebugMessenger();
		CreateSurface();
		PickPhysicalDevice();
		CreateLogicalDevice();
		if (!OFFSCREENRENDER) {
			CreateSwapChain();
			CreateSwapChainImageViews();
			CreateRenderPass();
		}
		CreateDescriptorSetLayout();
		if (!OFFSCREENRENDER) {
		    CreateGraphicsPipeline();
		}
		CreateComputePipeline();
		CreateCommandPool();
		if (!OFFSCREENRENDER) {
	       	CreateVertexBuffer();
		    CreateIndexBuffer();
		}
		CreateUniformBuffer();
		CreateTexelBuffer();
		CreateTexelBufferView();
		if (!OFFSCREENRENDER) {
		    CreateFramebuffers();
		}
		CreateDescriptorPool();
		CreateDescriptorSet();
		CreateCommandBuffer();
		CreateSyncObjects();
    }

	void DarkStyle() {
		ImGuiStyle* style = &ImGui::GetStyle();

		style->Colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
		style->Colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
		style->Colors[ImGuiCol_WindowBg]               = ImVec4(0.04f, 0.04f, 0.04f, 0.94f);
		style->Colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
		style->Colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
		style->Colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
		style->Colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
		style->Colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
		style->Colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
		style->Colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
		style->Colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
		style->Colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
		style->Colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
		style->Colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
		style->Colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
		style->Colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
		style->Colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
		style->Colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
		style->Colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
		style->Colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
		style->Colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
		style->Colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
		style->Colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_Separator]              = style->Colors[ImGuiCol_Border];
		style->Colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
		style->Colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
		style->Colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
		style->Colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
		style->Colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
		style->Colors[ImGuiCol_Tab]                    = ImLerp(style->Colors[ImGuiCol_Header],       style->Colors[ImGuiCol_TitleBgActive], 0.80f);
		style->Colors[ImGuiCol_TabHovered]             = style->Colors[ImGuiCol_HeaderHovered];
		style->Colors[ImGuiCol_TabActive]              = ImLerp(style->Colors[ImGuiCol_HeaderActive], style->Colors[ImGuiCol_TitleBgActive], 0.60f);
		style->Colors[ImGuiCol_TabUnfocused]           = ImLerp(style->Colors[ImGuiCol_Tab],          style->Colors[ImGuiCol_TitleBg], 0.80f);
		style->Colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(style->Colors[ImGuiCol_TabActive],    style->Colors[ImGuiCol_TitleBg], 0.40f);
		style->Colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
		style->Colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
		style->Colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
		style->Colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
		style->Colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
		style->Colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
		style->Colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
		style->Colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
		style->Colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
		style->Colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
		style->Colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
		style->Colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
		style->Colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
		style->Colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
	}

	void InitImGui() {
		VkDescriptorPoolSize poolSize[] =
		{
			{ VK_DESCRIPTOR_TYPE_SAMPLER, 1000 },
			{ VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000 },
			{ VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1000 },
			{ VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1000 },
			{ VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, 1000 },
			{ VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, 1000 },
			{ VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000 },
			{ VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000 },
			{ VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000 },
			{ VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000 },
			{ VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000 }
		};

		VkDescriptorPoolCreateInfo poolInfo{};
		poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
		poolInfo.poolSizeCount = std::size(poolSize);
		poolInfo.pPoolSizes = poolSize;
		poolInfo.maxSets = 1000;
		poolInfo.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;

		if(vkCreateDescriptorPool(device, &poolInfo, nullptr, &imguiDescriptorPool) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create ImGui Descriptor Pool!");
		}

		IMGUI_CHECKVERSION();

		ImGui::CreateContext();

		io = &ImGui::GetIO(); (void)io;
		io->ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

		DarkStyle();

		ImGui_ImplGlfw_InitForVulkan(window, true);

		ImGui_ImplVulkan_InitInfo initInfo{};
		initInfo.Instance = instance;
		initInfo.PhysicalDevice = physicalDevice;
		initInfo.Device = device;
		initInfo.Queue = graphicsQueue;
		initInfo.QueueFamily = FindQueueFamilies(physicalDevice).graphicsComputeFamily.value();
		initInfo.DescriptorPool = imguiDescriptorPool;
		initInfo.MinImageCount = static_cast<uint32_t>(swapChainImageViews.size());
		initInfo.ImageCount = static_cast<uint32_t>(swapChainImageViews.size());
		initInfo.MSAASamples = VK_SAMPLE_COUNT_1_BIT;
		initInfo.RenderPass = renderPass;
		initInfo.Subpass = 1;
		initInfo.UseDynamicRendering = false;

		ImGui_ImplVulkan_Init(&initInfo);

		ImGui_ImplVulkan_CreateFontsTexture();
	}

	void DefaultScene() {
		scene = nlohmann::ordered_json::parse(ReadFile("../scenes/scene0.json"));
	}

	void UpdateFromJSON() {
	    cameraShots.resize(scene["camera"]["numShots"]);
	    for (int i = 0; i < scene["camera"]["numShots"]; i++) {
			cameraShots[i].pos.x = scene["camera"]["position"][i][0];
    		cameraShots[i].pos.y = scene["camera"]["position"][i][1];
    		cameraShots[i].pos.z = scene["camera"]["position"][i][2];

    		cameraShots[i].angle.x = scene["camera"]["angle"][i][0];
    		cameraShots[i].angle.y = scene["camera"]["angle"][i][1];
		}

		camera.pos.x = cameraShots[cameraShotIndex - 1].pos.x;
		camera.pos.y = cameraShots[cameraShotIndex - 1].pos.y;
		camera.pos.z = cameraShots[cameraShotIndex - 1].pos.z;

		camera.angle.x = cameraShots[cameraShotIndex - 1].angle.x;
		camera.angle.y = cameraShots[cameraShotIndex - 1].angle.y;

		camera.ISO = scene["camera"]["ISO"];

		camera.size = scene["camera"]["size"];

		camera.apertureSize = scene["camera"]["apertureSize"];

		camera.apertureDist = scene["camera"]["apertureDistance"];

		camera.lensRadius = scene["camera"]["lensRadius"];

		camera.lensFocalLength = scene["camera"]["lensFocalLength"];

		camera.lensThickness = scene["camera"]["lensThickness"];

		camera.lensDistance = scene["camera"]["lensDistance"];

		spheres.resize(scene["sphere"].size());
		for (size_t i = 0; i < spheres.size(); i++) {
			spheres[i].pos[0] = scene["sphere"][i]["position"][0];
			spheres[i].pos[1] = scene["sphere"][i]["position"][1];
			spheres[i].pos[2] = scene["sphere"][i]["position"][2];

			spheres[i].radius = scene["sphere"][i]["radius"];

			spheres[i].materialID = scene["sphere"][i]["materialID"];
			spheres[i].lightID = scene["sphere"][i]["lightID"];
		}

		planes.resize(scene["plane"].size());
		for (size_t i = 0; i < planes.size(); i++) {
			planes[i].pos[0] = scene["plane"][i]["position"][0];
			planes[i].pos[1] = scene["plane"][i]["position"][1];
			planes[i].pos[2] = scene["plane"][i]["position"][2];

			planes[i].materialID = scene["plane"][i]["materialID"];
			planes[i].lightID = scene["plane"][i]["lightID"];
		}

		boxes.resize(scene["box"].size());
		for (size_t i = 0; i < boxes.size(); i++) {
			boxes[i].pos[0] = scene["box"][i]["position"][0];
			boxes[i].pos[1] = scene["box"][i]["position"][1];
			boxes[i].pos[2] = scene["box"][i]["position"][2];

			boxes[i].rotation[0] = scene["box"][i]["rotation"][0];
			boxes[i].rotation[1] = scene["box"][i]["rotation"][1];
			boxes[i].rotation[2] = scene["box"][i]["rotation"][2];

			boxes[i].size[0] = scene["box"][i]["size"][0];
			boxes[i].size[1] = scene["box"][i]["size"][1];
			boxes[i].size[2] = scene["box"][i]["size"][2];

			boxes[i].materialID = scene["box"][i]["materialID"];
			boxes[i].lightID = scene["box"][i]["lightID"];
		}

		lenses.resize(scene["lens"].size());
		for (size_t i = 0; i < lenses.size(); i++) {
			lenses[i].pos[0] = scene["lens"][i]["position"][0];
			lenses[i].pos[1] = scene["lens"][i]["position"][1];
			lenses[i].pos[2] = scene["lens"][i]["position"][2];

			lenses[i].rotation[0] = scene["lens"][i]["rotation"][0];
			lenses[i].rotation[1] = scene["lens"][i]["rotation"][1];
			lenses[i].rotation[2] = scene["lens"][i]["rotation"][2];

			lenses[i].radius = scene["lens"][i]["radius"];

			lenses[i].focalLength = scene["lens"][i]["focalLength"];

			lenses[i].thickness = scene["lens"][i]["thickness"];

			lenses[i].isConverging = scene["lens"][i]["isConverging"];

			lenses[i].materialID = scene["lens"][i]["materialID"];
			lenses[i].lightID = scene["lens"][i]["lightID"];
		}

		cyclides.resize(scene["cyclide"].size());
		for (size_t i = 0; i < cyclides.size(); i++) {
			cyclides[i].pos[0] = scene["cyclide"][i]["position"][0];
			cyclides[i].pos[1] = scene["cyclide"][i]["position"][1];
			cyclides[i].pos[2] = scene["cyclide"][i]["position"][2];

			cyclides[i].rotation[0] = scene["cyclide"][i]["rotation"][0];
			cyclides[i].rotation[1] = scene["cyclide"][i]["rotation"][1];
			cyclides[i].rotation[2] = scene["cyclide"][i]["rotation"][2];

			cyclides[i].scale[0] = scene["cyclide"][i]["scale"][0];
			cyclides[i].scale[1] = scene["cyclide"][i]["scale"][1];
			cyclides[i].scale[2] = scene["cyclide"][i]["scale"][2];

			cyclides[i].a = scene["cyclide"][i]["a"];
			cyclides[i].b = scene["cyclide"][i]["b"];
			cyclides[i].c = scene["cyclide"][i]["c"];
			cyclides[i].d = scene["cyclide"][i]["d"];

			cyclides[i].brad = scene["cyclide"][i]["boundingRadius"];

			cyclides[i].materialID = scene["cyclide"][i]["materialID"];
			cyclides[i].lightID = scene["cyclide"][i]["lightID"];
		}

		sdfs.resize(scene["sdf"].size());
		for (size_t i = 0; i < sdfs.size(); i++) {
			sdfs[i].pos[0] = scene["sdf"][i]["position"][0];
			sdfs[i].pos[1] = scene["sdf"][i]["position"][1];
			sdfs[i].pos[2] = scene["sdf"][i]["position"][2];

			sdfs[i].size[0] = scene["sdf"][i]["boundingSize"][0];
			sdfs[i].size[1] = scene["sdf"][i]["boundingSize"][1];
			sdfs[i].size[2] = scene["sdf"][i]["boundingSize"][2];

			sdfs[i].glsl = scene["sdf"][i]["glsl"];
		}

		materials.resize(scene["material"].size());
		for (size_t i = 0; i < materials.size(); i++) {
			materials[i].reflection[0] = scene["material"][i]["reflection"]["peakWavelength"];
			materials[i].reflection[1] = scene["material"][i]["reflection"]["sigma"];
			materials[i].reflection[2] = (float)scene["material"][i]["reflection"]["isInvert"];
		}

		lights.resize(scene["light"].size());
		for (size_t i = 0; i < lights.size(); i++) {
			lights[i].emission[0] = scene["light"][i]["emission"]["temperature"];
			lights[i].emission[1] = scene["light"][i]["emission"]["luminosity"];
		}
	}

	void UpdateToJSON() {
		scene = nlohmann::ordered_json();

		scene["camera"]["numShots"] = cameraShots.size();

		for (int i = 0; i < cameraShots.size(); i++) {
    		scene["camera"]["position"][i][0] = RoundDecimal((double)cameraShots[i].pos.x, 1e5);
    		scene["camera"]["position"][i][1] = RoundDecimal((double)cameraShots[i].pos.y, 1e5);
    		scene["camera"]["position"][i][2] = RoundDecimal((double)cameraShots[i].pos.z, 1e5);

    		scene["camera"]["angle"][i][0] = RoundDecimal((double)cameraShots[i].angle.x, 1e5);
    		scene["camera"]["angle"][i][1] = RoundDecimal((double)cameraShots[i].angle.y, 1e5);
		}

		scene["camera"]["ISO"] = camera.ISO;

		scene["camera"]["size"] = RoundDecimal((double)camera.size, 1e5);

		scene["camera"]["apertureSize"] = RoundDecimal((double)camera.apertureSize, 1e5);

		scene["camera"]["apertureDistance"] = RoundDecimal((double)camera.apertureDist, 1e5);

		scene["camera"]["lensRadius"] = RoundDecimal((double)camera.lensRadius, 1e5);

		scene["camera"]["lensFocalLength"] = RoundDecimal((double)camera.lensFocalLength, 1e5);

		scene["camera"]["lensThickness"] = RoundDecimal((double)camera.lensThickness, 1e5);

		scene["camera"]["lensDistance"] = RoundDecimal((double)camera.lensDistance, 1e5);

		for (size_t i = 0; i < spheres.size(); i++) {
			scene["sphere"][i]["position"][0] = RoundDecimal((double)spheres[i].pos[0], 1e5);
			scene["sphere"][i]["position"][1] = RoundDecimal((double)spheres[i].pos[1], 1e5);
			scene["sphere"][i]["position"][2] = RoundDecimal((double)spheres[i].pos[2], 1e5);;

			scene["sphere"][i]["radius"] = RoundDecimal((double)spheres[i].radius, 1e5);

			scene["sphere"][i]["materialID"] = spheres[i].materialID;
			scene["sphere"][i]["lightID"] = spheres[i].lightID;
		}

		for (size_t i = 0; i < planes.size(); i++) {
			scene["plane"][i]["position"][0] = RoundDecimal((double)planes[i].pos[0], 1e5);
			scene["plane"][i]["position"][1] = RoundDecimal((double)planes[i].pos[1], 1e5);
			scene["plane"][i]["position"][2] = RoundDecimal((double)planes[i].pos[2], 1e5);

			scene["plane"][i]["materialID"] = planes[i].materialID;
			scene["plane"][i]["lightID"] = planes[i].lightID;
		}

		for (size_t i = 0; i < boxes.size(); i++) {
			scene["box"][i]["position"][0] = RoundDecimal((double)boxes[i].pos[0], 1e5);
			scene["box"][i]["position"][1] = RoundDecimal((double)boxes[i].pos[1], 1e5);
			scene["box"][i]["position"][2] = RoundDecimal((double)boxes[i].pos[2], 1e5);

			scene["box"][i]["rotation"][0] = RoundDecimal((double)boxes[i].rotation[0], 1e5);
			scene["box"][i]["rotation"][1] = RoundDecimal((double)boxes[i].rotation[1], 1e5);
			scene["box"][i]["rotation"][2] = RoundDecimal((double)boxes[i].rotation[2], 1e5);

			scene["box"][i]["size"][0] = RoundDecimal((double)boxes[i].size[0], 1e5);
			scene["box"][i]["size"][1] = RoundDecimal((double)boxes[i].size[1], 1e5);
			scene["box"][i]["size"][2] = RoundDecimal((double)boxes[i].size[2], 1e5);

			scene["box"][i]["materialID"] = boxes[i].materialID;
			scene["box"][i]["lightID"] = boxes[i].lightID;
		}

		for (size_t i = 0; i < lenses.size(); i++) {
			scene["lens"][i]["position"][0] = RoundDecimal((double)lenses[i].pos[0], 1e5);
			scene["lens"][i]["position"][1] = RoundDecimal((double)lenses[i].pos[1], 1e5);
			scene["lens"][i]["position"][2] = RoundDecimal((double)lenses[i].pos[2], 1e5);

			scene["lens"][i]["rotation"][0] = RoundDecimal((double)lenses[i].rotation[0], 1e5);
			scene["lens"][i]["rotation"][1] = RoundDecimal((double)lenses[i].rotation[1], 1e5);
			scene["lens"][i]["rotation"][2] = RoundDecimal((double)lenses[i].rotation[2], 1e5);

			scene["lens"][i]["radius"] = RoundDecimal((double)lenses[i].radius, 1e5);

			scene["lens"][i]["focalLength"] = RoundDecimal((double)lenses[i].focalLength, 1e5);

			scene["lens"][i]["thickness"] = RoundDecimal((double)lenses[i].thickness, 1e5);

			scene["lens"][i]["isConverging"] = lenses[i].isConverging;

			scene["lens"][i]["materialID"] = lenses[i].materialID;
			scene["lens"][i]["lightID"] = lenses[i].lightID;
		}

		for (size_t i = 0; i < cyclides.size(); i++) {
			scene["cyclide"][i]["position"][0] = RoundDecimal((double)cyclides[i].pos[0], 1e5);
			scene["cyclide"][i]["position"][1] = RoundDecimal((double)cyclides[i].pos[1], 1e5);
			scene["cyclide"][i]["position"][2] = RoundDecimal((double)cyclides[i].pos[2], 1e5);

			scene["cyclide"][i]["rotation"][0] = RoundDecimal((double)cyclides[i].rotation[0], 1e5);
			scene["cyclide"][i]["rotation"][1] = RoundDecimal((double)cyclides[i].rotation[1], 1e5);
			scene["cyclide"][i]["rotation"][2] = RoundDecimal((double)cyclides[i].rotation[2], 1e5);

			scene["cyclide"][i]["scale"][0] = RoundDecimal((double)cyclides[i].scale[0], 1e5);
			scene["cyclide"][i]["scale"][1] = RoundDecimal((double)cyclides[i].scale[1], 1e5);
			scene["cyclide"][i]["scale"][2] = RoundDecimal((double)cyclides[i].scale[2], 1e5);

			scene["cyclide"][i]["a"] = RoundDecimal((double)cyclides[i].a, 1e5);
			scene["cyclide"][i]["b"] = RoundDecimal((double)cyclides[i].b, 1e5);
			scene["cyclide"][i]["c"] = RoundDecimal((double)cyclides[i].c, 1e5);
			scene["cyclide"][i]["d"] = RoundDecimal((double)cyclides[i].d, 1e5);

			scene["cyclide"][i]["boundingRadius"] = RoundDecimal((double)cyclides[i].brad, 1e5);

			scene["cyclide"][i]["materialID"] = cyclides[i].materialID;
			scene["cyclide"][i]["lightID"] = cyclides[i].lightID;
		}

		for (size_t i = 0; i < sdfs.size(); i++) {
			scene["sdf"][i]["position"][0] = RoundDecimal((double)sdfs[i].pos[0], 1e5);
			scene["sdf"][i]["position"][1] = RoundDecimal((double)sdfs[i].pos[1], 1e5);
			scene["sdf"][i]["position"][2] = RoundDecimal((double)sdfs[i].pos[2], 1e5);

			scene["sdf"][i]["boundingSize"][0] = RoundDecimal((double)sdfs[i].size[0], 1e5);
			scene["sdf"][i]["boundingSize"][1] = RoundDecimal((double)sdfs[i].size[1], 1e5);
			scene["sdf"][i]["boundingSize"][2] = RoundDecimal((double)sdfs[i].size[2], 1e5);

			scene["sdf"][i]["glsl"] = sdfs[i].glsl;
		}

		for (size_t i = 0; i < materials.size(); i++) {
			scene["material"][i]["reflection"]["peakWavelength"] = RoundDecimal((double)materials[i].reflection[0], 1e5);
			scene["material"][i]["reflection"]["sigma"] = RoundDecimal((double)materials[i].reflection[1], 1e5);
			scene["material"][i]["reflection"]["isInvert"] = (bool)materials[i].reflection[2];
		}

		for (size_t i = 0; i < lights.size(); i++) {
			scene["light"][i]["emission"]["temperature"] = RoundDecimal((double)lights[i].emission[0], 1e5);
			scene["light"][i]["emission"]["luminosity"] = RoundDecimal((double)lights[i].emission[1], 1e5);
		}
	}

	void HandleEvents(glm::vec2& cursorPos, glm::vec2& cameraAngle, glm::vec3& deltaCamPos) {
		glfwPollEvents();

		if (!isCameraLocked) {
			glm::vec2 cursorPos1 = glm::vec2((float)(ImGui::GetMousePos().x) / (float)W, (float)(H - ImGui::GetMousePos().y) / (float)H);

			if (!isImGuiWindowFocused) {
				if (ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
					isReset = true;
					glm::vec2 dxdy = cursorPos1 - cursorPos;
					cameraAngle = cameraAngle - (360.0f * dxdy);
					if (cameraAngle.x > 360.0f) {
						cameraAngle.x = cameraAngle.x - 360.0f;
					}
					if (cameraAngle.x < 0.0f) {
						cameraAngle.x = 360.0f + cameraAngle.x;
					}
					if (cameraAngle.y > 90.0f) {
						cameraAngle.y = 90.0f;
					}
					if (cameraAngle.y < -90.0f) {
						cameraAngle.y = -90.0f;
					}
				}
			}

			cursorPos = cursorPos1;

			deltaCamPos.x = ((float)(ImGui::IsKeyDown(ImGuiKey_D)) - (float)(ImGui::IsKeyDown(ImGuiKey_A)));
			deltaCamPos.y = ((float)(ImGui::IsKeyDown(ImGuiKey_E)) - (float)(ImGui::IsKeyDown(ImGuiKey_Q)));
			deltaCamPos.z = ((float)(ImGui::IsKeyDown(ImGuiKey_W)) - (float)(ImGui::IsKeyDown(ImGuiKey_S)));

			if ((deltaCamPos.x != 0.0f) || (deltaCamPos.y != 0.0f) || (deltaCamPos.z != 0.0f)) {
				isReset = true;
			}
		}
    }

	void UpdateCameraPos(glm::vec3& cameraPos, glm::vec2 cameraAngle, glm::vec3 deltaCamPos) {
		// http://www.songho.ca/opengl/gl_anglestoaxes.html
		glm::vec2 theta = glm::vec2(-cameraAngle.y, cameraAngle.x);
		glm::mat3 mX = glm::mat3(1.0f, 0.0f, 0.0f, 0.0f, glm::cos(theta.x), -glm::sin(theta.x), 0.0f, glm::sin(theta.x), glm::cos(theta.x));
		glm::mat3 mY = glm::mat3(glm::cos(theta.y), 0.0f, glm::sin(theta.y), 0.0f, 1.0f, 0.0f, -glm::sin(theta.y), 0.0f, glm::cos(theta.y));
		glm::mat3 m = mX * mY;

		cameraPos = cameraPos + deltaCamPos * m;
	}

	void ItemsTable(const char* name, int& selection, int id, int size, bool isPrintID) {
		for (int i = id; i < (size + id); i++) {
			ImGui::PushID(i);
			ImGui::TableNextRow();
			ImGui::TableSetColumnIndex(0);

			std::string label;
			label.append(name);
			if (isPrintID) {
				label.append(std::to_string(i - id + 1));
			}

			bool isSelected = selection == i;

			if (ImGui::Selectable(label.data(), &isSelected, ImGuiSelectableFlags_SpanAllColumns)) {
				if (isSelected) {
					selection = i;
				}
			}

			ImGui::PopID();
		}
	}

	void ImGuiRender(std::vector<float>& framesGraph) {
		static sphere newSphere = { { 0.0f, 0.0f, 0.0f }, 1.0f, 1, 0 };
		static plane newPlane = { { 0.0f, 0.0f, 0.0f }, 1, 0 };
		static box newBox = { { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f }, 1, 0 };
		static lens newLens = { { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, 1.0f, 1.0f, 0.0f, true, 1, 0 };
		static cyclide newCyclide = { { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f }, 3.36, -3.17, -1.06, -1.50, 1, 0 };
		static sdf newSDF = { { 0.0f, 0.0f, 0.0f }, { 2.0f, 2.0f, 2.0f }, R"(
float sdf(in vec3 p){
	return length(p) - 1.0;
}

float sdfmaterial(in vec3 p)
{
    return 0.0;
})"
		};
		static material newMaterial = { { 550.0f, 100.0f, 0 } };
		static light newLight = { { 5500.0f, 1.0f } };

		static std::vector<float> spectrumGraph{};
		static std::vector<float> tonemapGraph{};

		ImGui_ImplVulkan_NewFrame();
		ImGui_ImplGlfw_NewFrame();
		ImGui::NewFrame();

		ImGuiWindowFlags WinFlags = ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize;

		{
			ImGui::Begin("Scene", NULL, WinFlags);
			ImGui::SetWindowPos(ImVec2(W - ImGui::GetWindowWidth(), 0));
			ImGui::Text("Render Time: %0.3f ms (%0.1f FPS)", 1000.0f * frameTime, 1.0f / frameTime);
			ImGui::PlotLines("", framesGraph.data(), (int)framesGraph.size(), 0, NULL, 0.0f, 30.0f, ImVec2(303, 100));
			ImGui::Text("Resolution: (%i, %i) px", W, H);
			ImGui::Text("Samples: %i", currentSamples);
			ImGui::Text("Camera Angle: (%0.3f, %0.3f)", camera.angle.x, camera.angle.y);
			ImGui::Text("Camera Pos: (%0.3f, %0.3f, %0.3f)", camera.pos.x, camera.pos.y, camera.pos.z);
			isVSyncChanged = ImGui::Checkbox("VSync", &VSync);
			ImGui::Checkbox("Lock Camera", &isCameraLocked);
			ImGui::DragFloat("Min Latency", &minFrameTime, 1.0f, 0.0f, 1e7f);
			isReset |= ImGui::DragInt("Samples/Frame", &samplesPerFrame, 0.02f, 1, 100);
			isReset |= ImGui::DragInt("Path Length", &pathLength, 0.02f, 1, 100000);
			isLoadScene |= ImGui::Button("Load Scene", ImVec2(303, 0));
			isSaveScene |= ImGui::Button("Save Scene", ImVec2(303, 0));
			isSaveRender |= ImGui::Button("Save Render", ImVec2(303, 0));
			isRecompile |= ImGui::Button("Recompile", ImVec2(303, 0));
			ImGui::Separator();

			if (ImGui::CollapsingHeader("Post Processing")) {
				if (ImGui::BeginTable("Tonemap Table", 1)) {
					ImGui::TableSetupColumn("Tonemap");
					ImGui::TableHeadersRow();
					ItemsTable("None", tonemap, 0, 1, false);
					ItemsTable("Reinhard", tonemap, 1, 1, false);
					ItemsTable("ACES Film", tonemap, 2, 1, false);
					ItemsTable("DEUCES", tonemap, 3, 1, false);
					ImGui::EndTable();
				}

				tonemapGraph.clear();
				for (int i = 1; i < 101; i++) {
					float x = 0.01f * (float)i;
					tonemapGraph.push_back(tonemapping(x, tonemap));
				}

				ImGui::PlotLines("", tonemapGraph.data(), (int)tonemapGraph.size(), 0, NULL, 0.0f, 1.0f, ImVec2(303, 100));
			}

			if (ImGui::CollapsingHeader("Camera")) {
				isReset |= ImGui::DragFloat("Persistence", &persistence, 0.00025f, 0.00000f, 1.00000f, "%0.5f");
				isReset |= ImGui::DragInt("ISO", &camera.ISO, 50, 50, 819200);
				isReset |= ImGui::DragFloat("Camera Size", &camera.size, 0.001f, 0.001f, 5.0f, "%0.3f");
				isReset |= ImGui::DragFloat("Aperture Size", &camera.apertureSize, 0.0001f, 0.0001f, 10.0f, "%0.4f");
				isReset |= ImGui::DragFloat("Aperture Dist", &camera.apertureDist, 0.001f, 0.001f, camera.lensDistance, "%0.3f");
				float fov = 2.0f * glm::degrees(::atan(0.5f * camera.size / camera.apertureDist));
				ImGui::Text("FOV: %0.0f", fov);
				ImGui::Separator();

				ImGui::Text("Lens");
				isReset |= ImGui::DragFloat("Radius", &camera.lensRadius, 0.0005f, 0.0005f, 10.0f, "%0.4f");
				isReset |= ImGui::DragFloat("Focal Length", &camera.lensFocalLength, 0.0005f, 0.0005f, 10.0f, "%0.4f");
				isReset |= ImGui::DragFloat("Thickness", &camera.lensThickness, 0.0005f, 0.0f, 1.0f, "%0.4f");
				isReset |= ImGui::DragFloat("Distance", &camera.lensDistance, 0.001f, 0.001f, 100.0f, "%0.3f");
			}
			ImGui::Separator();

			if (ImGui::CollapsingHeader("Camera Shot")) {
			    int numShots = (int)cameraShots.size();

    			if (ImGui::BeginTable("Camera Shots Table", 1)) {
    				ImGui::TableSetupColumn("Camera Shots");
    				ImGui::TableHeadersRow();
    				ItemsTable("Camera Shot ", shotSelection, 0, numShots, true);
    				ImGui::EndTable();
    			}
    			ImGui::Separator();

			    if (ImGui::Button("Load Camera Shot", ImVec2(303, 0))) {
					if (numShots > 0) {
    					isReset = true;
    					camera.pos = cameraShots[shotSelection].pos;
    					camera.angle = cameraShots[shotSelection].angle;
					}
				}

				if (ImGui::Button("Add Camera Shot", ImVec2(303, 0))) {
				    CameraShot shot;
					shot.pos = camera.pos;
					shot.angle = camera.angle;
				    cameraShots.push_back(shot);
				}

				if (ImGui::Button("Delete Camera Shot", ImVec2(303, 0))) {
					int id = shotSelection;
					if (IsInRange(id, 0, numShots - 1)) {
						cameraShots.erase(std::next(cameraShots.begin(), id));
						if (shotSelection > 0) {
							shotSelection--;
						}
					}
				}
			}
			ImGui::Separator();

			int numMaterials = (int)materials.size();
			int numLights = (int)lights.size();

			if (ImGui::CollapsingHeader("Objects")) {
				int numSpheres = (int)spheres.size();
				int numPlanes = (int)planes.size();
				int numBoxes = (int)boxes.size();
				int numLenses = (int)lenses.size();
				int numCyclides = (int)cyclides.size();

				int id = objectSelection;
				if (IsInRange(id, 0, numSpheres - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Sphere %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", spheres[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("Radius", &spheres[id].radius, 0.01f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragInt("Material ID", &spheres[id].materialID, 0.02f, 1, numMaterials);
					isUpdateUBO |= ImGui::DragInt("Light ID", &spheres[id].lightID, 0.02f, 0, numLights);
				}

				id -= numSpheres;
				if (IsInRange(id, 0, numPlanes - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Plane %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", planes[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragInt("Material ID", &planes[id].materialID, 0.02f, 1, numMaterials);
					isUpdateUBO |= ImGui::DragInt("Light ID", &planes[id].lightID, 0.02f, 0, numLights);
				}

				id -= numPlanes;
				if (IsInRange(id, 0, numBoxes - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Box %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", boxes[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat3("Rotation", boxes[id].rotation, 0.1f);
					isUpdateUBO |= ImGui::DragFloat3("Size", boxes[id].size, 0.01f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragInt("Material ID", &boxes[id].materialID, 0.02f, 1, numMaterials);
					isUpdateUBO |= ImGui::DragInt("Light ID", &boxes[id].lightID, 0.02f, 0, numLights);
				}

				id -= numBoxes;
				if (IsInRange(id, 0, numLenses - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Lens %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", lenses[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat3("Rotation", lenses[id].rotation, 0.1f);
					isUpdateUBO |= ImGui::DragFloat("Radius", &lenses[id].radius, 0.001f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragFloat("Focal Length", &lenses[id].focalLength, 0.001f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragFloat("Thickness", &lenses[id].thickness, 0.001f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::Checkbox("Convex Lens", &lenses[id].isConverging);
					isUpdateUBO |= ImGui::DragInt("Material ID", &lenses[id].materialID, 0.02f, 1, numMaterials);
					isUpdateUBO |= ImGui::DragInt("Light ID", &lenses[id].lightID, 0.02f, 0, numLights);
				}

				id -= numLenses;
				if (IsInRange(id, 0, numCyclides - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Cyclide %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", cyclides[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat3("Rotation", cyclides[id].rotation, 0.1f);
					isUpdateUBO |= ImGui::DragFloat3("Scale", cyclides[id].scale, 0.01f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragFloat("a", &cyclides[id].a, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("b", &cyclides[id].b, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("c", &cyclides[id].c, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("d", &cyclides[id].d, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("Bounding Radius", &cyclides[id].brad, 0.01f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragInt("Material ID", &cyclides[id].materialID, 0.02f, 1, numMaterials);
					isUpdateUBO |= ImGui::DragInt("Light ID", &cyclides[id].lightID, 0.02f, 0, numLights);
				}

				id -= numCyclides;

				ImGui::Separator();

				if (ImGui::BeginTable("Objects Table", 1)) {
					ImGui::TableSetupColumn("Object");
					ImGui::TableHeadersRow();
					ItemsTable("Sphere ", objectSelection, 0, numSpheres, true);
					ItemsTable("Plane ", objectSelection, numSpheres, numPlanes, true);
					ItemsTable("Box ", objectSelection, numSpheres + numPlanes, numBoxes, true);
					ItemsTable("Lens ", objectSelection, numSpheres + numPlanes + numBoxes, numLenses, true);
					ItemsTable("Cyclide ", objectSelection, numSpheres + numPlanes + numBoxes + numLenses, numCyclides, true);
					ImGui::EndTable();
				}
				ImGui::Separator();

				if (ImGui::Button("Add New Sphere", ImVec2(303, 0))) {
					spheres.push_back(newSphere);

					objectSelection = numSpheres;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Add New Plane", ImVec2(303, 0))) {
					planes.push_back(newPlane);

					objectSelection = numSpheres + numPlanes;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Add New Box", ImVec2(303, 0))) {
					boxes.push_back(newBox);

					objectSelection = numSpheres + numPlanes + numBoxes;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Add New Lens", ImVec2(303, 0))) {
					lenses.push_back(newLens);

					objectSelection = numSpheres + numPlanes + numBoxes + numLenses;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Add New Cyclide", ImVec2(303, 0))) {
					cyclides.push_back(newCyclide);

					objectSelection = numSpheres + numPlanes + numBoxes + numLenses + numCyclides;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Delete Object", ImVec2(303, 0))) {
					id = objectSelection;
					if (IsInRange(id, 0, numSpheres - 1)) {
						spheres.erase(std::next(spheres.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					id -= numSpheres;
					if (IsInRange(id, 0, numPlanes - 1)) {
						planes.erase(std::next(planes.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					id -= numPlanes;
					if (IsInRange(id, 0, numBoxes - 1)) {
						boxes.erase(std::next(boxes.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					id -= numBoxes;
					if (IsInRange(id, 0, numLenses - 1)) {
						lenses.erase(std::next(lenses.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					id -= numLenses;
					if(IsInRange(id, 0, numCyclides - 1)) {
						cyclides.erase(std::next(cyclides.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					isUpdateUBO = true;
				}
			}
			ImGui::Separator();

			if (ImGui::CollapsingHeader("SDFs")) {
				int numSDFs = (int)sdfs.size();

				int id = sdfSelection;
				if (IsInRange(id, 0, numSDFs - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "SDF %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", sdfs[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat3("Bounding Box Size", sdfs[id].size, 0.01f, 0.0f, 1e7f);
					isLoadSDF |= ImGui::Button("Change SDF", ImVec2(303, 0));
					isSaveSDF |= ImGui::Button("Save SDF", ImVec2(303, 0));
				}

				ImGui::Separator();

				if (ImGui::BeginTable("SDFs Table", 1)) {
					ImGui::TableSetupColumn("SDF");
					ImGui::TableHeadersRow();
					ItemsTable("SDF ", sdfSelection, 0, numSDFs, true);
					ImGui::EndTable();
				}
				ImGui::Separator();

				if (ImGui::Button("Add New SDF", ImVec2(303, 0))) {
					sdfs.push_back(newSDF);

					sdfSelection = numSDFs;
					isUpdateUBO = true;
					isRecompile = true;
				}

				if (ImGui::Button("Delete SDF", ImVec2(303, 0))) {
					id = sdfSelection;
					if (IsInRange(id, 0, numSDFs - 1)) {
						sdfs.erase(std::next(sdfs.begin(), id));
						if (sdfSelection > 0) {
							sdfSelection--;
						}
					}

					isUpdateUBO = true;
					isRecompile = true;
				}
			}
			ImGui::Separator();

			if (ImGui::CollapsingHeader("Materials")) {
				if (IsInRange(materialSelection, 0, numMaterials - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Material %i", materialSelection + 1);
					ImGui::Text("Reflection");
					ImGui::PushID("Reflection");

					spectrumGraph.clear();
					for (int i = 1; i < 101; i++) {
						float x = 0.01f * float(i) * 330.0f + 390.0f;
						spectrumGraph.push_back(SpectralPowerDistribution(x, materials[materialSelection].reflection[0],
						materials[materialSelection].reflection[1], materials[materialSelection].reflection[2]));
					}

					ImGui::PlotLines("", spectrumGraph.data(), (int)spectrumGraph.size(), 0, NULL, 0.0f, 1.0f, ImVec2(303, 100));
					isUpdateUBO |= ImGui::DragFloat("Peak Lambda", &materials[materialSelection].reflection[0], 1.0f, 0.0f, 1200.0f);
					isUpdateUBO |= ImGui::DragFloat("Sigma", &materials[materialSelection].reflection[1], 0.5f, 0.0f, 100.0f);
					bool isInvertBool;
					isInvertBool = (bool)materials[materialSelection].reflection[2];
					isUpdateUBO |= ImGui::Checkbox("Invert", &isInvertBool);
					materials[materialSelection].reflection[2] = (float)isInvertBool;
					ImGui::PopID();
				}
				ImGui::Separator();

				if (ImGui::BeginTable("Materials Table", 1)) {
					ImGui::TableSetupColumn("Materials");
					ImGui::TableHeadersRow();
					ItemsTable("Material ", materialSelection, 0, numMaterials, true);
					ImGui::EndTable();
				}
				ImGui::Separator();

				if (ImGui::Button("Add New Material")) {
					materials.push_back(newMaterial);

					materialSelection = numMaterials;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Delete Material")) {
					if (IsInRange(materialSelection, 0, numMaterials - 1)) {
						materials.erase(std::next(materials.begin(), materialSelection));

						for (sphere& sphere : spheres) {
							if ((sphere.materialID > materialSelection) && (sphere.materialID > 1)) {
								sphere.materialID--;
							}
						}

						for (plane& plane : planes) {
							if ((plane.materialID > materialSelection) && (plane.materialID > 1)) {
								plane.materialID--;
							}
						}

						for (box& box : boxes) {
							if ((box.materialID > materialSelection) && (box.materialID > 1)) {
								box.materialID--;
							}
						}

						for (lens& lens : lenses) {
							if ((lens.materialID > materialSelection) && (lens.materialID > 1)) {
								lens.materialID--;
							}
						}

						for (cyclide& cyclide : cyclides) {
							if ((cyclide.materialID > materialSelection) && (cyclide.materialID > 1)) {
								cyclide.materialID--;
							}
						}

						if (materialSelection > 0) {
							materialSelection--;
						}
					}

					isUpdateUBO = true;
				}
			}

			if (ImGui::CollapsingHeader("Lights")) {
				if (IsInRange(lightSelection, 0, numLights - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Light %i", lightSelection + 1);

					ImGui::Text("Emission");
					ImGui::PushID("Emission");

					spectrumGraph.clear();
					for (int i = 1; i < 101; i++) {
						float x = float(i) * 12e-9f;
						spectrumGraph.push_back(BlackBodyRadiation(x, lights[lightSelection].emission[0]) / BlackBodyRadiationPeak(lights[lightSelection].emission[0]));
					}

					ImGui::PlotLines("", spectrumGraph.data(), (int)spectrumGraph.size(), 0, NULL, 0.0f, 1.0f, ImVec2(303, 100));
					isUpdateUBO |= ImGui::DragFloat("Temperature", &lights[lightSelection].emission[0], 5.0f, 0.0f, 1e5f);
					isUpdateUBO |= ImGui::DragFloat("Luminosity", &lights[lightSelection].emission[1], 0.1f, 0.0f, 1e5f);
					ImGui::PopID();
				}
				ImGui::Separator();

				if (ImGui::BeginTable("Lights Table", 1)) {
					ImGui::TableSetupColumn("Lights");
					ImGui::TableHeadersRow();
					ItemsTable("Light ", lightSelection, 0, numLights, true);
					ImGui::EndTable();
				}
				ImGui::Separator();

				if (ImGui::Button("Add New Light")) {
					lights.push_back(newLight);

					lightSelection = numLights;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Delete Light")) {
					if (IsInRange(lightSelection, 0, numLights - 1)) {
						lights.erase(std::next(lights.begin(), lightSelection));

						for (sphere& sphere : spheres) {
							if ((sphere.lightID > lightSelection) && (sphere.lightID > 1)) {
								sphere.lightID--;
							}
						}

						for (plane& plane : planes) {
							if ((plane.lightID > lightSelection) && (plane.lightID > 1)) {
								plane.lightID--;
							}
						}

						for (box& box : boxes) {
							if ((box.lightID > lightSelection) && (box.lightID > 1)) {
								box.lightID--;
							}
						}

						for (lens& lens : lenses) {
							if ((lens.lightID > lightSelection) && (lens.lightID > 1)) {
								lens.lightID--;
							}
						}

						if (lightSelection > 0) {
							lightSelection--;
						}
					}

					isUpdateUBO = true;
				}
			}

			isImGuiWindowFocused = ImGui::IsWindowFocused();
			ImGui::End();
		}

		ImGui::Render();
	}

	void CleanUpImages() {
		for (VkFramebuffer framebuffer : framebuffers) {
			vkDestroyFramebuffer(device, framebuffer, nullptr);
		}

		for (VkImageView imageView : swapChainImageViews) {
			vkDestroyImageView(device, imageView, nullptr);
		}

		vkDestroySwapchainKHR(device, swapChain, nullptr);
	}

	void CleanUpTexelBuffer() {
		vkDestroyBufferView(device, texelBufferView, nullptr);
		vkDestroyBuffer(device, texelBuffer, nullptr);
		vkFreeMemory(device, texelBufferMemory, nullptr);
	}

	void LoadScene() {
		std::vector<std::string> sceneDir = pfd::open_file("Load Scene", "", {"All Files", "*"}, pfd::opt::none).result();

		if (!sceneDir.empty()) {
			scene = ReadJSON(sceneDir.at(0));
			UpdateFromJSON();

			objectSelection = 0;
			materialSelection = 0;
			isUpdateUBO = true;
			isRecompile = true;

			vkDeviceWaitIdle(device);

			CleanUpTexelBuffer();

			CreateTexelBuffer();
			CreateTexelBufferView();

			UpdateDescriptorSet();
		}
	}

	void SaveScene() {
		std::string sceneDir = pfd::save_file("Save Scene", "", {"All Files", "*"}, pfd::opt::force_overwrite).result();

		if (!sceneDir.empty()) {
			UpdateToJSON();
			SaveFile(sceneDir, scene.dump(4, (char)32, true));
		}
	}

	void LoadSDF() {
		std::vector<std::string> SDFDir = pfd::open_file("Load SDF", "", {"All Files", "*"}, pfd::opt::none).result();
		if (!SDFDir.empty()) {
			sdfs[sdfSelection].glsl = ReadFile(SDFDir.at(0));
			isRecompile = true;
		}
	}

	void SaveSDF() {
		std::string SDFDir = pfd::save_file("Save SDF", "", {"All Files", "*"}, pfd::opt::force_overwrite).result();

		if (!SDFDir.empty()) {
			std::cout << sdfs[sdfSelection].glsl << std::endl;
			SaveFile(SDFDir, sdfs[sdfSelection].glsl);
		}
	}

	void SaveRender() {
	    std::string renderDir = pfd::save_file("Save Render", "", {"PPM", "*.ppm"}, pfd::opt::force_overwrite).result();

		if (!renderDir.empty()) {
            void* mappedMemory;
           	vkMapMemory(device, texelBufferMemory, 0, VK_WHOLE_SIZE, 0, &mappedMemory);

           	float* pixels = static_cast<float*>(mappedMemory);
           	char* pixelsRGB = new char[W * H * 3];

           	for (int i = 0; i < (W * H); i++) {
                glm::vec3 inColor = glm::vec3(pixels[4*i], pixels[4*i+1], pixels[4*i+2]);
                inColor = IlluminantEToD65(inColor);
                inColor = glm::max(XYZToRGB(inColor), glm::vec3(0.0));
                inColor = tonemapping(inColor, tonemap);
                inColor = glm::vec3(sRGBCompanding(inColor.x), sRGBCompanding(inColor.y), sRGBCompanding(inColor.z));

          		pixelsRGB[3*i] = (char)(inColor.x * 255.0);
          		pixelsRGB[3*i+1] = (char)(inColor.y * 255.0);
          		pixelsRGB[3*i+2] = (char)(inColor.z * 255.0);
           	}

           	SavePPM(renderDir, W, H, pixelsRGB);

           	vkUnmapMemory(device, texelBufferMemory);
           	delete[] pixelsRGB;
		}
	}

	void RecordGraphicsCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex) {
		VkCommandBufferBeginInfo beginInfo{};
		beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
		beginInfo.flags = 0;
		beginInfo.pInheritanceInfo = nullptr;

		if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Begin Recording Graphics Command Buffer!");
		}

		VkViewport viewport{};
		viewport.x = 0.0f;
		viewport.y = 0.0f;
		viewport.width = static_cast<float>(W);
		viewport.height = static_cast<float>(H);
		viewport.minDepth = 0.0f;
		viewport.maxDepth = 1.0f;

		vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

		VkRect2D scissor{};
		scissor.offset = {0, 0};
		scissor.extent.width = static_cast<uint32_t>(W);
		scissor.extent.height = static_cast<uint32_t>(H);

		vkCmdSetScissor(commandBuffer, 0, 1, &scissor);

		VkBuffer vertexBuffers[] = {vertexBuffer};
		VkDeviceSize offsets[] = {0};

		vkCmdBindVertexBuffers(commandBuffer, 0, 1, vertexBuffers, offsets);

		vkCmdBindIndexBuffer(commandBuffer, indexBuffer, 0, VK_INDEX_TYPE_UINT16);

		VkRenderPassBeginInfo renderPassBeginInfo{};
		renderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
		renderPassBeginInfo.renderPass = renderPass;
		renderPassBeginInfo.framebuffer = framebuffers[imageIndex];
		renderPassBeginInfo.renderArea.extent.width = static_cast<uint32_t>(W);
		renderPassBeginInfo.renderArea.extent.height = static_cast<uint32_t>(H);
		renderPassBeginInfo.renderArea.offset = {0, 0};
		renderPassBeginInfo.clearValueCount = 0;
		renderPassBeginInfo.pClearValues = nullptr;

		vkCmdBeginRenderPass(commandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

		vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

		vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
		graphicsPipelineLayout, 0, 1, &descriptorSets[currentFrame], 0, nullptr);

		vkCmdPushConstants(commandBuffer, graphicsPipelineLayout, VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(pushConstant), &pushConstant);

		vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(indices.size()), 1, 0, 0, 0);

		vkCmdNextSubpass(commandBuffer, VK_SUBPASS_CONTENTS_INLINE);

		ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), commandBuffer);

		vkCmdEndRenderPass(commandBuffer);

		if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Record Graphics Command Buffer!");
		}
	}

	void RecordComputeCommandBuffer(VkCommandBuffer commandBuffer) {
		VkCommandBufferBeginInfo beginInfo{};
		beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
		beginInfo.flags = 0;
		beginInfo.pInheritanceInfo = nullptr;

		if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Begin Recording Compute Command Buffer!");
		}

		vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, computePipeline);

		vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE,
		computePipelineLayout, 0, 1, &descriptorSets[currentFrame], 0, nullptr);

		vkCmdPushConstants(commandBuffer, computePipelineLayout, VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(pushConstant), &pushConstant);

		vkCmdDispatch(commandBuffer, static_cast<uint32_t>(std::ceil(W / 16.0)), static_cast<uint32_t>(std::ceil(H / 16.0)), 1);

		if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Record Compute Command Buffer!");
		}
	}

	void RecreateSwapChain() {
		vkDeviceWaitIdle(device);

		CleanUpImages();

		CreateSwapChain();
		CreateSwapChainImageViews();

		CreateFramebuffers();
	}

	void RecreateImages() {
		isWindowMinimized = (bool)glfwGetWindowAttrib(window, GLFW_ICONIFIED);

		while (glfwGetWindowAttrib(window, GLFW_ICONIFIED)) {
			glfwWaitEvents();
		}

		if (isWindowMinimized) {
			return;
		}

		RecreateSwapChain();

		CleanUpTexelBuffer();

		CreateTexelBuffer();
		CreateTexelBufferView();

		UpdateDescriptorSet();
	}

	void UpdateUniformBuffer() {
		if (isUpdateUBO) {
			std::array<float, 7> numObjects;
			std::vector<float> objectsArray;
			std::vector<float> sdfsArray;
			std::vector<float> materialsArray;
			std::vector<float> lightsArray;
			std::vector<float> lightIDs;

			for (int i = 0; i < spheres.size(); i++) {
				objectsArray.push_back(spheres[i].pos[0]);
				objectsArray.push_back(spheres[i].pos[1]);
				objectsArray.push_back(spheres[i].pos[2]);
				objectsArray.push_back(spheres[i].radius);
				objectsArray.push_back((float)spheres[i].materialID);
				objectsArray.push_back((float)spheres[i].lightID);
				if (spheres[i].lightID > 0) {
					lightIDs.push_back(i);
				}
			}

			for (int i = 0; i < planes.size(); i++) {
				objectsArray.push_back(planes[i].pos[0]);
				objectsArray.push_back(planes[i].pos[1]);
				objectsArray.push_back(planes[i].pos[2]);
				objectsArray.push_back((float)planes[i].materialID);
				objectsArray.push_back((float)planes[i].lightID);
				if (planes[i].lightID > 0) {
					lightIDs.push_back(spheres.size() + i);
				}
			}

			for (int i = 0; i < boxes.size(); i++) {
				objectsArray.push_back(boxes[i].pos[0]);
				objectsArray.push_back(boxes[i].pos[1]);
				objectsArray.push_back(boxes[i].pos[2]);
				objectsArray.push_back(boxes[i].rotation[0]);
				objectsArray.push_back(boxes[i].rotation[1]);
				objectsArray.push_back(boxes[i].rotation[2]);
				objectsArray.push_back(boxes[i].size[0]);
				objectsArray.push_back(boxes[i].size[1]);
				objectsArray.push_back(boxes[i].size[2]);
				objectsArray.push_back((float)boxes[i].materialID);
				objectsArray.push_back((float)boxes[i].lightID);
				if (boxes[i].lightID > 0) {
					lightIDs.push_back(spheres.size() + planes.size() + i);
				}
			}

			for (int i = 0; i < lenses.size(); i++) {
				objectsArray.push_back(lenses[i].pos[0]);
				objectsArray.push_back(lenses[i].pos[1]);
				objectsArray.push_back(lenses[i].pos[2]);
				objectsArray.push_back(lenses[i].rotation[0]);
				objectsArray.push_back(lenses[i].rotation[1]);
				objectsArray.push_back(lenses[i].rotation[2]);
				objectsArray.push_back(lenses[i].radius);
				objectsArray.push_back(lenses[i].focalLength);
				objectsArray.push_back(lenses[i].thickness);
				objectsArray.push_back((float)lenses[i].isConverging);
				objectsArray.push_back((float)lenses[i].materialID);
				objectsArray.push_back((float)lenses[i].lightID);
				if (planes[i].lightID > 0) {
					lightIDs.push_back(spheres.size() + planes.size() + boxes.size() + i);
				}
			}

			for (int i = 0; i < cyclides.size(); i++) {
				objectsArray.push_back(cyclides[i].pos[0]);
				objectsArray.push_back(cyclides[i].pos[1]);
				objectsArray.push_back(cyclides[i].pos[2]);
				objectsArray.push_back(cyclides[i].rotation[0]);
				objectsArray.push_back(cyclides[i].rotation[1]);
				objectsArray.push_back(cyclides[i].rotation[2]);
				objectsArray.push_back(cyclides[i].scale[0]);
				objectsArray.push_back(cyclides[i].scale[1]);
				objectsArray.push_back(cyclides[i].scale[2]);
				objectsArray.push_back(cyclides[i].a);
				objectsArray.push_back(cyclides[i].b);
				objectsArray.push_back(cyclides[i].c);
				objectsArray.push_back(cyclides[i].d);
				objectsArray.push_back(cyclides[i].brad * cyclides[i].brad *
					(glm::max(glm::max(cyclides[i].scale[0], cyclides[i].scale[1]), cyclides[i].scale[2]) *
					glm::max(glm::max(cyclides[i].scale[0], cyclides[i].scale[1]), cyclides[i].scale[2])));
				objectsArray.push_back((float)cyclides[i].materialID);
				objectsArray.push_back((float)cyclides[i].lightID);
				if (planes[i].lightID > 0) {
					lightIDs.push_back(spheres.size() + planes.size() + boxes.size() + lenses.size() + i);
				}
			}

			numObjects[0] = (float)spheres.size();
			numObjects[1] = (float)planes.size();
			numObjects[2] = (float)boxes.size();
			numObjects[3] = (float)lenses.size();
			numObjects[4] = (float)cyclides.size();
			numObjects[5] = (float)sdfs.size();
			numObjects[6] = (float)lightIDs.size();

			for (size_t i = 0; i < numObjects.size(); i++) {
				ubo.numObjects[i] = numObjects[i];
			}

			for (int i = 0; i < MAX_OBJECTS_SIZE; i++) {
				if (objectsArray.size() > i) {
					ubo.packedObjects[i] = objectsArray[i];
				} else {
					ubo.packedObjects[i] = 0.0f;
				}
			}

			for (int i = 0; i < sdfs.size(); i++) {
				sdfsArray.push_back(sdfs[i].pos[0]);
				sdfsArray.push_back(sdfs[i].pos[1]);
				sdfsArray.push_back(sdfs[i].pos[2]);
				sdfsArray.push_back(sdfs[i].size[0]);
				sdfsArray.push_back(sdfs[i].size[1]);
				sdfsArray.push_back(sdfs[i].size[2]);
			}

			for (int i = 0; i < MAX_SDFS_SIZE; i++) {
				if (sdfsArray.size() > i) {
					ubo.packedSdfs[i] = sdfsArray[i];
				} else {
					ubo.packedSdfs[i] = 0.0f;
				}
			}

			for (int i = 0; i < materials.size(); i++) {
				materialsArray.push_back(materials[i].reflection[0]);
				materialsArray.push_back(materials[i].reflection[1]);
				materialsArray.push_back(materials[i].reflection[2]);
			}

			for (int i = 0; i < MAX_MATERIALS_SIZE; i++) {
				if (materialsArray.size() > i) {
					ubo.packedMaterials[i] = materialsArray[i];
				} else {
					ubo.packedMaterials[i] = 0.0f;
				}
			}

			for (int i = 0; i < lights.size(); i++) {
				lightsArray.push_back(lights[i].emission[0]);
				lightsArray.push_back(lights[i].emission[1]);
			}

			for (int i = 0; i < MAX_LIGHTS_SIZE; i++) {
				if (lightsArray.size() > i) {
					ubo.packedLights[i] = lightsArray[i];
				} else {
					ubo.packedLights[i] = 0.0f;
				}
			}

			for (int i = 0; i < MAX_LIGHTIDS_SIZE; i++) {
				if (lightIDs.size() > i) {
					ubo.packedLightIDs[i] = lightIDs[i];
				} else {
					ubo.packedLightIDs[i] = 0.0f;
				}
			}

			for (size_t k = 0; k < MAX_FRAMES_IN_FLIGHT; k++) {
				memcpy(uniformBuffersMapped[k], &ubo, sizeof(ubo));
			}

			isUpdateUBO = false;
		}
	}

	void UpdatePushConstant() {
		pushConstant.resolution = glm::ivec2(W, H);
		pushConstant.frame = frame;
		pushConstant.currentSamples = currentSamples;
		pushConstant.samplesPerFrame = samplesPerFrame;
		pushConstant.FPS = 1.0f / frameTime;
		pushConstant.persistence = persistence;
		pushConstant.pathLength = pathLength;
		pushConstant.cameraAngle = glm::vec2(-camera.angle.y, camera.angle.x);
		pushConstant.cameraPosX = camera.pos.x;
		pushConstant.cameraPosY = camera.pos.y;
		pushConstant.cameraPosZ = camera.pos.z;
		pushConstant.ISO = camera.ISO;
		pushConstant.cameraSize = camera.size;
		pushConstant.apertureSize = camera.apertureSize;
		pushConstant.apertureDist = camera.apertureDist;
		pushConstant.lensRadius = camera.lensRadius;
		pushConstant.lensFocalLength = camera.lensFocalLength;
		pushConstant.lensThickness = camera.lensThickness;
		pushConstant.lensDistance = camera.lensDistance;
		pushConstant.tonemap = tonemap;
	}

	void RecompileComputeShaders() {
		vkDestroyPipeline(device, computePipeline, nullptr);
		vkDestroyPipelineLayout(device, computePipelineLayout, nullptr);

		CreateComputePipeline();
	}

	void DrawFrame() {
		if (isRecompile) {
			for (int i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
				vkWaitForFences(device, 1, &computeInFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
				currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
			}
			RecompileComputeShaders();
			isRecompile = false;
		} else {
			vkWaitForFences(device, 1, &computeInFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
		}

		UpdateUniformBuffer();
		UpdatePushConstant();

		if (isSaveRender) {
		    SaveRender();
			isSaveRender = false;
		}

		vkResetFences(device, 1, &computeInFlightFences[currentFrame]);
		vkResetCommandBuffer(computeCommandBuffers[currentFrame], 0);

		RecordComputeCommandBuffer(computeCommandBuffers[currentFrame]);

		VkSubmitInfo computeSubmitInfo{};
		computeSubmitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		computeSubmitInfo.commandBufferCount = 1;
		computeSubmitInfo.pCommandBuffers = &computeCommandBuffers[currentFrame];

		if (!OFFSCREENRENDER) {
			computeSubmitInfo.signalSemaphoreCount = 1;
			computeSubmitInfo.pSignalSemaphores = &computeFinishedSemaphores[currentFrame];
		}

		if (vkQueueSubmit(computeQueue, 1, &computeSubmitInfo, computeInFlightFences[currentFrame]) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Submit Compute Command Buffers!");
		}

		uint32_t imageIndex = 0;
		VkResult result;

		if (!OFFSCREENRENDER) {
			vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

			if (isVSyncChanged) {
				RecreateSwapChain();

				isVSyncChanged = false;
			}

			result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX,
			imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);

			if (result == VK_ERROR_OUT_OF_DATE_KHR) {
				RecreateImages();

				if (!isWindowMinimized) {
					frame = samplesPerFrame;
					currentSamples = samplesPerFrame;
				} else {
					isWindowMinimized = false;
				}

				return;
			} else if ((result != VK_SUCCESS) && (result != VK_SUBOPTIMAL_KHR)) {
				throw std::runtime_error("Failed To Acquire Swap Chain Image!");
			}

			vkResetFences(device, 1, &inFlightFences[currentFrame]);

			vkResetCommandBuffer(graphicsCommandBuffers[currentFrame], 0);
			RecordGraphicsCommandBuffer(graphicsCommandBuffers[currentFrame], imageIndex);

			VkSubmitInfo submitInfo{};
			submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
			VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT};
			submitInfo.pWaitDstStageMask = waitStages;
			submitInfo.commandBufferCount = 1;
			submitInfo.pCommandBuffers = &graphicsCommandBuffers[currentFrame];

			std::vector<VkSemaphore> waitSemaphores;
			waitSemaphores.push_back(computeFinishedSemaphores[currentFrame]);
			waitSemaphores.push_back(imageAvailableSemaphores[currentFrame]);
			submitInfo.waitSemaphoreCount = static_cast<uint32_t>(waitSemaphores.size());
			submitInfo.pWaitSemaphores = waitSemaphores.data();
			submitInfo.signalSemaphoreCount = 1;
			submitInfo.pSignalSemaphores = &renderFinishedSemaphores[currentFrame];

			if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Submit Draw Command Buffer!");
			}

			VkPresentInfoKHR presentInfo{};
			presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
			presentInfo.waitSemaphoreCount = 1;
			presentInfo.pWaitSemaphores = &renderFinishedSemaphores[currentFrame];
			VkSwapchainKHR swapChains[] = {swapChain};
			presentInfo.swapchainCount = 1;
			presentInfo.pSwapchains = swapChains;
			presentInfo.pImageIndices = &imageIndex;
			presentInfo.pResults = nullptr; // Checking If Presentation Was Successful For Multiple Swap Chains

			result = vkQueuePresentKHR(presentQueue, &presentInfo);

			if ((result == VK_ERROR_OUT_OF_DATE_KHR) || (result == VK_SUBOPTIMAL_KHR)) {
				RecreateImages();

				if (!isWindowMinimized) {
					frame = 0;
					currentSamples = 0;
				} else {
					isWindowMinimized = false;
				}
			} else if (result != VK_SUCCESS) {
				throw std::runtime_error("Failed To Present Swap Chain Image!");
			}
		}

		currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
	}

    void MainLoop() {
		double start = 0;
		double end = 0;
		double prevEnd = 0;

		if (OFFSCREENRENDER) {
			std::cout << "Number Of Samples: ";
			std::cin >> numSamples;
			std::cout << "Number Of Samples Per Frame: ";
			std::cin >> samplesPerFrame;
			std::cout << "Path Length: ";
			std::cin >> pathLength;
			std::cout << "Camera Shot Index(1, 2, 3, ...): ";
			std::cin >> cameraShotIndex;

			start = glfwGetTime();
		}

		glm::vec2 cursorPos = glm::vec2(0.0f, 0.0f);
		glm::vec3 deltaCamPos = glm::vec3(0.0f, 0.0f, 0.0f);

		std::vector<float> framesGraph;

		if (OFFSCREENRENDER) {
			std::vector<std::string> sceneDir = pfd::open_file("Load Scene", "", {"All Files", "*"}, pfd::opt::none).result();

			if (sceneDir.empty()) {
				throw std::runtime_error("No Scene Has Been Selected!");
			} else {
				scene = ReadJSON(sceneDir.at(0));
			}

			UpdateFromJSON();

			RecompileComputeShaders();
		} else {
			DefaultScene();
			UpdateFromJSON();
		}

        while (!glfwWindowShouldClose(window)) {
			if (!OFFSCREENRENDER) {
				HandleEvents(cursorPos, camera.angle, deltaCamPos);

				Sleep(minFrameTime);

				deltaCamPos *= 3.0f * frameTime;
				UpdateCameraPos(camera.pos, glm::radians(camera.angle), deltaCamPos);

				ImGuiRender(framesGraph);

				if (isLoadScene) {
					LoadScene();
					isLoadScene = false;
				}

				if (isSaveScene) {
					SaveScene();
					isSaveScene = false;
				}

				if (isLoadSDF) {
					LoadSDF();
					isLoadSDF = false;
				}

				if (isSaveSDF) {
					SaveSDF();
					isSaveSDF = false;
				}

				if (frame >= samplesPerFrame) {
					isReset |= isUpdateUBO;
					isReset |= isRecompile;
				}
			}

			frame += samplesPerFrame;
			if (isReset) {
				currentSamples = samplesPerFrame;
				isReset = false;
			} else {
				currentSamples += samplesPerFrame;
			}

			DrawFrame();

			if (OFFSCREENRENDER) {
				prevEnd = end;
				end = glfwGetTime();
				double dtime = end - prevEnd;
				double speed = (double)samplesPerFrame / dtime;
				double timeElapsed = end - start;
				double progress = (double)currentSamples / (double)numSamples;
				int percentage = (int)(100.0 * progress);
				double timeRemaining = timeElapsed * ((1.0 / progress) - 1.0);

				std::string progressBar;
				for (int i = 0; i < percentage; i++) {
					progressBar.push_back((char)219);
				}
				for (int i = percentage; i < 100; i++) {
					progressBar.push_back((char)32);
				}

				printf("Rendering: %i%%|%s| %i/%i [%0.1fs|%0.1fs, %0.3fSPP/s] \r", percentage, progressBar.data(), currentSamples, numSamples, timeElapsed, timeRemaining, speed);
				if (currentSamples >= numSamples) {
					std::cout << std::endl;
					printf("Rendering Completed In %0.3fs. \n", timeElapsed);
					break;
				}
			}

			if (!OFFSCREENRENDER) {
				frameTime = io->DeltaTime;

				if (framesGraph.size() >= 100) {
					framesGraph.erase(framesGraph.begin());
				}
				framesGraph.push_back(1000.0f * frameTime);
			}
        }

		vkDeviceWaitIdle(device);

		if (OFFSCREENRENDER) {
		    SaveRender();
		}
    }

    void CleanUp() {
        if (!OFFSCREENRENDER) {
            CleanUpImages();
        }
		CleanUpTexelBuffer();

		if (!OFFSCREENRENDER) {
			ImGui_ImplVulkan_Shutdown();
			ImGui_ImplGlfw_Shutdown();
			ImGui::DestroyContext();
		}

		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			vkDestroyBuffer(device, uniformBuffers[i], nullptr);
			vkFreeMemory(device, uniformBuffersMemory[i], nullptr);
		}

		if (!OFFSCREENRENDER) {
			vkDestroyDescriptorPool(device, imguiDescriptorPool, nullptr);
		}

		vkDestroyDescriptorPool(device, descriptorPool, nullptr);

		vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr);

		if (!OFFSCREENRENDER) {
    		vkDestroyBuffer(device, indexBuffer, nullptr);
    		vkFreeMemory(device, indexBufferMemory, nullptr);

    		vkDestroyBuffer(device, vertexBuffer, nullptr);
    		vkFreeMemory(device, vertexBufferMemory, nullptr);
		}

		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			vkDestroyFence(device, computeInFlightFences[i], nullptr);
			vkDestroySemaphore(device, computeFinishedSemaphores[i], nullptr);

			vkDestroyFence(device, inFlightFences[i], nullptr);
			vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr);
			vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr);
		}

		vkDestroyCommandPool(device, commandPool, nullptr);

		vkDestroyPipeline(device, computePipeline, nullptr);
		if (!OFFSCREENRENDER) {
		    vkDestroyPipeline(device, graphicsPipeline, nullptr);
		}
		vkDestroyPipelineLayout(device, computePipelineLayout, nullptr);
		if (!OFFSCREENRENDER) {
		    vkDestroyPipelineLayout(device, graphicsPipelineLayout, nullptr);
		}

		for (VkShaderModule shaderModule : shaderModules) {
			vkDestroyShaderModule(device, shaderModule, nullptr);
		}

		if (!OFFSCREENRENDER) {
		  vkDestroyRenderPass(device, renderPass, nullptr);
		}

		vkDestroyDevice(device, nullptr);

		if (isValidationLayersEnabled) {
			DestoryDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);
		}

		vkDestroySurfaceKHR(instance, surface, nullptr);
		vkDestroyInstance(instance, nullptr);

        glfwDestroyWindow(window);
		glfwTerminate();
    }
};

int main(int argc, char* argv[])
{
    App app;

    try {
        app.run();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return EXIT_FAILURE;
    }

	return EXIT_SUCCESS;
}
