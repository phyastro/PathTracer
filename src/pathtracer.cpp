#include <vulkan/vulkan.h>
#include <glslang/Public/ShaderLang.h>
#include <glslang/Public/ResourceLimits.h>
#include <glslang/SPIRV/GlslangToSpv.h>
#include <GLFW/glfw3.h>
#include <imgui.h>
#include <imgui_internal.h>
#include <imgui_impl_glfw.h>
#include <imgui_impl_vulkan.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <json/json.hpp>
#include <portable-file-dialogs/portable-file-dialogs.h>

#include <iostream>
#include <stdexcept>
#include <cstdlib>
#include <vector>
#include <string>
#include <map>
#include <optional>
#include <set>
#include <cstdint>
#include <limits>
#include <algorithm>
#include <fstream>
#include <array>
#include <cmath>

const unsigned int WIDTH = 1280;
const unsigned int HEIGHT = 720;
const int MAX_FRAMES_IN_FLIGHT = 2;
const bool OFFSCREENRENDER = false;
const int TONEMAP = 3; // 0 - None,  1 - Reinhard, 2 - ACES Film, 3 - DEUCES

#define DEBUGMODE
//#define LAUNCHFROMEXECUTABLES
#define MAX_OBJECTS_SIZE 1024
#define MAX_SDFS_SIZE 768
#define MAX_MATERIALS_SIZE 975

#ifdef DEBUGMODE
const bool isValidationLayersEnabled = true;
#else
const bool isValidationLayersEnabled = false;
#endif

#ifdef LAUNCHFROMEXECUTABLES
const bool isRunFromExecutables = true;
#else
const bool isRunFromExecutables = false;
#endif

struct QueueFamilyIndices {
	std::optional<uint32_t> graphicsComputeFamily;
	std::optional<uint32_t> presentFamily;

	bool IsComplete() {
		return graphicsComputeFamily.has_value() && presentFamily.has_value();
	}
};

struct SwapChainSupportDetails {
	VkSurfaceCapabilitiesKHR capabilities;
	std::vector<VkSurfaceFormatKHR> formats;
	std::vector<VkPresentModeKHR> presentModes;
};

struct colorFormatName {
	VkFormat format;
	const char* name;
};

struct colorSpaceName {
	VkColorSpaceKHR space;
	const char* name;
};

struct presentModeName {
	VkPresentModeKHR mode;
	const char* name;
};

struct Vertex {
	glm::vec2 pos;

	static VkVertexInputBindingDescription getBindingDescription() {
		VkVertexInputBindingDescription bindingDescription{};
		bindingDescription.binding = 0; // Only 1 Vertex Array, So Index Is 0
		bindingDescription.stride = sizeof(Vertex);
		bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

		return bindingDescription;
	}

	static VkVertexInputAttributeDescription getAttributeDescription() {
		VkVertexInputAttributeDescription attributeDescription{};
		attributeDescription.binding = 0;
		attributeDescription.location = 0; // location Directive In Vertex Shader
		attributeDescription.format = VK_FORMAT_R32G32_SFLOAT;
		attributeDescription.offset = offsetof(Vertex, pos);

		return attributeDescription;
	}
};

struct sphere {
	float pos[3];
	float radius;
	int materialID;
};

struct plane {
	float pos[3];
	int materialID;
};

struct box {
	float pos[3];
	float rotation[3];
	float size[3];
	int materialID;
};

struct lens {
	float pos[3];
	float rotation[3];
	float radius;
	float focalLength;
	float thickness;
	bool isConverging;
	int materialID;
};

struct cyclide {
	float pos[3];
	float rotation[3];
	float scale[3];
	float a;
	float b;
	float c;
	float d;
	float brad;
	int materialID;
};

struct material {
	float reflection[3];
	float emission[2];
};

struct sdf {
	float pos[3];
	float size[3];
	std::string glsl;
};

struct Camera {
	glm::vec3 pos;
	glm::vec2 angle;
	int ISO;
	float size;
	float apertureSize;
	float apertureDist;
	float lensRadius;
	float lensFocalLength;
	float lensThickness;
	float lensDistance;
};

struct UniformBufferObject {
	float numObjects[6];
	float packedObjects[MAX_OBJECTS_SIZE];
	float packedSdfs[MAX_SDFS_SIZE];
	float packedMaterials[MAX_MATERIALS_SIZE];
	float CIELMS2006[1323];
};

struct PushConstantValues {
	glm::ivec2 resolution;
	int frame;
	int currentSamples;
	int samplesPerFrame;
	float FPS;
	float persistence;
	int pathLength;
	glm::vec2 cameraAngle;
	float cameraPosX;
	float cameraPosY;
	float cameraPosZ;
	int ISO;
	float cameraSize;
	float apertureSize;
	float apertureDist;
	float lensRadius;
	float lensFocalLength;
	float lensThickness;
	float lensDistance;
	int tonemap;
};

const std::vector<const char*> validationLayers = {
	"VK_LAYER_KHRONOS_validation"
};

const std::vector<const char*> instanceExtensions = {};

const std::vector<const char*> deviceExtensions = {
	VK_KHR_SWAPCHAIN_EXTENSION_NAME,
	VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME
};

const std::vector<colorFormatName> colorFormats = {
	{VK_FORMAT_R4G4_UNORM_PACK8, "VK_FORMAT_R4G4_UNORM_PACK8"},
	{VK_FORMAT_R4G4B4A4_UNORM_PACK16, "VK_FORMAT_R4G4B4A4_UNORM_PACK16"},
	{VK_FORMAT_B4G4R4A4_UNORM_PACK16, "VK_FORMAT_B4G4R4A4_UNORM_PACK16"},
	{VK_FORMAT_R5G6B5_UNORM_PACK16, "VK_FORMAT_R5G6B5_UNORM_PACK16"},
	{VK_FORMAT_B5G6R5_UNORM_PACK16, "VK_FORMAT_B5G6R5_UNORM_PACK16"},
	{VK_FORMAT_R5G5B5A1_UNORM_PACK16, "VK_FORMAT_R5G5B5A1_UNORM_PACK16"},
	{VK_FORMAT_B5G5R5A1_UNORM_PACK16, "VK_FORMAT_B5G5R5A1_UNORM_PACK16"},
	{VK_FORMAT_A1R5G5B5_UNORM_PACK16, "VK_FORMAT_A1R5G5B5_UNORM_PACK16"},
	{VK_FORMAT_R8_UNORM, "VK_FORMAT_R8_UNORM"},
	{VK_FORMAT_R8_SNORM, "VK_FORMAT_R8_SNORM"},
	{VK_FORMAT_R8_USCALED, "VK_FORMAT_R8_USCALED"},
	{VK_FORMAT_R8_SSCALED, "VK_FORMAT_R8_SSCALED"},
	{VK_FORMAT_R8_UINT, "VK_FORMAT_R8_UINT"},
	{VK_FORMAT_R8_SINT, "VK_FORMAT_R8_SINT"},
	{VK_FORMAT_R8_SRGB, "VK_FORMAT_R8_SRGB"},
	{VK_FORMAT_R8G8_UNORM, "VK_FORMAT_R8G8_UNORM"},
	{VK_FORMAT_R8G8_SNORM, "VK_FORMAT_R8G8_SNORM"},
	{VK_FORMAT_R8G8_USCALED, "VK_FORMAT_R8G8_USCALED"},
	{VK_FORMAT_R8G8_SSCALED, "VK_FORMAT_R8G8_SSCALED"},
	{VK_FORMAT_R8G8_UINT, "VK_FORMAT_R8G8_UINT"},
	{VK_FORMAT_R8G8_SINT, "VK_FORMAT_R8G8_SINT"},
	{VK_FORMAT_R8G8_SRGB, "VK_FORMAT_R8G8_SRGB"},
	{VK_FORMAT_R8G8B8_UNORM, "VK_FORMAT_R8G8B8_UNORM"},
	{VK_FORMAT_R8G8B8_SNORM, "VK_FORMAT_R8G8B8_SNORM"},
	{VK_FORMAT_R8G8B8_USCALED, "VK_FORMAT_R8G8B8_USCALED"},
	{VK_FORMAT_R8G8B8_SSCALED, "VK_FORMAT_R8G8B8_SSCALED"},
	{VK_FORMAT_R8G8B8_UINT, "VK_FORMAT_R8G8B8_UINT"},
	{VK_FORMAT_R8G8B8_SINT, "VK_FORMAT_R8G8B8_SINT"},
	{VK_FORMAT_R8G8B8_SRGB, "VK_FORMAT_R8G8B8_SRGB"},
	{VK_FORMAT_B8G8R8_UNORM, "VK_FORMAT_B8G8R8_UNORM"},
	{VK_FORMAT_B8G8R8_SNORM, "VK_FORMAT_B8G8R8_SNORM"},
	{VK_FORMAT_B8G8R8_USCALED, "VK_FORMAT_B8G8R8_USCALED"},
	{VK_FORMAT_B8G8R8_SSCALED, "VK_FORMAT_B8G8R8_SSCALED"},
	{VK_FORMAT_B8G8R8_UINT, "VK_FORMAT_B8G8R8_UINT"},
	{VK_FORMAT_B8G8R8_SINT, "VK_FORMAT_B8G8R8_SINT"},
	{VK_FORMAT_B8G8R8_SRGB, "VK_FORMAT_B8G8R8_SRGB"},
	{VK_FORMAT_R8G8B8A8_UNORM, "VK_FORMAT_R8G8B8A8_UNORM"},
	{VK_FORMAT_R8G8B8A8_SNORM, "VK_FORMAT_R8G8B8A8_SNORM"},
	{VK_FORMAT_R8G8B8A8_USCALED, "VK_FORMAT_R8G8B8A8_USCALED"},
	{VK_FORMAT_R8G8B8A8_SSCALED, "VK_FORMAT_R8G8B8A8_SSCALED"},
	{VK_FORMAT_R8G8B8A8_UINT, "VK_FORMAT_R8G8B8A8_UINT"},
	{VK_FORMAT_R8G8B8A8_SINT, "VK_FORMAT_R8G8B8A8_SINT"},
	{VK_FORMAT_R8G8B8A8_SRGB, "VK_FORMAT_R8G8B8A8_SRGB"},
	{VK_FORMAT_B8G8R8A8_UNORM, "VK_FORMAT_B8G8R8A8_UNORM"},
	{VK_FORMAT_B8G8R8A8_SNORM, "VK_FORMAT_B8G8R8A8_SNORM"},
	{VK_FORMAT_B8G8R8A8_USCALED, "VK_FORMAT_B8G8R8A8_USCALED"},
	{VK_FORMAT_B8G8R8A8_SSCALED, "VK_FORMAT_B8G8R8A8_SSCALED"},
	{VK_FORMAT_B8G8R8A8_UINT, "VK_FORMAT_B8G8R8A8_UINT"},
	{VK_FORMAT_B8G8R8A8_SINT, "VK_FORMAT_B8G8R8A8_SINT"},
	{VK_FORMAT_B8G8R8A8_SRGB, "VK_FORMAT_B8G8R8A8_SRGB"},
	{VK_FORMAT_A8B8G8R8_UNORM_PACK32, "VK_FORMAT_A8B8G8R8_UNORM_PACK32"},
	{VK_FORMAT_A8B8G8R8_SNORM_PACK32, "VK_FORMAT_A8B8G8R8_SNORM_PACK32"},
	{VK_FORMAT_A8B8G8R8_USCALED_PACK32, "VK_FORMAT_A8B8G8R8_USCALED_PACK32"},
	{VK_FORMAT_A8B8G8R8_SSCALED_PACK32, "VK_FORMAT_A8B8G8R8_SSCALED_PACK32"},
	{VK_FORMAT_A8B8G8R8_UINT_PACK32, "VK_FORMAT_A8B8G8R8_UINT_PACK32"},
	{VK_FORMAT_A8B8G8R8_SINT_PACK32, "VK_FORMAT_A8B8G8R8_SINT_PACK32"},
	{VK_FORMAT_A8B8G8R8_SRGB_PACK32, "VK_FORMAT_A8B8G8R8_SRGB_PACK32"},
	{VK_FORMAT_A2R10G10B10_UNORM_PACK32, "VK_FORMAT_A2R10G10B10_UNORM_PACK32"},
	{VK_FORMAT_A2R10G10B10_SNORM_PACK32, "VK_FORMAT_A2R10G10B10_SNORM_PACK32"},
	{VK_FORMAT_A2R10G10B10_USCALED_PACK32, "VK_FORMAT_A2R10G10B10_USCALED_PACK32"},
	{VK_FORMAT_A2R10G10B10_SSCALED_PACK32, "VK_FORMAT_A2R10G10B10_SSCALED_PACK32"},
	{VK_FORMAT_A2R10G10B10_UINT_PACK32, "VK_FORMAT_A2R10G10B10_UINT_PACK32"},
	{VK_FORMAT_A2R10G10B10_SINT_PACK32, "VK_FORMAT_A2R10G10B10_SINT_PACK32"},
	{VK_FORMAT_A2B10G10R10_UNORM_PACK32, "VK_FORMAT_A2B10G10R10_UNORM_PACK32"},
	{VK_FORMAT_A2B10G10R10_SNORM_PACK32, "VK_FORMAT_A2B10G10R10_SNORM_PACK32"},
	{VK_FORMAT_A2B10G10R10_USCALED_PACK32, "VK_FORMAT_A2B10G10R10_USCALED_PACK32"},
	{VK_FORMAT_A2B10G10R10_SSCALED_PACK32, "VK_FORMAT_A2B10G10R10_SSCALED_PACK32"},
	{VK_FORMAT_A2B10G10R10_UINT_PACK32, "VK_FORMAT_A2B10G10R10_UINT_PACK32"},
	{VK_FORMAT_A2B10G10R10_SINT_PACK32, "VK_FORMAT_A2B10G10R10_SINT_PACK32"},
	{VK_FORMAT_R16_UNORM, "VK_FORMAT_R16_UNORM"},
	{VK_FORMAT_R16_SNORM, "VK_FORMAT_R16_SNORM"},
	{VK_FORMAT_R16_USCALED, "VK_FORMAT_R16_USCALED"},
	{VK_FORMAT_R16_SSCALED, "VK_FORMAT_R16_SSCALED"},
	{VK_FORMAT_R16_UINT, "VK_FORMAT_R16_UINT"},
	{VK_FORMAT_R16_SINT, "VK_FORMAT_R16_SINT"},
	{VK_FORMAT_R16_SFLOAT, "VK_FORMAT_R16_SFLOAT"},
	{VK_FORMAT_R16G16_UNORM, "VK_FORMAT_R16G16_UNORM"},
	{VK_FORMAT_R16G16_SNORM, "VK_FORMAT_R16G16_SNORM"},
	{VK_FORMAT_R16G16_USCALED, "VK_FORMAT_R16G16_USCALED"},
	{VK_FORMAT_R16G16_SSCALED, "VK_FORMAT_R16G16_SSCALED"},
	{VK_FORMAT_R16G16_UINT, "VK_FORMAT_R16G16_UINT"},
	{VK_FORMAT_R16G16_SINT, "VK_FORMAT_R16G16_SINT"},
	{VK_FORMAT_R16G16_SFLOAT, "VK_FORMAT_R16G16_SFLOAT"},
	{VK_FORMAT_R16G16B16_UNORM, "VK_FORMAT_R16G16B16_UNORM"},
	{VK_FORMAT_R16G16B16_SNORM, "VK_FORMAT_R16G16B16_SNORM"},
	{VK_FORMAT_R16G16B16_USCALED, "VK_FORMAT_R16G16B16_USCALED"},
	{VK_FORMAT_R16G16B16_SSCALED, "VK_FORMAT_R16G16B16_SSCALED"},
	{VK_FORMAT_R16G16B16_UINT, "VK_FORMAT_R16G16B16_UINT"},
	{VK_FORMAT_R16G16B16_SINT, "VK_FORMAT_R16G16B16_SINT"},
	{VK_FORMAT_R16G16B16_SFLOAT, "VK_FORMAT_R16G16B16_SFLOAT"},
	{VK_FORMAT_R16G16B16A16_UNORM, "VK_FORMAT_R16G16B16A16_UNORM"},
	{VK_FORMAT_R16G16B16A16_SNORM, "VK_FORMAT_R16G16B16A16_SNORM"},
	{VK_FORMAT_R16G16B16A16_USCALED, "VK_FORMAT_R16G16B16A16_USCALED"},
	{VK_FORMAT_R16G16B16A16_SSCALED, "VK_FORMAT_R16G16B16A16_SSCALED"},
	{VK_FORMAT_R16G16B16A16_UINT, "VK_FORMAT_R16G16B16A16_UINT"},
	{VK_FORMAT_R16G16B16A16_SINT, "VK_FORMAT_R16G16B16A16_SINT"},
	{VK_FORMAT_R16G16B16A16_SFLOAT, "VK_FORMAT_R16G16B16A16_SFLOAT"},
	{VK_FORMAT_R32_UINT, "VK_FORMAT_R32_UINT"},
	{VK_FORMAT_R32_SINT, "VK_FORMAT_R32_SINT"},
	{VK_FORMAT_R32_SFLOAT, "VK_FORMAT_R32_SFLOAT"},
	{VK_FORMAT_R32G32_UINT, "VK_FORMAT_R32G32_UINT"},
	{VK_FORMAT_R32G32_SINT, "VK_FORMAT_R32G32_SINT"},
	{VK_FORMAT_R32G32_SFLOAT, "VK_FORMAT_R32G32_SFLOAT"},
	{VK_FORMAT_R32G32B32_UINT, "VK_FORMAT_R32G32B32_UINT"},
	{VK_FORMAT_R32G32B32_SINT, "VK_FORMAT_R32G32B32_SINT"},
	{VK_FORMAT_R32G32B32_SFLOAT, "VK_FORMAT_R32G32B32_SFLOAT"},
	{VK_FORMAT_R32G32B32A32_UINT, "VK_FORMAT_R32G32B32A32_UINT"},
	{VK_FORMAT_R32G32B32A32_SINT, "VK_FORMAT_R32G32B32A32_SINT"},
	{VK_FORMAT_R32G32B32A32_SFLOAT, "VK_FORMAT_R32G32B32A32_SFLOAT"},
	{VK_FORMAT_R64_UINT, "VK_FORMAT_R64_UINT"},
	{VK_FORMAT_R64_SINT, "VK_FORMAT_R64_SINT"},
	{VK_FORMAT_R64_SFLOAT, "VK_FORMAT_R64_SFLOAT"},
	{VK_FORMAT_R64G64_UINT, "VK_FORMAT_R64G64_UINT"},
	{VK_FORMAT_R64G64_SINT, "VK_FORMAT_R64G64_SINT"},
	{VK_FORMAT_R64G64_SFLOAT, "VK_FORMAT_R64G64_SFLOAT"},
	{VK_FORMAT_R64G64B64_UINT, "VK_FORMAT_R64G64B64_UINT"},
	{VK_FORMAT_R64G64B64_SINT, "VK_FORMAT_R64G64B64_SINT"},
	{VK_FORMAT_R64G64B64_SFLOAT, "VK_FORMAT_R64G64B64_SFLOAT"},
	{VK_FORMAT_R64G64B64A64_UINT, "VK_FORMAT_R64G64B64A64_UINT"},
	{VK_FORMAT_R64G64B64A64_SINT, "VK_FORMAT_R64G64B64A64_SINT"},
	{VK_FORMAT_R64G64B64A64_SFLOAT, "VK_FORMAT_R64G64B64A64_SFLOAT"},
	{VK_FORMAT_B10G11R11_UFLOAT_PACK32, "VK_FORMAT_B10G11R11_UFLOAT_PACK32"}
};

const std::vector<colorSpaceName> colorSpaces = {
	{VK_COLOR_SPACE_SRGB_NONLINEAR_KHR, "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"},
	{VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT, "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT, "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"},
	{VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT, "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT"},
	{VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT, "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_BT709_LINEAR_EXT, "VK_COLOR_SPACE_BT709_LINEAR_EXT"},
	{VK_COLOR_SPACE_BT709_NONLINEAR_EXT, "VK_COLOR_SPACE_BT709_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_BT2020_LINEAR_EXT, "VK_COLOR_SPACE_BT2020_LINEAR_EXT"},
	{VK_COLOR_SPACE_HDR10_ST2084_EXT, "VK_COLOR_SPACE_HDR10_ST2084_EXT"},
	{VK_COLOR_SPACE_DOLBYVISION_EXT, "VK_COLOR_SPACE_DOLBYVISION_EXT"},
	{VK_COLOR_SPACE_HDR10_HLG_EXT, "VK_COLOR_SPACE_HDR10_HLG_EXT"},
	{VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT, "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"},
	{VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT, "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_PASS_THROUGH_EXT, "VK_COLOR_SPACE_PASS_THROUGH_EXT"},
	{VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT, "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"},
	{VK_COLOR_SPACE_DISPLAY_NATIVE_AMD, "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD"},
	{VK_COLOR_SPACE_MAX_ENUM_KHR, "VK_COLOR_SPACE_MAX_ENUM_KHR"}
};

const std::vector<presentModeName> presentModes = {
	{VK_PRESENT_MODE_IMMEDIATE_KHR, "VK_PRESENT_MODE_IMMEDIATE_KHR"},
	{VK_PRESENT_MODE_MAILBOX_KHR, "VK_PRESENT_MODE_MAILBOX_KHR"},
	{VK_PRESENT_MODE_FIFO_KHR, "VK_PRESENT_MODE_FIFO_KHR"},
	{VK_PRESENT_MODE_FIFO_RELAXED_KHR, "VK_PRESENT_MODE_FIFO_RELAXED_KHR"},
	{VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR, "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"},
	{VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"},
	{VK_PRESENT_MODE_MAX_ENUM_KHR, "VK_PRESENT_MODE_MAX_ENUM_KHR"}
};

const std::vector<Vertex> vertices = {
	{{-1.0f, -1.0f}},
	{{1.0f, -1.0f}},
	{{1.0f, 1.0f}},
	{{-1.0f, 1.0f}}
};

const std::vector<uint16_t> indices = {
	0, 1, 2, 2, 3, 0
};

// Table For Cone Response
// http://www.cvrl.org/ciexyzpr.htm
// Converted XYZ Values From CIEXYZ2006 Table To LMS Values
const float CIELMS2006[1323] = {
    0.000446791201f, 0.000285471690f, 0.006815772006f,
    0.000544605453f, 0.000350402455f, 0.008258398353f,
    0.000662378860f, 0.000429198705f, 0.010004675217f,
    0.000803535640f, 0.000524352997f, 0.012113361708f,
    0.000971862809f, 0.000638631434f, 0.014652380691f,
    0.001171474480f, 0.000775041951f, 0.017699468593f,
    0.001406749686f, 0.000936769960f, 0.021342531594f,
    0.001682226174f, 0.001127086245f, 0.025679675471f,
    0.002002459186f, 0.001349222261f, 0.030818685751f,
    0.002371836074f, 0.001606164131f, 0.036875796441f,
    0.002794314065f, 0.001900466182f, 0.043973633747f,
    0.003273663095f, 0.002234411327f, 0.052239252202f,
    0.003815310962f, 0.002611773478f, 0.061805093498f,
    0.004425876131f, 0.003037433419f, 0.072803807265f,
    0.005112981402f, 0.003517336789f, 0.085362740693f,
    0.005885554228f, 0.004058762190f, 0.099597461614f,
    0.006752371595f, 0.004669716718f, 0.115604723240f,
    0.007715321774f, 0.005354982938f, 0.133452429181f,
    0.008770868112f, 0.006117196814f, 0.153170876910f,
    0.009910276471f, 0.006957085731f, 0.174742846003f,
    0.011118582077f, 0.007872910566f, 0.198093663281f,
    0.012378160861f, 0.008861664685f, 0.223111673244f,
    0.013685422750f, 0.009925448149f, 0.249757413704f,
    0.015043929434f, 0.011069059203f, 0.278023368055f,
    0.016461532729f, 0.012298884213f, 0.307916852666f,
    0.017950996821f, 0.013623224040f, 0.339466886569f,
    0.019524670048f, 0.015050898366f, 0.372661763573f,
    0.021173348726f, 0.016583575201f, 0.407195428387f,
    0.022877498535f, 0.018219175809f, 0.442586017210f,
    0.024611698391f, 0.019953414996f, 0.478228289146f,
    0.026344636634f, 0.021779097448f, 0.513395166492f,
    0.028047780439f, 0.023688908898f, 0.547420258905f,
    0.029726301547f, 0.025685787501f, 0.580318846046f,
    0.031400362165f, 0.027778028077f, 0.612422089906f,
    0.033097437554f, 0.029977413789f, 0.644222451468f,
    0.034852667971f, 0.032299556490f, 0.676368515343f,
    0.036698909600f, 0.034762180243f, 0.709422178713f,
    0.038632514359f, 0.037375633440f, 0.743033549681f,
    0.040637143961f, 0.040147816898f, 0.776518247337f,
    0.042692373187f, 0.043086983007f, 0.809082468688f,
    0.044773869156f, 0.046200685515f, 0.839825884399f,
    0.046859034603f, 0.049492473731f, 0.868018151356f,
    0.048948284684f, 0.052947301159f, 0.893952971738f,
    0.051049733944f, 0.056541352783f, 0.918289157669f,
    0.053173643572f, 0.060244904154f, 0.941791185052f,
    0.055332394231f, 0.064022375206f, 0.965319089280f,
    0.057533320772f, 0.067838479452f, 0.989482701306f,
    0.059756132301f, 0.071677567408f, 1.013541881784f,
    0.061970286209f, 0.075529161125f, 1.036324471295f,
    0.064141386057f, 0.079382501435f, 1.056563736717f,
    0.066231528146f, 0.083226588777f, 1.072921598772f,
    0.068213945837f, 0.087056278952f, 1.084439258782f,
    0.070118480446f, 0.090896251379f, 1.091860984067f,
    0.071994689313f, 0.094785845215f, 1.096427754128f,
    0.073898220866f, 0.098773425801f, 1.099431562816f,
    0.075890623419f, 0.102917148382f, 1.102188925371f,
    0.078020765563f, 0.107264539573f, 1.105558090451f,
    0.080263600868f, 0.111782834672f, 1.108515444043f,
    0.082571056923f, 0.116408235102f, 1.109557911184f,
    0.084889601296f, 0.121064463035f, 1.107189810295f,
    0.087160199084f, 0.125662546024f, 1.099961298778f,
    0.089339798764f, 0.130133083196f, 1.087009938391f,
    0.091469361661f, 0.134538492690f, 1.069532101886f,
    0.093616552805f, 0.138989112837f, 1.049190561320f,
    0.095855189124f, 0.143612572531f, 1.027559984256f,
    0.098265810128f, 0.148555441568f, 1.006097360232f,
    0.100921078530f, 0.153951356658f, 0.985873620917f,
    0.103838717564f, 0.159812357725f, 0.966837567126f,
    0.107022554740f, 0.166114457711f, 0.948690937428f,
    0.110476873090f, 0.172827377083f, 0.931159375666f,
    0.114205810793f, 0.179913315901f, 0.913991691619f,
    0.118205910035f, 0.187326033047f, 0.896883401090f,
    0.122442142282f, 0.195012343282f, 0.879267616362f,
    0.126865035642f, 0.202908867221f, 0.860557672417f,
    0.131417257607f, 0.210939688235f, 0.840224880688f,
    0.136032391834f, 0.219016422326f, 0.817809742361f,
    0.140650302970f, 0.227055228721f, 0.793051763874f,
    0.145268684856f, 0.235036504573f, 0.766230599976f,
    0.149902315788f, 0.242960069707f, 0.737749929432f,
    0.154568709520f, 0.250828753599f, 0.707999876470f,
    0.159287864470f, 0.258648079291f, 0.677351527355f,
    0.164082804132f, 0.266432380043f, 0.646160565467f,
    0.168980944144f, 0.274222497624f, 0.614780887453f,
    0.174013218214f, 0.282072155577f, 0.583532565228f,
    0.179214207394f, 0.290042740730f, 0.552692481021f,
    0.184622424197f, 0.298204280520f, 0.522495374775f,
    0.190274152301f, 0.306622789284f, 0.493154083530f,
    0.196182507267f, 0.315320245988f, 0.464906150553f,
    0.202354086275f, 0.324307882949f, 0.437951505268f,
    0.208795133478f, 0.333598145047f, 0.412439124363f,
    0.215510959093f, 0.343204043555f, 0.388473285358f,
    0.222496537875f, 0.353120216519f, 0.366055898210f,
    0.229703222750f, 0.363257694266f, 0.344928810596f,
    0.237064292731f, 0.373494087365f, 0.324820346459f,
    0.244503733222f, 0.383691275441f, 0.305510152152f,
    0.251935703846f, 0.393695177813f, 0.286823743812f,
    0.259305727981f, 0.403404842213f, 0.268694396149f,
    0.266724066457f, 0.412993316530f, 0.251325072957f,
    0.274359362112f, 0.422726780176f, 0.234927194211f,
    0.282400827738f, 0.432899717409f, 0.219652555326f,
    0.291060576333f, 0.443837403391f, 0.205602861540f,
    0.300512953715f, 0.455798400980f, 0.192790727816f,
    0.310688180933f, 0.468649950058f, 0.181027561249f,
    0.321434798481f, 0.482132221297f, 0.170111430040f,
    0.332575518340f, 0.495949014974f, 0.159875459352f,
    0.343904278479f, 0.509764525620f, 0.150182748358f,
    0.355238361424f, 0.523291596151f, 0.140929173566f,
    0.366597058241f, 0.536584764449f, 0.132058730092f,
    0.378063416840f, 0.549804583182f, 0.123533280399f,
    0.389733824562f, 0.563132327714f, 0.115323204742f,
    0.401718321195f, 0.576769889481f, 0.107406476996f,
    0.414113547189f, 0.590887860932f, 0.099770189547f,
    0.426912901683f, 0.605457135131f, 0.092414696660f,
    0.440077682639f, 0.620388381365f, 0.085344288039f,
    0.453562770999f, 0.635581535415f, 0.078564246872f,
    0.467316313376f, 0.650925230196f, 0.072080033481f,
    0.481285942447f, 0.666307918717f, 0.065914705983f,
    0.495440876379f, 0.681655384645f, 0.060147758659f,
    0.509754069281f, 0.696900214964f, 0.054844515136f,
    0.524195474898f, 0.711970329912f, 0.050041337771f,
    0.538732235938f, 0.726789463589f, 0.045752243188f,
    0.553340340733f, 0.741310032253f, 0.041958023992f,
    0.568044438887f, 0.755619595835f, 0.038572077471f,
    0.582886083187f, 0.769849752097f, 0.035509891855f,
    0.597913726911f, 0.784145639351f, 0.032704460752f,
    0.613182677790f, 0.798665685405f, 0.030102971525f,
    0.628713503432f, 0.813497663694f, 0.027670374913f,
    0.644357845779f, 0.828392970681f, 0.025401732367f,
    0.659906028625f, 0.842993441253f, 0.023296395041f,
    0.675126436444f, 0.856912494195f, 0.021351357446f,
    0.689765745973f, 0.869737411412f, 0.019561771525f,
    0.703611033036f, 0.881132546068f, 0.017919878077f,
    0.716684669778f, 0.891153349431f, 0.016411945429f,
    0.729081366543f, 0.899970386620f, 0.015024543232f,
    0.740909607886f, 0.907770576359f, 0.013746007650f,
    0.752290161325f, 0.914753642072f, 0.012566196850f,
    0.763332866470f, 0.921101422934f, 0.011477236105f,
    0.774066900523f, 0.926889431190f, 0.010475480710f,
    0.784501682318f, 0.932167288062f, 0.009557550694f,
    0.794649442892f, 0.936987429640f, 0.008719440344f,
    0.804524498769f, 0.941403637223f, 0.007956700634f,
    0.814165776771f, 0.945482208569f, 0.007263857283f,
    0.823704670756f, 0.949332687944f, 0.006632822815f,
    0.833302321097f, 0.953077401324f, 0.006056034895f,
    0.843128334332f, 0.956840900470f, 0.005527110954f,
    0.853360488604f, 0.960749348504f, 0.005040691750f,
    0.864107686060f, 0.964861010983f, 0.004592645461f,
    0.875165304908f, 0.968952136436f, 0.004180845044f,
    0.886235761649f, 0.972724707358f, 0.003803456353f,
    0.897004013330f, 0.975876443134f, 0.003458523463f,
    0.907138807832f, 0.978103799476f, 0.003144022579f,
    0.916347211043f, 0.979151570347f, 0.002857799222f,
    0.924545939079f, 0.978964309861f, 0.002597356441f,
    0.931708138528f, 0.977540275782f, 0.002360322914f,
    0.937811472896f, 0.974883666843f, 0.002144557640f,
    0.942838255567f, 0.971004188278f, 0.001948124790f,
    0.946845047707f, 0.965987626411f, 0.001769282273f,
    0.950171702532f, 0.960200573623f, 0.001606484988f,
    0.953234688708f, 0.954069206649f, 0.001458327421f,
    0.956456217394f, 0.948006274966f, 0.001323526561f,
    0.960263235088f, 0.942409330971f, 0.001200906493f,
    0.964952536439f, 0.937521485254f, 0.001089409113f,
    0.970274084447f, 0.933013348402f, 0.000988119752f,
    0.975835019479f, 0.928425329900f, 0.000896194984f,
    0.981233618784f, 0.923310260328f, 0.000812844988f,
    0.986058732666f, 0.917234679236f, 0.000737330789f,
    0.989998954023f, 0.909908441154f, 0.000668952456f,
    0.993167871975f, 0.901553529961f, 0.000607009761f,
    0.995790379634f, 0.892510292087f, 0.000550864446f,
    0.998094750677f, 0.883106046852f, 0.000499945613f,
    1.000311771879f, 0.873653553348f, 0.000453743100f,
    1.002615256845f, 0.864361948379f, 0.000411806223f,
    1.004945057825f, 0.855081363769f, 0.000373749339f,
    1.007181648589f, 0.845583436290f, 0.000339224708f,
    1.009204681156f, 0.835651868596f, 0.000307913655f,
    1.010893433648f, 0.825083424475f, 0.000279524276f,
    1.012146071657f, 0.813738760961f, 0.000253788765f,
    1.012935978608f, 0.801684285538f, 0.000230459098f,
    1.013256302092f, 0.789034017380f, 0.000209309179f,
    1.013100748647f, 0.775897103957f, 0.000190134184f,
    1.012463965039f, 0.762378092575f, 0.000172748435f,
    1.011315599519f, 0.748536414758f, 0.000156983825f,
    1.009524559890f, 0.734275618292f, 0.000142688265f,
    1.006937309191f, 0.719472862686f, 0.000129724031f,
    1.003404959807f, 0.704020055437f, 0.000117966246f,
    0.998785410404f, 0.687825950947f, 0.000107301614f,
    0.993053811380f, 0.670887747175f, 0.000097627445f,
    0.986625582942f, 0.653492866350f, 0.000088850502f,
    0.980011461827f, 0.635971466953f, 0.000080886226f,
    0.973704004532f, 0.618620926111f, 0.000073658137f,
    0.968178572475f, 0.601705257294f, 0.000067097073f,
    0.963739819817f, 0.585393652539f, 0.000061140237f,
    0.960058683852f, 0.569589392249f, 0.000055730836f,
    0.956661077597f, 0.554143668783f, 0.000050817568f,
    0.953082866924f, 0.538924580964f, 0.000046353830f,
    0.948869080949f, 0.523816131217f, 0.000042297540f,
    0.943670437635f, 0.508725541075f, 0.000038610584f,
    0.937516378388f, 0.493615545269f, 0.000035258437f,
    0.930530352863f, 0.478465286878f, 0.000032209839f,
    0.922834924328f, 0.463259600331f, 0.000029436514f,
    0.914550477257f, 0.447988833310f, 0.000026912865f,
    0.905777399580f, 0.432662747456f, 0.000024615720f,
    0.896545135839f, 0.417346400591f, 0.000022524094f,
    0.886866822567f, 0.402110969655f, 0.000020618967f,
    0.876754455034f, 0.387021678291f, 0.000018883145f,
    0.866220978413f, 0.372135366200f, 0.000017301046f,
    0.855286395408f, 0.357495750218f, 0.000015858566f,
    0.844001884099f, 0.343112521195f, 0.000014542904f,
    0.832425509040f, 0.328989259576f, 0.000013342478f,
    0.820613843732f, 0.315130274497f, 0.000012246788f,
    0.808622146353f, 0.301540255735f, 0.000011246320f,
    0.796480784154f, 0.288230584427f, 0.000010332457f,
    0.784129879371f, 0.275227794933f, 0.000009497375f,
    0.771491803973f, 0.262559183602f, 0.000008733974f,
    0.758494709642f, 0.250247615118f, 0.000008035828f,
    0.745074222615f, 0.238311074645f, 0.000007397103f,
    0.731194794322f, 0.226762817412f, 0.000006812500f,
    0.716916509268f, 0.215610807898f, 0.000006277209f,
    0.702319572459f, 0.204859949682f, 0.000005786862f,
    0.687481233501f, 0.194511246139f, 0.000005337494f,
    0.672473477160f, 0.184566374622f, 0.000004925505f,
    0.657355242830f, 0.175020851416f, 0.000004547620f,
    0.642140409622f, 0.165863443275f, 0.000004200868f,
    0.626833854070f, 0.157080299102f, 0.000003882547f,
    0.611441307355f, 0.148658955197f, 0.000003590197f,
    0.595969959290f, 0.140587481210f, 0.000003321583f,
    0.580443832479f, 0.132855258683f, 0.000000000000f,
    0.564949335618f, 0.125455759488f, 0.000000000000f,
    0.549580150535f, 0.118382509597f, 0.000000000000f,
    0.534420786584f, 0.111628978179f, 0.000000000000f,
    0.519546529219f, 0.105187481632f, 0.000000000000f,
    0.504981028590f, 0.099051390456f, 0.000000000000f,
    0.490575994927f, 0.093216751927f, 0.000000000000f,
    0.476160254633f, 0.087679249182f, 0.000000000000f,
    0.461584710046f, 0.082432679458f, 0.000000000000f,
    0.446722646384f, 0.077469629526f, 0.000000000000f,
    0.431517946931f, 0.072780179742f, 0.000000000000f,
    0.416114848981f, 0.068348502471f, 0.000000000000f,
    0.400688815881f, 0.064158525318f, 0.000000000000f,
    0.385395311003f, 0.060195885805f, 0.000000000000f,
    0.370369567238f, 0.056447361192f, 0.000000000000f,
    0.355713257232f, 0.052901858798f, 0.000000000000f,
    0.341457795628f, 0.049553198960f, 0.000000000000f,
    0.327615907002f, 0.046395344184f, 0.000000000000f,
    0.314197477937f, 0.043421931633f, 0.000000000000f,
    0.301209797977f, 0.040626352023f, 0.000000000000f,
    0.288659043540f, 0.037999452218f, 0.000000000000f,
    0.276554468960f, 0.035525212791f, 0.000000000000f,
    0.264903541312f, 0.033188630231f, 0.000000000000f,
    0.253710139268f, 0.030976460892f, 0.000000000000f,
    0.242975480974f, 0.028877992782f, 0.000000000000f,
    0.232680492532f, 0.026888267461f, 0.000000000000f,
    0.222738951714f, 0.025017293915f, 0.000000000000f,
    0.213061291860f, 0.023274774920f, 0.000000000000f,
    0.203572431549f, 0.021665893752f, 0.000000000000f,
    0.194211085038f, 0.020192851079f, 0.000000000000f,
    0.184946914334f, 0.018850624781f, 0.000000000000f,
    0.175826936290f, 0.017617832972f, 0.000000000000f,
    0.166908741802f, 0.016473176626f, 0.000000000000f,
    0.158240531708f, 0.015399495506f, 0.000000000000f,
    0.149861560830f, 0.014382546423f, 0.000000000000f,
    0.141800540437f, 0.013413375977f, 0.000000000000f,
    0.134069064675f, 0.012492228341f, 0.000000000000f,
    0.126672469509f, 0.011620876846f, 0.000000000000f,
    0.119613005767f, 0.010800018368f, 0.000000000000f,
    0.112890303561f, 0.010029765220f, 0.000000000000f,
    0.106499765768f, 0.009309319135f, 0.000000000000f,
    0.100428233079f, 0.008636744633f, 0.000000000000f,
    0.094661261922f, 0.008009633916f, 0.000000000000f,
    0.089185048478f, 0.007425638247f, 0.000000000000f,
    0.083986428821f, 0.006882499740f, 0.000000000000f,
    0.079053128808f, 0.006378005616f, 0.000000000000f,
    0.074374428945f, 0.005910703380f, 0.000000000000f,
    0.069940074379f, 0.005478979587f, 0.000000000000f,
    0.065740001385f, 0.005081131004f, 0.000000000000f,
    0.061764310737f, 0.004715428036f, 0.000000000000f,
    0.058003175330f, 0.004379634620f, 0.000000000000f,
    0.054446219010f, 0.004070505950f, 0.000000000000f,
    0.051083404658f, 0.003784863663f, 0.000000000000f,
    0.047905131187f, 0.003520045423f, 0.000000000000f,
    0.044902302478f, 0.003273746991f, 0.000000000000f,
    0.042066231197f, 0.003044105778f, 0.000000000000f,
    0.039388578232f, 0.002829959840f, 0.000000000000f,
    0.036861404291f, 0.002630355304f, 0.000000000000f,
    0.034477164435f, 0.002444386084f, 0.000000000000f,
    0.032228675561f, 0.002271178078f, 0.000000000000f,
    0.030109340448f, 0.002109905287f, 0.000000000000f,
    0.028113760241f, 0.001959769190f, 0.000000000000f,
    0.026236739693f, 0.001820017179f, 0.000000000000f,
    0.024473083870f, 0.001689965553f, 0.000000000000f,
    0.022817596311f, 0.001568944316f, 0.000000000000f,
    0.021264464166f, 0.001456314517f, 0.000000000000f,
    0.019805727108f, 0.001351372499f, 0.000000000000f,
    0.018433737554f, 0.001253442216f, 0.000000000000f,
    0.017141828966f, 0.001161947255f, 0.000000000000f,
    0.015924183563f, 0.001076384099f, 0.000000000000f,
    0.014777227038f, 0.000996367096f, 0.000000000000f,
    0.013703282361f, 0.000921915488f, 0.000000000000f,
    0.012704468897f, 0.000853002605f, 0.000000000000f,
    0.011781299522f, 0.000789545750f, 0.000000000000f,
    0.010932996317f, 0.000731383875f, 0.000000000000f,
    0.010156484492f, 0.000678244881f, 0.000000000000f,
    0.009443488232f, 0.000629579404f, 0.000000000000f,
    0.008785718678f, 0.000584841186f, 0.000000000000f,
    0.008176154255f, 0.000543568800f, 0.000000000000f,
    0.007608846673f, 0.000505364810f, 0.000000000000f,
    0.007079201899f, 0.000469898081f, 0.000000000000f,
    0.006584903785f, 0.000436950038f, 0.000000000000f,
    0.006124141821f, 0.000406325986f, 0.000000000000f,
    0.005695109374f, 0.000377856980f, 0.000000000000f,
    0.005296031915f, 0.000351385349f, 0.000000000000f,
    0.004924989890f, 0.000326755243f, 0.000000000000f,
    0.004579468788f, 0.000303812768f, 0.000000000000f,
    0.004257085127f, 0.000282413887f, 0.000000000000f,
    0.003955756540f, 0.000262430446f, 0.000000000000f,
    0.003673662698f, 0.000243750034f, 0.000000000000f,
    0.003409381770f, 0.000226283775f, 0.000000000000f,
    0.003162265054f, 0.000209983661f, 0.000000000000f,
    0.002931763823f, 0.000194814887f, 0.000000000000f,
    0.002717244911f, 0.000180730426f, 0.000000000000f,
    0.002518020135f, 0.000167681252f, 0.000000000000f,
    0.002333351637f, 0.000155615462f, 0.000000000000f,
    0.002162444591f, 0.000144462310f, 0.000000000000f,
    0.002004499255f, 0.000134158439f, 0.000000000000f,
    0.001858722959f, 0.000124639528f, 0.000000000000f,
    0.001724341858f, 0.000115848410f, 0.000000000000f,
    0.001600530964f, 0.000107727625f, 0.000000000000f,
    0.001486242615f, 0.000100213892f, 0.000000000000f,
    0.001380491261f, 0.000093250590f, 0.000000000000f,
    0.001282415473f, 0.000086784249f, 0.000000000000f,
    0.001191264664f, 0.000080770132f, 0.000000000000f,
    0.001106434943f, 0.000075171066f, 0.000000000000f,
    0.001027585936f, 0.000069963538f, 0.000000000000f,
    0.000954425779f, 0.000065127205f, 0.000000000000f,
    0.000886655638f, 0.000060641837f, 0.000000000000f,
    0.000823974522f, 0.000056486621f, 0.000000000000f,
    0.000766054852f, 0.000052640602f, 0.000000000000f,
    0.000712478377f, 0.000049076426f, 0.000000000000f,
    0.000662845446f, 0.000045767077f, 0.000000000000f,
    0.000616799637f, 0.000042690657f, 0.000000000000f,
    0.000574023885f, 0.000039826278f, 0.000000000000f,
    0.000534237513f, 0.000037155255f, 0.000000000000f,
    0.000497195149f, 0.000034663596f, 0.000000000000f,
    0.000462678062f, 0.000032338266f, 0.000000000000f,
    0.000430488595f, 0.000030167265f, 0.000000000000f,
    0.000400448182f, 0.000028139644f, 0.000000000000f,
    0.000372414382f, 0.000026246502f, 0.000000000000f,
    0.000346325025f, 0.000024483559f, 0.000000000000f,
    0.000322123579f, 0.000022846936f, 0.000000000000f,
    0.000299741180f, 0.000021331864f, 0.000000000000f,
    0.000279099884f, 0.000019933381f, 0.000000000000f,
    0.000260093916f, 0.000018644253f, 0.000000000000f,
    0.000242538705f, 0.000017451337f, 0.000000000000f,
    0.000226255557f, 0.000016341970f, 0.000000000000f,
    0.000211092046f, 0.000015305391f, 0.000000000000f,
    0.000196918198f, 0.000014332370f, 0.000000000000f,
    0.000183636172f, 0.000013416247f, 0.000000000000f,
    0.000171208681f, 0.000012555133f, 0.000000000000f,
    0.000159608063f, 0.000011747816f, 0.000000000000f,
    0.000148803080f, 0.000010992728f, 0.000000000000f,
    0.000138759902f, 0.000010288211f, 0.000000000000f,
    0.000129438739f, 0.000009631986f, 0.000000000000f,
    0.000120785407f, 0.000009020728f, 0.000000000000f,
    0.000112746515f, 0.000008451126f, 0.000000000000f,
    0.000105273414f, 0.000007920207f, 0.000000000000f,
    0.000098321819f, 0.000007425094f, 0.000000000000f,
    0.000091850646f, 0.000006963104f, 0.000000000000f,
    0.000085820120f, 0.000006531299f, 0.000000000000f,
    0.000080193814f, 0.000006127036f, 0.000000000000f,
    0.000074939009f, 0.000005747903f, 0.000000000000f,
    0.000070026232f, 0.000005391791f, 0.000000000000f,
    0.000065430986f, 0.000005056983f, 0.000000000000f,
    0.000061138630f, 0.000004742701f, 0.000000000000f,
    0.000057136173f, 0.000004448240f, 0.000000000000f,
    0.000053410065f, 0.000004172866f, 0.000000000000f,
    0.000049946509f, 0.000003915821f, 0.000000000000f,
    0.000046729184f, 0.000003676074f, 0.000000000000f,
    0.000043733415f, 0.000003451994f, 0.000000000000f,
    0.000040935411f, 0.000003241954f, 0.000000000000f,
    0.000038314575f, 0.000003044551f, 0.000000000000f,
    0.000035853084f, 0.000002858569f, 0.000000000000f,
    0.000033537937f, 0.000002683116f, 0.000000000000f,
    0.000031366661f, 0.000002518095f, 0.000000000000f,
    0.000029337847f, 0.000002363478f, 0.000000000000f,
    0.000027448721f, 0.000002219135f, 0.000000000000f,
    0.000025695423f, 0.000002084843f, 0.000000000000f,
    0.000024071545f, 0.000001960184f, 0.000000000000f,
    0.000022563945f, 0.000001844161f, 0.000000000000f,
    0.000021159533f, 0.000001735774f, 0.000000000000f,
    0.000019846973f, 0.000001634168f, 0.000000000000f,
    0.000018616449f, 0.000001538601f, 0.000000000000f,
    0.000017460218f, 0.000001448474f, 0.000000000000f,
    0.000016374401f, 0.000001363543f, 0.000000000000f,
    0.000015355910f, 0.000001283588f, 0.000000000000f,
    0.000014401615f, 0.000001208400f, 0.000000000000f,
    0.000013508408f, 0.000001137786f, 0.000000000000f,
    0.000012672938f, 0.000001071497f, 0.000000000000f,
    0.000011891047f, 0.000001009239f, 0.000000000000f,
    0.000011158694f, 0.000000950708f, 0.000000000000f,
    0.000010472204f, 0.000000895636f, 0.000000000000f,
    0.000009828228f, 0.000000843779f, 0.000000000000f,
    0.000009223876f, 0.000000794928f, 0.000000000000f,
    0.000008657105f, 0.000000748963f, 0.000000000000f,
    0.000008126072f, 0.000000705781f, 0.000000000000f,
    0.000007628954f, 0.000000665275f, 0.000000000000f,
    0.000007163965f, 0.000000627326f, 0.000000000000f,
    0.000006729280f, 0.000000591810f, 0.000000000000f,
    0.000006322852f, 0.000000558547f, 0.000000000000f,
    0.000005942709f, 0.000000527360f, 0.000000000000f,
    0.000005587024f, 0.000000498080f, 0.000000000000f,
    0.000005254103f, 0.000000470573f, 0.000000000000f,
    0.000004942298f, 0.000000444692f, 0.000000000000f,
    0.000004649769f, 0.000000420297f, 0.000000000000f,
    0.000004374799f, 0.000000397255f, 0.000000000000f,
    0.000004115870f, 0.000000375451f, 0.000000000000f,
    0.000003871632f, 0.000000354778f, 0.000000000000f,
    0.000003641033f, 0.000000335160f, 0.000000000000f,
    0.000003423642f, 0.000000316573f, 0.000000000000f,
    0.000003219123f, 0.000000299004f, 0.000000000000f,
    0.000003027082f, 0.000000282432f, 0.000000000000f,
    0.000002847082f, 0.000000266832f, 0.000000000000f,
    0.000002678606f, 0.000000252170f, 0.000000000000f,
    0.000002520941f, 0.000000238389f, 0.000000000000f,
    0.000002373366f, 0.000000225432f, 0.000000000000f,
    0.000002235211f, 0.000000213245f, 0.000000000000f,
    0.000002105849f, 0.000000201777f, 0.000000000000f,
    0.000001984669f, 0.000000190980f, 0.000000000000f,
    0.000001870983f, 0.000000180797f, 0.000000000000f,
    0.000001764148f, 0.000000171175f, 0.000000000000f,
    0.000001663590f, 0.000000162066f, 0.000000000000f,
    0.000001568795f, 0.000000153429f, 0.000000000000f,
    0.000001479332f, 0.000000145228f, 0.000000000000f,
    0.000001394934f, 0.000000137445f, 0.000000000000f,
    0.000001315365f, 0.000000130065f, 0.000000000000f,
    0.000001240399f, 0.000000123071f, 0.000000000000f,
    0.000001169811f, 0.000000116448f, 0.000000000000f,
    0.000001103383f, 0.000000110182f, 0.000000000000f,
    0.000001040903f, 0.000000104256f, 0.000000000000f,
    0.000000982166f, 0.000000098654f, 0.000000000000f,
    0.000000926974f, 0.000000093364f, 0.000000000000f,
    0.000000875134f, 0.000000088370f, 0.000000000000f
};

std::string vertexShaderCode{};
std::string fragmentShaderCode{};
std::string computeShaderCode{};

VkResult CreateDebugUtilsMessengerEXT(VkInstance instance,
const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo,
const VkAllocationCallbacks *pAllocator,
VkDebugUtilsMessengerEXT *pDebugMessenger) {
	PFN_vkCreateDebugUtilsMessengerEXT func = (PFN_vkCreateDebugUtilsMessengerEXT)
	vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
	if (func != nullptr) {
		return func(instance, pCreateInfo, pAllocator, pDebugMessenger);
	} else {
		return VK_ERROR_EXTENSION_NOT_PRESENT;
	}
}

void DestoryDebugUtilsMessengerEXT(VkInstance instance,
VkDebugUtilsMessengerEXT debugMessenger,
const VkAllocationCallbacks* pAllocator) {
	PFN_vkDestroyDebugUtilsMessengerEXT func = (PFN_vkDestroyDebugUtilsMessengerEXT)
	vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
	if (func != nullptr) {
		func(instance, debugMessenger, pAllocator);
	}
}

std::string ReadFile(const std::string& fileDir) {
	std::ifstream file(fileDir, std::ios::ate | std::ios::binary);

	if (!file.is_open()) {
		std::string error;
		error.append("Failed To Open The File With Directory ");
		error.append(fileDir.c_str());

		throw std::runtime_error(error);
	}

	size_t fileSize = (size_t)file.tellg();
	std::string buffer;
	buffer.resize(fileSize);

	file.seekg(0);
	file.read(buffer.data(), fileSize);
	file.close();

	return buffer;
}

nlohmann::ordered_json ReadJSON(const std::string& fileDir) {
	std::ifstream file(fileDir);

	if (!file.is_open()) {
		std::string error;
		error.append("Failed To Open The JSON File With Directory ");
		error.append(fileDir.c_str());

		throw std::runtime_error(error);
	}

	nlohmann::ordered_json json;
	file >> json;

	return json;
}

void SaveFile(const std::string& fileDir, const std::string& File) {
	std::ofstream file(fileDir, std::ios::binary);

	file << File;

	file.close();
}

void SavePPM(const std::string& filename, int width, int height, char* data) {
	std::ofstream file;
	file.open(filename, std::ios::out | std::ios::binary);

	file << "P6" << "\n" << width << "\n" << height << "\n" << "255" << "\n";

	file.write(data, static_cast<size_t>(width * height * 3));

	if (file.fail()) {
		throw std::runtime_error("Couldn't Save The Image File!");
	} else {
		std::cout << "Successfully Saved The Image File." << std::endl;
	}

	file.close();
}

double RoundDecimal(double number, double precision) {
	if (number >= 0.0) {
		number = static_cast<int>(number * precision + 0.5);
	} else {
		number = static_cast<int>(number * precision - 0.5);
	}

	return number / precision;
}

bool IsInRange(int x, int a, int b) {
	return (x >= a) && (x <= b) && (b >= a);
}

float SpectralPowerDistribution(float l, float l_peak, float d, float invert) {
	// Spectral Power Distribution Function Calculated On The Basis Of Peak Wavelength And Standard Deviation
	// Using Gaussian Function To Predict Spectral Radiance
	// In Reality, Spectral Radiance Function Has Different Shapes For Different Objects Also Looks Much Different Than This
	float x = (l - l_peak) / (2.0f * d * d);
	float radiance = exp(-x * x);
	radiance = glm::mix(radiance, 1.0f - radiance, invert);

	return radiance;
}

float BlackBodyRadiation(float l, float T) {
	// Plank's Law
	return (1.1910429724e-16f * pow(l, -5.0f)) / (exp(0.014387768775f / (l * T)) - 1.0f);
}

float BlackBodyRadiationPeak(float T) {
	// Derived By Substituting Wien's Displacement Law On Plank's Law
	return 4.0956746759e-6f * pow(T, 5.0f);
}

float Reinhard(float x) {
	// x / (1 + x)
	return x / (1.0f + x);
}

// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
float ACESFilm(float x) {
	// x(ax + b) / (x(cx + d) + e)
	float a = 2.51f;
	float b = 0.03f;
	float c = 2.43f;
	float d = 0.59f;
	float e = 0.14f;

	return x * (a * x + b) / (x * (c * x + d) + e);
}

// DEUCES Biophotometric Tonemap by Ted(Kerdek)
float DEUCESBioPhotometric(float x) {
	// e^(-0.25 / x)
	return exp(-0.25f / x);
}

float tonemapping(float x, int tonemap) {
	if (tonemap == 1) {
		x = Reinhard(x);
	}

	if (tonemap == 2) {
		x = ACESFilm(x);
	}

	if (tonemap == 3) {
		x = DEUCESBioPhotometric(x);
	}

	return x;
}

class App {
public:
    void run() {
        InitWindow();
		glslang::InitializeProcess();
        InitVulkan();
		if (!OFFSCREENRENDER) {
			InitImGui();
		}
        MainLoop();
		glslang::FinalizeProcess();
        CleanUp();
    }
private:
    GLFWwindow* window;
	int W = WIDTH;
	int H = HEIGHT;
	bool VSync = false;

	VkInstance instance;
	VkDebugUtilsMessengerEXT debugMessenger;
	VkSurfaceKHR surface;

	VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
	VkDevice device;

	VkQueue graphicsQueue;
	VkQueue computeQueue;
	VkQueue presentQueue;

	VkSwapchainKHR swapChain;
	std::vector<VkImage> swapChainImages;
	VkFormat swapChainImageFormat;
	std::vector<VkImageView> swapChainImageViews;

	VkRenderPass renderPass;

	VkDescriptorSetLayout descriptorSetLayout;
	std::vector<VkShaderModule> shaderModules;

	VkPipelineLayout graphicsPipelineLayout;
	VkPipeline graphicsPipeline;

	VkPipelineLayout computePipelineLayout;
	VkPipeline computePipeline;

	VkCommandPool commandPool;

	VkBuffer vertexBuffer;
	VkDeviceMemory vertexBufferMemory;
	VkBuffer indexBuffer;
	VkDeviceMemory indexBufferMemory;

	std::vector<VkBuffer> uniformBuffers;
	std::vector<VkDeviceMemory> uniformBuffersMemory;
	std::vector<void*> uniformBuffersMapped;
	UniformBufferObject ubo;

	VkBuffer texelBuffer;
	VkDeviceMemory texelBufferMemory;
	VkFormat texelBufferFormat = VK_FORMAT_R32G32B32A32_SFLOAT;
	VkBufferView texelBufferView;

	VkImage processorImage;
	VkFormat processorImageFormat = VK_FORMAT_B8G8R8A8_UNORM;
	VkDeviceMemory processorImageMemory;
	VkImageView processorImageView;

	VkImage saveImage;
	VkFormat saveImageFormat = VK_FORMAT_B8G8R8A8_UNORM;
	VkDeviceMemory saveImageMemory;

	std::vector<VkFramebuffer> framebuffers;

	VkDescriptorPool descriptorPool;
	std::vector<VkDescriptorSet> descriptorSets;

	PushConstantValues pushConstant;

	std::vector<VkCommandBuffer> graphicsCommandBuffers;
	std::vector<VkCommandBuffer> computeCommandBuffers;

	std::vector<VkSemaphore> imageAvailableSemaphores;
	std::vector<VkSemaphore> renderFinishedSemaphores;
	std::vector<VkFence> inFlightFences;

	std::vector<VkSemaphore> computeFinishedSemaphores;
	std::vector<VkFence> computeInFlightFences;

	VkDescriptorPool imguiDescriptorPool;
	ImGuiIO* io;

	bool isWindowMinimized = false;
	bool isVSyncChanged = false;
	bool isCameraLocked = false;
	bool isReset = false;
	bool isUpdateUBO = true;
	bool isRecompile = false;

	uint32_t currentFrame = 0;
	int samplesPerFrame = 1;
	int frame = 0;
	int currentSamples = 0;
	int numSamples = 10000;
	float frameTime = 0.0166f;
	float minFrameTime = 0.0f;

	float persistence = 0.0625f;
	int pathLength = 5;
	int tonemap = TONEMAP;

	nlohmann::ordered_json scene;
	bool isLoadScene = false;
	bool isSaveScene = false;
	bool isLoadSDF = false;
	bool isSaveSDF = false;

	Camera camera{};
	std::vector<sphere> spheres;
	std::vector<plane> planes;
	std::vector<box> boxes;
	std::vector<lens> lenses;
	std::vector<cyclide> cyclides;
	std::vector<material> materials;
	std::vector<sdf> sdfs;

	bool isImGuiWindowFocused = false;
	int objectSelection = 0;
	int materialSelection = 0;
	int sdfSelection = 0;

    void InitWindow() {
		glfwInit();

		glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);

		if (OFFSCREENRENDER) {
			glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);
		} else {
			glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE);
			glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);
		}

		window = glfwCreateWindow(W, H, "Path Tracer", nullptr, nullptr);

		GLFWmonitor* monitor = glfwGetPrimaryMonitor();
		int monitorX = 0;
		int monitorY = 0;
		int monitorWidth = 0;
		int monitorHeight = 0;

		glfwGetMonitorWorkarea(monitor, &monitorX, &monitorY, &monitorWidth, &monitorHeight);

		glfwSetWindowPos(window, monitorX + (monitorWidth - W) / 2, monitorY + (monitorHeight - H) / 2);
    }

	bool CheckValidationLayerSupport() {
		uint32_t layersCount;
		vkEnumerateInstanceLayerProperties(&layersCount, nullptr);
		std::vector<VkLayerProperties> availableLayers(layersCount);
		vkEnumerateInstanceLayerProperties(&layersCount, availableLayers.data());

		for(const char* layerName : validationLayers) {
			bool layerFound = false;
			for(const VkLayerProperties &layerProperties : availableLayers) {
				if (strcmp(layerName, layerProperties.layerName) == 0) {
					layerFound = true;
					break;
				}
			}

			if (!layerFound) {
				return false;
			}
		}
		return true;
	}

	void AvailableInstanceExtensions() {
		uint32_t availableExtensionsCount = 0;
		vkEnumerateInstanceExtensionProperties(nullptr, &availableExtensionsCount, nullptr);
		std::vector<VkExtensionProperties> availableExtensions(availableExtensionsCount);
		vkEnumerateInstanceExtensionProperties(nullptr, &availableExtensionsCount, availableExtensions.data());

		std::cout << "Available Instance Extensions:" << std::endl;
		for(const VkExtensionProperties &extension : availableExtensions) {
			std::cout << "\t" << extension.extensionName << std::endl;
		}
	}

	std::vector<const char*> GetRequiredInstanceExtensions() {
		uint32_t glfwExtensionsCount = 0;
		const char** glfwExtensions;
		glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionsCount);

		std::vector<const char*> extensions(glfwExtensionsCount);
		for (uint32_t i = 0; i < glfwExtensionsCount; i++) {
			extensions[i] = glfwExtensions[i];
		}

		if (isValidationLayersEnabled) {
			extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); // Require Extension VK_EXT_debug_utils
		}

		for (const char* instanceExtension : instanceExtensions) {
			extensions.push_back(instanceExtension);
		}

		std::cout << "Required Instance Extensions:" << std::endl;
		for(const char* extension : extensions) {
			//std::cout << "\t" << extension << std::endl;
		}

		return extensions;
	}

	void CreateInstance() {
		if (isValidationLayersEnabled && !CheckValidationLayerSupport()) {
			throw std::runtime_error("Validation Layers Are Requested But Not Available!");
		}

		VkApplicationInfo appInfo{};
		appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
		appInfo.pApplicationName = "Vulkan App";
		appInfo.applicationVersion = VK_MAKE_API_VERSION(0, 1, 0, 0);
		appInfo.pEngineName = "No Engine";
		appInfo.engineVersion = VK_MAKE_API_VERSION(0, 1, 0, 0);
		appInfo.apiVersion = VK_API_VERSION_1_3;

		VkInstanceCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
		createInfo.pApplicationInfo = &appInfo;

		AvailableInstanceExtensions();

		std::vector<const char*> extensions = GetRequiredInstanceExtensions();
		createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());
		createInfo.ppEnabledExtensionNames = extensions.data();

		if (isValidationLayersEnabled) {
			createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
			createInfo.ppEnabledLayerNames = validationLayers.data();
		} else {
			createInfo.enabledLayerCount = 0;
		}

		if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
			throw std::runtime_error("Instance Creation Failed!");
		}
	}

	static VKAPI_ATTR VkBool32 VKAPI_CALL DebugCallback(
	VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
	VkDebugUtilsMessageTypeFlagsEXT messageType,
	const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData,
	void *pUserData) {
		std::cerr << "Validation Layer: " << pCallbackData->pMessage << std::endl;

		return VK_FALSE;
	}

	void SetupDebugMessenger() {
		if (!isValidationLayersEnabled) {
			return;
		}

		VkDebugUtilsMessengerCreateInfoEXT createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
		createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
		VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
		createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
		VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
		VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
		createInfo.pfnUserCallback = DebugCallback;

		if (CreateDebugUtilsMessengerEXT(instance, &createInfo, nullptr, &debugMessenger) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Set Up Debug Messenger!");
		}
	}

	void CreateSurface() {
		if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
			throw std::runtime_error("Window Surface Creation Failed!");
		}
	}

	QueueFamilyIndices FindQueueFamilies(VkPhysicalDevice device) {
		QueueFamilyIndices indices;
		uint32_t queueFamilyCount = 0;
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);
		std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
		vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

		int i = 0;
		for (const VkQueueFamilyProperties &queueFamily : queueFamilies) {
			if ((queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) &&
				(queueFamily.queueFlags & VK_QUEUE_COMPUTE_BIT)) {
				indices.graphicsComputeFamily = i;
			}

			VkBool32 presentSupport = false;
			vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);
			if (presentSupport) {
				indices.presentFamily = i;
			}

			if (indices.IsComplete()) {
				break;
			}
			i++;
		}

		return indices;
	}

	SwapChainSupportDetails QuerySwapChainSupport(VkPhysicalDevice device) {
		SwapChainSupportDetails details;
		vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities);

		uint32_t formatCount;
		vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr);
		if (formatCount != 0) {
			details.formats.resize(formatCount);
			vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data());
		}

		uint32_t presentModeCount;
		vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr);
		if (presentModeCount != 0) {
			details.presentModes.resize(presentModeCount);
			vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data());
		}

		return details;
	}

	bool CheckDeviceExtensionsSupport(VkPhysicalDevice device) {
		uint32_t extensionCount;
		vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);
		std::vector<VkExtensionProperties> availableExtensions(extensionCount);
		vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data());

		std::cout << "Available Device Extensions:" << std::endl;
		for (const VkExtensionProperties& availableExtension : availableExtensions) {
			//std::cout << "\t" << availableExtension.extensionName << std::endl;
		}

		std::cout << "Required Device Extensions:" << std::endl;
		for (const char* deviceExtension : deviceExtensions) {
			//std::cout << "\t" << deviceExtension << std::endl;
		}

		std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());
		for (const VkExtensionProperties& extension : availableExtensions) {
			requiredExtensions.erase(extension.extensionName);
		}

		return requiredExtensions.empty();
	}

	bool IsDeviceSuitable(VkPhysicalDevice device) {
		QueueFamilyIndices indices = FindQueueFamilies(device);

		bool isExtensionsSupported = CheckDeviceExtensionsSupport(device);

		bool isSwapChainAdequate = false;
		if (isExtensionsSupported) {
			SwapChainSupportDetails swapChainSupport = QuerySwapChainSupport(device);
			isSwapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
		}

		return indices.IsComplete() && isExtensionsSupported && isSwapChainAdequate;
	}

	int RateDeviceSuitability(VkPhysicalDevice device) {
		int score = 0;
		VkPhysicalDeviceProperties deviceProperties;
		vkGetPhysicalDeviceProperties(device, &deviceProperties);
		VkPhysicalDeviceFeatures deviceFeatures;
		vkGetPhysicalDeviceFeatures(device, &deviceFeatures);

		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU) {
			score = 100;
		}
		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU) {
			score = 300;
		}
		if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
			score = 1000;
		}

		if (!IsDeviceSuitable(device)) {
			return 0;
		}

		return score;
	}

	void PickPhysicalDevice() {
		uint32_t devicesCount;
		vkEnumeratePhysicalDevices(instance, &devicesCount, nullptr);
		if (devicesCount == 0) {
			throw std::runtime_error("Failed To Find GPUs With Vulkan Support!");
		}

		std::vector<VkPhysicalDevice> devices(devicesCount);
		vkEnumeratePhysicalDevices(instance, &devicesCount, devices.data());

		std::multimap<int, VkPhysicalDevice> deviceScores;
		for (const VkPhysicalDevice &device : devices) {
			int score = RateDeviceSuitability(device);
			deviceScores.insert(std::make_pair(score, device));
		}

		if (deviceScores.rbegin()->first > 0) {
			physicalDevice = deviceScores.rbegin()->second;
		} else {
			throw std::runtime_error("Failed To Find A Suitable GPU!");
		}
	}

	void CreateLogicalDevice() {
		QueueFamilyIndices indices = FindQueueFamilies(physicalDevice);

		std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
		std::set<uint32_t> uniqueQueueFamilies = {indices.graphicsComputeFamily.value(), indices.presentFamily.value()};

		float queuePriority = 1.0f;
		for (uint32_t queueFamily : uniqueQueueFamilies) {
			VkDeviceQueueCreateInfo queueCreateInfo{};
			queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
			queueCreateInfo.queueFamilyIndex = queueFamily;
			queueCreateInfo.queueCount = 1;
			queueCreateInfo.pQueuePriorities = &queuePriority;
			queueCreateInfos.push_back(queueCreateInfo);
		}

		VkPhysicalDeviceFeatures deviceFeatures{};

		VkPhysicalDeviceUniformBufferStandardLayoutFeatures UBOLayoutFeatures{};
		UBOLayoutFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
		UBOLayoutFeatures.uniformBufferStandardLayout = VK_TRUE;

		VkDeviceCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
		createInfo.pNext = &UBOLayoutFeatures;
		createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
		createInfo.pQueueCreateInfos = queueCreateInfos.data();
		createInfo.pEnabledFeatures = &deviceFeatures;
		createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size());
		createInfo.ppEnabledExtensionNames = deviceExtensions.data();

		if (isValidationLayersEnabled) {
			createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
			createInfo.ppEnabledLayerNames = validationLayers.data();
		} else {
			createInfo.enabledLayerCount = 0;
		}

		if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) {
			throw std::runtime_error("Logical Device Creation Failed!");
		}

		vkGetDeviceQueue(device, indices.graphicsComputeFamily.value(), 0, &graphicsQueue);
		vkGetDeviceQueue(device, indices.graphicsComputeFamily.value(), 0, &computeQueue);
		vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &presentQueue);
	}

	VkSurfaceFormatKHR ChooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) {
		std::cout << "Available Surface Formats:" << std::endl;
		for (const VkSurfaceFormatKHR& availableFormat : availableFormats) {
			for (const colorSpaceName& colorSpace : colorSpaces) {
				if (availableFormat.colorSpace == colorSpace.space) {
					for (const colorFormatName& colorFormat : colorFormats) {
						if (availableFormat.format == colorFormat.format) {
							//std::cout << "\t" << colorFormat.name << ", " << colorSpace.name << std::endl;
						}
					}
				}
			}
		}

		VkSurfaceFormatKHR surfaceFormat;
		for (const VkSurfaceFormatKHR& availableFormat : availableFormats) {
			if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM) {
				surfaceFormat = availableFormat;
				for (const colorSpaceName& colorSpace : colorSpaces) {
					if (surfaceFormat.colorSpace == colorSpace.space) {
						std::cout << "Using VK_FORMAT_B8G8R8A8_UNORM Format With " << colorSpace.name << " Color Space" << std::endl;
						return surfaceFormat;
					}
				}
			}
		}

		throw std::runtime_error("Failed To Choose Appropriate Surface Format!");
	}

	VkPresentModeKHR ChooseSwapPresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes) {
		std::vector<presentModeName> availablePresentModesNames;
		std::cout << "Available Presentation Modes:" << std::endl;
		for (const VkPresentModeKHR& availablePresentMode : availablePresentModes) {
			for (const presentModeName& presentMode : presentModes) {
				if (availablePresentMode == presentMode.mode) {
					//std::cout << "\t" << presentMode.name << std::endl;
					availablePresentModesNames.push_back(presentMode);
					break;
				}
			}
		}

		if (VSync) {
			for (const presentModeName& availablePresentModeName : availablePresentModesNames) {
				if (availablePresentModeName.mode == VK_PRESENT_MODE_FIFO_RELAXED_KHR) {
					std::cout << "Using Presentation Mode VK_PRESENT_MODE_FIFO_RELAXED_KHR" << std::endl;
					return availablePresentModeName.mode;
				}
			}

			std::cout << "Using Presentation Mode VK_PRESENT_MODE_FIFO_KHR" << std::endl;
			return VK_PRESENT_MODE_FIFO_KHR;
		} else {
			for (const presentModeName& availablePresentModeName : availablePresentModesNames) {
				if (availablePresentModeName.mode == VK_PRESENT_MODE_MAILBOX_KHR) {
					std::cout << "Using Presentation Mode VK_PRESENT_MODE_MAILBOX_KHR" << std::endl;
					return availablePresentModeName.mode;
				}
			}

			for (const presentModeName& availablePresentModeName : availablePresentModesNames) {
				if (availablePresentModeName.mode == VK_PRESENT_MODE_IMMEDIATE_KHR) {
					std::cout << "Using Presentation Mode VK_PRESENT_MODE_IMMEDIATE_KHR" << std::endl;
					return availablePresentModeName.mode;
				}
			}

			throw std::runtime_error("Disabling VSync Is Not Supported!");
		}
	}

	VkExtent2D ChooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {
		if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
			W = capabilities.currentExtent.width;
			H = capabilities.currentExtent.height;
			return capabilities.currentExtent;
		} else {
			glfwGetWindowSize(window, &W, &H);
			VkExtent2D actualExtent = {
				static_cast<uint32_t>(W),
				static_cast<uint32_t>(H)
			};
			actualExtent.width = std::clamp(actualExtent.width,
				capabilities.minImageExtent.width,
				capabilities.maxImageExtent.width);
			actualExtent.height = std::clamp(actualExtent.height,
				capabilities.minImageExtent.height,
				capabilities.maxImageExtent.height);

			return actualExtent;
		}
	}

	void CreateSwapChain() {
		SwapChainSupportDetails swapChainSupport = QuerySwapChainSupport(physicalDevice);

		VkSurfaceFormatKHR surfaceFormat = ChooseSwapSurfaceFormat(swapChainSupport.formats);
		VkPresentModeKHR presentMode = ChooseSwapPresentMode(swapChainSupport.presentModes);
		VkExtent2D extent = ChooseSwapExtent(swapChainSupport.capabilities);

		uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 2;
		if ((swapChainSupport.capabilities.maxImageCount > 0) && (imageCount > swapChainSupport.capabilities.maxImageCount)) {
			imageCount = swapChainSupport.capabilities.maxImageCount;
		}

		VkSwapchainCreateInfoKHR createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
		createInfo.surface = surface;
		createInfo.minImageCount = imageCount;
		createInfo.imageFormat = surfaceFormat.format;
		createInfo.imageColorSpace = surfaceFormat.colorSpace;
		createInfo.imageExtent = extent;
		createInfo.imageArrayLayers = 1;
		createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

		QueueFamilyIndices indices = FindQueueFamilies(physicalDevice);
		uint32_t queueFamilyIndices[] = {indices.graphicsComputeFamily.value(), indices.presentFamily.value()};

		if (indices.graphicsComputeFamily != indices.presentFamily) {
			createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; // Slower
			createInfo.queueFamilyIndexCount = 2;
			createInfo.pQueueFamilyIndices = queueFamilyIndices;
		} else {
			createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; // Faster
			createInfo.queueFamilyIndexCount = 0; // Optional
			createInfo.pQueueFamilyIndices = nullptr; // Optional
		}

		createInfo.preTransform = swapChainSupport.capabilities.currentTransform; // No Transformation To Images
		createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; // Ignore Alpha Channels
		createInfo.presentMode = presentMode;
		createInfo.clipped = VK_FALSE; // We Need To Care About Pixels Which Are Not Visible So, VK_FALSE

		createInfo.oldSwapchain = VK_NULL_HANDLE; // TODO, We Need This To Be Enabled To Resize Window, Etc.

		if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Swap Chain!");
		}

		vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr);
		swapChainImages.resize(imageCount);
		vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data());

		swapChainImageFormat = surfaceFormat.format;
	}

	void CreateSwapChainImageViews() {
		VkImageViewCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
		createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
		createInfo.format = swapChainImageFormat;
		createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
		createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
		createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
		createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;

		swapChainImageViews.resize(swapChainImages.size());

		for (size_t i = 0; i < swapChainImages.size(); i++) {
			createInfo.image = swapChainImages[i];
			createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
			createInfo.subresourceRange.baseMipLevel = 0;
			createInfo.subresourceRange.levelCount = 1;
			createInfo.subresourceRange.baseArrayLayer = 0;
			createInfo.subresourceRange.layerCount = 1;

			if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Create Image Views!");
			}
		}
	}

	void CreateRenderPass() {
		std::vector<VkAttachmentDescription> colorAttachments{};
		VkAttachmentReference subpass1ColorAttachmentRefs{};
		VkAttachmentReference subpass2ColorAttachmentRef{};
		std::vector<VkSubpassDescription> subpass{};
		std::vector<VkSubpassDependency> dependency{};
		VkRenderPassCreateInfo createInfo{};

		if (OFFSCREENRENDER) {
			colorAttachments.resize(1);
			subpass.resize(1);
			dependency.resize(1);
		} else {
			colorAttachments.resize(2);
			subpass.resize(2);
			dependency.resize(2);
		}

		if (OFFSCREENRENDER) {
			colorAttachments[0].format = processorImageFormat;
			colorAttachments[0].samples = VK_SAMPLE_COUNT_1_BIT;
			colorAttachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
			colorAttachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
			colorAttachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
			colorAttachments[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
			colorAttachments[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
			colorAttachments[0].finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
		} else {
			colorAttachments[0].format = swapChainImageFormat;
			colorAttachments[0].samples = VK_SAMPLE_COUNT_1_BIT;
			colorAttachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
			colorAttachments[0].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
			colorAttachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
			colorAttachments[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
			colorAttachments[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
			colorAttachments[0].finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

			colorAttachments[1].format = swapChainImageFormat;
			colorAttachments[1].samples = VK_SAMPLE_COUNT_1_BIT;
			colorAttachments[1].loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
			colorAttachments[1].storeOp = VK_ATTACHMENT_STORE_OP_STORE;
			colorAttachments[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
			colorAttachments[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
			colorAttachments[1].initialLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
			colorAttachments[1].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
		}

		subpass1ColorAttachmentRefs.attachment = 0;
		subpass1ColorAttachmentRefs.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		subpass2ColorAttachmentRef.attachment = 1;
		subpass2ColorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

		subpass[0].pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
		subpass[0].colorAttachmentCount = 1;
		subpass[0].pColorAttachments = &subpass1ColorAttachmentRefs;

		if (!OFFSCREENRENDER) {
			subpass[1].pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
			subpass[1].colorAttachmentCount = 1;
			subpass[1].pColorAttachments = &subpass2ColorAttachmentRef;
		}

		dependency[0].srcSubpass = VK_SUBPASS_EXTERNAL;
		dependency[0].dstSubpass = 0;
		dependency[0].srcStageMask = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
		dependency[0].dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
		dependency[0].srcAccessMask = 0;
		dependency[0].dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
		dependency[0].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;

		if (!OFFSCREENRENDER) {
			dependency[1].srcSubpass = 0;
			dependency[1].dstSubpass = 1;
			dependency[1].srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
			dependency[1].dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
			dependency[1].srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
			dependency[1].dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
			dependency[1].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
		}

		createInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
		createInfo.attachmentCount = static_cast<uint32_t>(colorAttachments.size());
		createInfo.pAttachments = colorAttachments.data();
		createInfo.subpassCount = static_cast<uint32_t>(subpass.size());
		createInfo.pSubpasses = subpass.data();
		createInfo.dependencyCount = static_cast<uint32_t>(dependency.size());
		createInfo.pDependencies = dependency.data();

		if (vkCreateRenderPass(device, &createInfo, nullptr, &renderPass) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Render Pass!");
		}
	}

	void CreateDescriptorSetLayout() {
		std::array<VkDescriptorSetLayoutBinding, 2> layoutBinding{};
		VkDescriptorSetLayoutCreateInfo layoutInfo{};

		layoutBinding[0].binding = 0;
		layoutBinding[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		layoutBinding[0].descriptorCount = 1;
		layoutBinding[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
		layoutBinding[0].pImmutableSamplers = nullptr;

		layoutBinding[1].binding = 1;
		layoutBinding[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
		layoutBinding[1].descriptorCount = 1;
		layoutBinding[1].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
		layoutBinding[1].pImmutableSamplers = nullptr;

		layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
		layoutInfo.bindingCount = static_cast<uint32_t>(layoutBinding.size());
		layoutInfo.pBindings = layoutBinding.data();
		layoutInfo.flags = 0;

		if (vkCreateDescriptorSetLayout(device, &layoutInfo, nullptr, &descriptorSetLayout) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Descriptor Set Layout!");
		}
	}

	std::vector<uint32_t> GLSLToSPIRV(const std::string& code, const EShLanguage stage) {
		glslang::TShader shader(stage);

		const char* codes[] = {code.c_str()};
		const char* const* ptrCodes = codes;
		shader.setStrings(ptrCodes, 1);

		shader.setEnvInput(glslang::EShSourceGlsl, stage, glslang::EShClientVulkan, 100);
		shader.setEnvClient(glslang::EShClientVulkan, glslang::EShTargetVulkan_1_3);
		shader.setEnvTarget(glslang::EshTargetSpv, glslang::EShTargetSpv_1_6);

		shader.parse(GetDefaultResources(), 100, false, EShMsgDefault);

		std::string shaderLog;
		shaderLog.append(shader.getInfoLog());
		if (stage == EShLangFragment) {
			std::cout << "Parsing Fragment Shader: ";
		}
		if (stage == EShLangVertex) {
			std::cout << "Parsing Vertex Shader: ";
		}
		if (stage == EShLangCompute) {
			std::cout << "Parsing Compute Shader: ";
		}
		if (shaderLog.size() > 0) {
			std::cout << shaderLog << std::endl;
		} else {
			std::cout << "Success" << std::endl;
		}

		glslang::TProgram program;
		program.addShader(&shader);
		program.link(EShMsgDefault);

		std::string programLog;
		programLog.append(program.getInfoLog());
		if (stage == EShLangFragment) {
			std::cout << "Linking Fragment Program: ";
		}
		if (stage == EShLangVertex) {
			std::cout << "Linking Vertex Program: ";
		}
		if (stage == EShLangCompute) {
			std::cout << "Linking Compute Program: ";
		}
		if (programLog.size() > 0) {
			std::cout << programLog << std::endl;
		} else {
			std::cout << "Success" << std::endl;
		}

		glslang::TIntermediate* intermediate = program.getIntermediate(stage);

		std::vector<uint32_t> spirv;
		glslang::GlslangToSpv(*intermediate, spirv);

		return spirv;
	}

	VkShaderModule CreateShaderModule(const std::vector<uint32_t>& code) {
		VkShaderModuleCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
		createInfo.codeSize = code.size() * sizeof(uint32_t);
		createInfo.pCode = code.data();

		VkShaderModule shaderModule;
		if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Shader Module!");
		}

		return shaderModule;
	}

	VkPipelineShaderStageCreateInfo CreateShaderStageInfo(VkShaderModule module, VkShaderStageFlagBits stage, const char* pName) {
		shaderModules.push_back(module);

		VkPipelineShaderStageCreateInfo shaderStageInfo{};
		shaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
		shaderStageInfo.stage = stage;
		shaderStageInfo.module = module;
		shaderStageInfo.pName = pName;
		shaderStageInfo.pSpecializationInfo = nullptr; // For Specifying Different Constants Instead Of Doing It In Runtime

		return shaderStageInfo;
	}

	void CreateGraphicsPipeline() {
		vertexShaderCode = ReadFile("../src/shader.vert");
		if (isRunFromExecutables) {
		vertexShaderCode = ReadFile("./src/shader.vert");
		}
		fragmentShaderCode = ReadFile("../src/shader.frag");
		if (isRunFromExecutables) {
		fragmentShaderCode = ReadFile("./src/shader.frag");
		}

		std::array<VkPipelineShaderStageCreateInfo, 2> shaderStages;

		shaderStages[0] = CreateShaderStageInfo(CreateShaderModule(GLSLToSPIRV(vertexShaderCode, EShLangVertex)), VK_SHADER_STAGE_VERTEX_BIT, "main");
		shaderStages[1] = CreateShaderStageInfo(CreateShaderModule(GLSLToSPIRV(fragmentShaderCode, EShLangFragment)), VK_SHADER_STAGE_FRAGMENT_BIT, "main");

		VkVertexInputBindingDescription bindingDescription = Vertex::getBindingDescription();
		VkVertexInputAttributeDescription attributeDescription = Vertex::getAttributeDescription();
		VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
		vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
		vertexInputInfo.vertexBindingDescriptionCount = 1;
		vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
		vertexInputInfo.vertexAttributeDescriptionCount = 1;
		vertexInputInfo.pVertexAttributeDescriptions = &attributeDescription;

		VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
		inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
		inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
		inputAssembly.primitiveRestartEnable = VK_FALSE;

		VkPipelineViewportStateCreateInfo viewportState{};
		viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
		viewportState.viewportCount = 1;
		viewportState.scissorCount = 1;

		VkPipelineRasterizationStateCreateInfo rasterizer{};
		rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
		rasterizer.depthClampEnable = VK_FALSE;
		rasterizer.rasterizerDiscardEnable = VK_FALSE;
		rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
		rasterizer.lineWidth = 1.0f;
		rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
		rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
		rasterizer.depthBiasEnable = VK_FALSE;

		VkPipelineMultisampleStateCreateInfo multisampling{};
		multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
		multisampling.sampleShadingEnable = VK_FALSE;
		multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

		VkPipelineColorBlendAttachmentState colorBlendAttachment{};
		colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
		VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
		colorBlendAttachment.blendEnable = VK_FALSE;

		VkPipelineColorBlendStateCreateInfo colorBlending{};
		colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
		colorBlending.logicOpEnable = VK_FALSE;
		colorBlending.attachmentCount = 1;
		colorBlending.pAttachments = &colorBlendAttachment;

		std::vector<VkDynamicState> dynamicStates = {
			VK_DYNAMIC_STATE_VIEWPORT,
			VK_DYNAMIC_STATE_SCISSOR
		};
		VkPipelineDynamicStateCreateInfo dynamicState{};
		dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
		dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
		dynamicState.pDynamicStates = dynamicStates.data();

		VkPushConstantRange pushConstantRange{};
		pushConstantRange.offset = 0;
		pushConstantRange.size = sizeof(PushConstantValues);
		pushConstantRange.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;

		// Uniforms And Push Values
		VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
		pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
		pipelineLayoutInfo.setLayoutCount = 1;
		pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout;
		pipelineLayoutInfo.pushConstantRangeCount = 1;
		pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;

		if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &graphicsPipelineLayout) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Graphics Pipeline Layout!");
		}

		VkGraphicsPipelineCreateInfo pipelineInfo{};
		pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
		pipelineInfo.stageCount = static_cast<uint32_t>(shaderStages.size());
		pipelineInfo.pStages = shaderStages.data();
		pipelineInfo.pVertexInputState = &vertexInputInfo;
		pipelineInfo.pInputAssemblyState = &inputAssembly;
		pipelineInfo.pViewportState = &viewportState;
		pipelineInfo.pRasterizationState = &rasterizer;
		pipelineInfo.pMultisampleState = &multisampling;
		pipelineInfo.pDepthStencilState = nullptr;
		pipelineInfo.pColorBlendState = &colorBlending;
		pipelineInfo.pDynamicState = &dynamicState;
		pipelineInfo.renderPass = renderPass;
		pipelineInfo.subpass = 0;
		pipelineInfo.layout = graphicsPipelineLayout;

		if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Graphics Pipeline!");
		}
	}

	void InsertSDF() {
		for (int i = (sdfs.size() - 1); i >= 0; i--) {
			std::string sdf = sdfs[i].glsl;
			std::string SDFName = "SDF";
			std::string SDFFunction = "\n    if ((set";
			std::string SDFMATERIALFunction;
			std::string SDFPos;
			std::string SDFNum = std::to_string(i + 1);
			std::string SDFCode = std::to_string(int(pow(2, i % 32)));

			SDFName.append(SDFNum);
			sdf.replace(sdf.find("sdf"), 3, SDFName);
			SDFName.append("MATERIAL");
			sdf.replace(sdf.find("sdfmaterial"), 11, SDFName);
			sdf.append("\n");

			SDFPos.append("(p - vec3(sdfs[");
			SDFPos.append(std::to_string(6 * i));
			SDFPos.append("], sdfs[");
			SDFPos.append(std::to_string(6 * i + 1));
			SDFPos.append("], sdfs[");
			SDFPos.append(std::to_string(6 * i + 2));
			SDFPos.append("]))");

			SDFFunction.append(std::to_string(((i - (i % 32)) / 32) + 1));
			SDFFunction.append(" & ");
			SDFFunction.append(SDFCode);
			SDFFunction.append(") == ");
			SDFFunction.append(SDFCode);
			SDFFunction.append(") sdf");
			SDFMATERIALFunction = SDFFunction;
			SDFFunction.append(" = min(sdf, SDF");
			SDFFunction.append(SDFNum);
			SDFFunction.append(SDFPos);
			SDFFunction.append(");");

			SDFMATERIALFunction.append("material = minMaterial(sdf, SDF");
			SDFMATERIALFunction.append(SDFNum);
			SDFMATERIALFunction.append(SDFPos);
			SDFMATERIALFunction.append(", sdfmaterial, SDF");
			SDFMATERIALFunction.append(SDFNum);
			SDFMATERIALFunction.append("MATERIAL");
			SDFMATERIALFunction.append(SDFPos);
			SDFMATERIALFunction.append(");");

			computeShaderCode.insert(computeShaderCode.find("// Put SDF Functions Here") + 26, SDFFunction);
			computeShaderCode.insert(computeShaderCode.find("// Put SDFMATERIAL Functions Here") + 34, SDFFunction);
			computeShaderCode.insert(computeShaderCode.find("// Put SDFMATERIAL Functions Here") + 34, SDFMATERIALFunction);
			computeShaderCode.insert(computeShaderCode.find("// All SDF Are Inserted Here") + 31, sdf);
		}
	}

	void CreateComputePipeline() {
		computeShaderCode = ReadFile("../src/shader.comp");
		if (isRunFromExecutables) {
		computeShaderCode = ReadFile("./src/shader.comp");
		}

		InsertSDF();

		VkPipelineShaderStageCreateInfo computeShaderStage{};
		computeShaderStage = CreateShaderStageInfo(CreateShaderModule(GLSLToSPIRV(computeShaderCode, EShLangCompute)), VK_SHADER_STAGE_COMPUTE_BIT, "main");

		VkPushConstantRange pushConstantRange{};
		pushConstantRange.offset = 0;
		pushConstantRange.size = sizeof(PushConstantValues);
		pushConstantRange.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;

		// Uniforms And Push Values
		VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
		pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
		pipelineLayoutInfo.setLayoutCount = 1;
		pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout;
		pipelineLayoutInfo.pushConstantRangeCount = 1;
		pipelineLayoutInfo.pPushConstantRanges = &pushConstantRange;

		if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &computePipelineLayout) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Compute Pipeline Layout!");
		}

		VkComputePipelineCreateInfo pipelineInfo{};
		pipelineInfo.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
		pipelineInfo.layout = computePipelineLayout;
		pipelineInfo.stage = computeShaderStage;

		if (vkCreateComputePipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &computePipeline) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Compute Pipeline!");
		}
	}

	void CreateCommandPool() {
		QueueFamilyIndices queueFamilyIndices = FindQueueFamilies(physicalDevice);

		VkCommandPoolCreateInfo poolInfo{};
		poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
		poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
		poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsComputeFamily.value();

		if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Command Pool!");
		}
	}

	uint32_t FindMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
		VkPhysicalDeviceMemoryProperties memoryProperties;
		vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memoryProperties);

		for (uint32_t i = 0; i < memoryProperties.memoryTypeCount; i++) {
			if ((typeFilter & (1 << i)) && ((memoryProperties.memoryTypes[i].propertyFlags & properties) == properties)) {
				return i;
			}
		}

		throw std::runtime_error("Failed To Find Suitable Memory Type!");
	}

	void CreateBuffer(VkDeviceSize size, VkBufferUsageFlags usage,
	VkMemoryPropertyFlags properties, VkBuffer& buffer, VkDeviceMemory& bufferMemory) {
		VkBufferCreateInfo bufferInfo{};
		bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
		bufferInfo.size = size;
		bufferInfo.usage = usage;
		bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

		if (vkCreateBuffer(device, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Buffer!");
		}

		VkMemoryRequirements memoryRequirements;
		vkGetBufferMemoryRequirements(device, buffer, &memoryRequirements);

		VkMemoryAllocateInfo allocateInfo{};
		allocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
		allocateInfo.allocationSize = memoryRequirements.size;
		allocateInfo.memoryTypeIndex = FindMemoryType(memoryRequirements.memoryTypeBits, properties);

		if (vkAllocateMemory(device, &allocateInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Allocate Buffer Memory!");
		}

		vkBindBufferMemory(device, buffer, bufferMemory, 0);
	}

	void CopyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
		VkCommandBufferAllocateInfo allocateInfo{};
		allocateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
		allocateInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocateInfo.commandPool = commandPool;
		allocateInfo.commandBufferCount = 1;

		VkCommandBuffer commandBuffer;
		vkAllocateCommandBuffers(device, &allocateInfo, &commandBuffer);

		VkCommandBufferBeginInfo beginInfo{};
		beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
		beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

		vkBeginCommandBuffer(commandBuffer, &beginInfo);

		VkBufferCopy copyRegion{};
		copyRegion.srcOffset = 0;
		copyRegion.dstOffset = 0;
		copyRegion.size = size;
		vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

		vkEndCommandBuffer(commandBuffer);

		VkSubmitInfo submitInfo{};
		submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		submitInfo.commandBufferCount = 1;
		submitInfo.pCommandBuffers = &commandBuffer;

		vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE);
		vkQueueWaitIdle(graphicsQueue);

		vkFreeCommandBuffers(device, commandPool, 1, &commandBuffer);
	}

	void CreateVertexBuffer() {
		VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();

		VkBuffer stagingBuffer;
		VkDeviceMemory stagingBufferMemory;
		CreateBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
		stagingBuffer, stagingBufferMemory);

		void* data;
		vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
		memcpy(data, vertices.data(), (size_t)bufferSize);
		vkUnmapMemory(device, stagingBufferMemory);

		CreateBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT |
		VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
		vertexBuffer, vertexBufferMemory);

		CopyBuffer(stagingBuffer, vertexBuffer, bufferSize);

		vkDestroyBuffer(device, stagingBuffer, nullptr);
		vkFreeMemory(device, stagingBufferMemory, nullptr);
	}

	void CreateIndexBuffer() {
		VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

		VkBuffer stagingBuffer;
		VkDeviceMemory stagingBufferMemory;
		CreateBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
		stagingBuffer, stagingBufferMemory);

		void* data;
		vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
		memcpy(data, indices.data(), (size_t)bufferSize);
		vkUnmapMemory(device, stagingBufferMemory);

		CreateBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT |
		VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
		indexBuffer, indexBufferMemory);

		CopyBuffer(stagingBuffer, indexBuffer, bufferSize);

		vkDestroyBuffer(device, stagingBuffer, nullptr);
		vkFreeMemory(device, stagingBufferMemory, nullptr);
	}

	void CreateUniformBuffer() {
		for (int i = 0; i < std::size(CIELMS2006); i++) {
			ubo.CIELMS2006[i] = CIELMS2006[i];
		}

		VkDeviceSize bufferSize = sizeof(UniformBufferObject);

		uniformBuffers.resize(MAX_FRAMES_IN_FLIGHT);
		uniformBuffersMemory.resize(MAX_FRAMES_IN_FLIGHT);
		uniformBuffersMapped.resize(MAX_FRAMES_IN_FLIGHT);

		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			CreateBuffer(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
			VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
			uniformBuffers[i], uniformBuffersMemory[i]);

			vkMapMemory(device, uniformBuffersMemory[i], 0, bufferSize, 0, &uniformBuffersMapped[i]);
		}
	}

	void CreateTexelBuffer() {
		VkDeviceSize bufferSize = W * H * 4 * 4;

		CreateBuffer(bufferSize, VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
		VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, texelBuffer, texelBufferMemory);
	}

	void CreateTexelBufferView() {
		VkBufferViewCreateInfo createInfo{};
		createInfo.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
		createInfo.flags = 0;
		createInfo.buffer = texelBuffer;
		createInfo.format = texelBufferFormat;
		createInfo.offset = 0;
		createInfo.range = VK_WHOLE_SIZE;

		if (vkCreateBufferView(device, &createInfo, nullptr, &texelBufferView) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Texel Buffer View!");
		}
	}

	void CreateImages() {
		if (OFFSCREENRENDER) {
			std::array<VkImageCreateInfo, 2> createInfo{};
			std::array<VkMemoryRequirements, 2> memoryRequirements;
			std::array<VkMemoryAllocateInfo, 2> allocateInfo{};

			createInfo[0].sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
			createInfo[0].imageType = VK_IMAGE_TYPE_2D;
			createInfo[0].extent.width = static_cast<uint32_t>(W);
			createInfo[0].extent.height = static_cast<uint32_t>(H);
			createInfo[0].extent.depth = 1;
			createInfo[0].mipLevels = 1;
			createInfo[0].arrayLayers = 1;
			createInfo[0].format = processorImageFormat;
			createInfo[0].tiling = VK_IMAGE_TILING_OPTIMAL;
			createInfo[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
			createInfo[0].usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
			createInfo[0].sharingMode = VK_SHARING_MODE_EXCLUSIVE;
			createInfo[0].samples = VK_SAMPLE_COUNT_1_BIT;
			createInfo[0].flags = 0;

			if (vkCreateImage(device, &createInfo[0], nullptr, &processorImage) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Create Processor Image!");
			}

			vkGetImageMemoryRequirements(device, processorImage, &memoryRequirements[0]);

			allocateInfo[0].sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
			allocateInfo[0].allocationSize = memoryRequirements[0].size;
			allocateInfo[0].memoryTypeIndex = FindMemoryType(memoryRequirements[0].memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

			if (vkAllocateMemory(device, &allocateInfo[0], nullptr, &processorImageMemory) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Allocate Processor Image Memory!");
			}

			vkBindImageMemory(device, processorImage, processorImageMemory, 0);

			createInfo[1].sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
			createInfo[1].imageType = VK_IMAGE_TYPE_2D;
			createInfo[1].extent.width = static_cast<uint32_t>(W);
			createInfo[1].extent.height = static_cast<uint32_t>(H);
			createInfo[1].extent.depth = 1;
			createInfo[1].mipLevels = 1;
			createInfo[1].arrayLayers = 1;
			createInfo[1].format = saveImageFormat;
			createInfo[1].tiling = VK_IMAGE_TILING_LINEAR;
			createInfo[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
			createInfo[1].usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;
			createInfo[1].sharingMode = VK_SHARING_MODE_EXCLUSIVE;
			createInfo[1].samples = VK_SAMPLE_COUNT_1_BIT;
			createInfo[1].flags = 0;

			if (vkCreateImage(device, &createInfo[1], nullptr, &saveImage) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Create Save Image!");
			}

			vkGetImageMemoryRequirements(device, saveImage, &memoryRequirements[1]);

			allocateInfo[1].sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
			allocateInfo[1].allocationSize = memoryRequirements[1].size;
			allocateInfo[1].memoryTypeIndex = FindMemoryType(memoryRequirements[1].memoryTypeBits,
			VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);

			if (vkAllocateMemory(device, &allocateInfo[1], nullptr, &saveImageMemory) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Allocate Save Image Memory!");
			}

			vkBindImageMemory(device, saveImage, saveImageMemory, 0);
		}
	}

	void CreateImageViews() {
		VkImageViewCreateInfo createInfo{};

		if (OFFSCREENRENDER) {
			createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
			createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
			createInfo.format = processorImageFormat;
			createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
			createInfo.image = processorImage;
			createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
			createInfo.subresourceRange.baseMipLevel = 0;
			createInfo.subresourceRange.levelCount = 1;
			createInfo.subresourceRange.baseArrayLayer = 0;
			createInfo.subresourceRange.layerCount = 1;

			if (vkCreateImageView(device, &createInfo, nullptr, &processorImageView) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Create Processor Image View!");
			}
		}
	}

	void CreateFramebuffers() {
		if (OFFSCREENRENDER) {
			framebuffers.resize(1);
		} else {
			framebuffers.resize(swapChainImageViews.size());
		}

		for (size_t i = 0; i < framebuffers.size(); i++) {
			std::vector<VkImageView> attachments;
			if (OFFSCREENRENDER) {
				attachments.push_back(processorImageView);
			} else {
				attachments.push_back(swapChainImageViews[i]);
				attachments.push_back(swapChainImageViews[i]);
			}

			VkFramebufferCreateInfo createInfo{};
			createInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
			createInfo.renderPass = renderPass;
			createInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
			createInfo.pAttachments = attachments.data();
			createInfo.width = static_cast<uint32_t>(W);
			createInfo.height = static_cast<uint32_t>(H);
			createInfo.layers = 1;

			if (vkCreateFramebuffer(device, &createInfo, nullptr, &framebuffers[i]) != VK_SUCCESS) {
				std::runtime_error("Failed To Create Framebuffers!");
			}
		}
	}

	void CreateDescriptorPool() {
		std::array<VkDescriptorPoolSize, 2> poolSize{};
		VkDescriptorPoolCreateInfo poolInfo{};

		poolSize[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
		poolSize[0].descriptorCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);

		poolSize[1].type = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
		poolSize[1].descriptorCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);

		poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
		poolInfo.poolSizeCount = static_cast<uint32_t>(poolSize.size());
		poolInfo.pPoolSizes = poolSize.data();
		poolInfo.maxSets = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);

		if (vkCreateDescriptorPool(device, &poolInfo, nullptr, &descriptorPool) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create Descriptor Pool!");
		}
	}

	void UpdateDescriptorSet() {
		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			std::array<VkWriteDescriptorSet, 2> descriptorWrite{};

			VkDescriptorBufferInfo bufferInfo{};
			bufferInfo.buffer = uniformBuffers[i];
			bufferInfo.offset = 0;
			bufferInfo.range = sizeof(UniformBufferObject);

			descriptorWrite[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
			descriptorWrite[0].dstSet = descriptorSets[i];
			descriptorWrite[0].dstBinding = 0;
			descriptorWrite[0].dstArrayElement = 0;
			descriptorWrite[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
			descriptorWrite[0].descriptorCount = 1;
			descriptorWrite[0].pBufferInfo = &bufferInfo;
			descriptorWrite[0].pImageInfo = nullptr;
			descriptorWrite[0].pTexelBufferView = nullptr;

			VkDescriptorBufferInfo texelBufferInfo{};
			texelBufferInfo.buffer = texelBuffer;
			texelBufferInfo.offset = 0;
			texelBufferInfo.range = W * H * 4 * 4;

			descriptorWrite[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
			descriptorWrite[1].dstSet = descriptorSets[i];
			descriptorWrite[1].dstBinding = 1;
			descriptorWrite[1].dstArrayElement = 0;
			descriptorWrite[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
			descriptorWrite[1].descriptorCount = 1;
			descriptorWrite[1].pBufferInfo = &texelBufferInfo;
			descriptorWrite[1].pImageInfo = nullptr;
			descriptorWrite[1].pTexelBufferView = &texelBufferView;

			vkUpdateDescriptorSets(device, static_cast<uint32_t>(descriptorWrite.size()), descriptorWrite.data(), 0, nullptr);
		}
	}

	void CreateDescriptorSet() {
		VkDescriptorSetAllocateInfo allocateInfo{};
		allocateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
		allocateInfo.descriptorPool = descriptorPool;
		allocateInfo.descriptorSetCount = static_cast<uint32_t>(MAX_FRAMES_IN_FLIGHT);
		std::vector<VkDescriptorSetLayout> layouts(MAX_FRAMES_IN_FLIGHT, descriptorSetLayout);
		allocateInfo.pSetLayouts = layouts.data();

		descriptorSets.resize(MAX_FRAMES_IN_FLIGHT);
		if (vkAllocateDescriptorSets(device, &allocateInfo, descriptorSets.data()) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Allocate Descriptor Sets!");
		}

		UpdateDescriptorSet();
	}

	void CreateCommandBuffer() {
		graphicsCommandBuffers.resize(MAX_FRAMES_IN_FLIGHT);
		computeCommandBuffers.resize(MAX_FRAMES_IN_FLIGHT);

		std::array<VkCommandBufferAllocateInfo, 2> allocateInfo{};

		allocateInfo[0].sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
		allocateInfo[0].commandPool = commandPool;
		allocateInfo[0].level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocateInfo[0].commandBufferCount = static_cast<uint32_t>(graphicsCommandBuffers.size());

		allocateInfo[1].sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
		allocateInfo[1].commandPool = commandPool;
		allocateInfo[1].level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
		allocateInfo[1].commandBufferCount = static_cast<uint32_t>(computeCommandBuffers.size());

		if (vkAllocateCommandBuffers(device, &allocateInfo[0], graphicsCommandBuffers.data()) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Allocate Graphics Command Buffers!");
		}

		if (vkAllocateCommandBuffers(device, &allocateInfo[1], computeCommandBuffers.data()) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Allocate Compute Command Buffers!");
		}
	}

	void CreateSyncObjects() {
		imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
		renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
		inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

		computeFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
		computeInFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

		VkSemaphoreCreateInfo semaphoreInfo{};
		semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

		VkFenceCreateInfo fenceInfo{};
		fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
		fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			if ((vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphores[i]) != VK_SUCCESS) ||
			(vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphores[i]) != VK_SUCCESS) ||
			(vkCreateFence(device, &fenceInfo, nullptr, &inFlightFences[i]) != VK_SUCCESS)) {
				throw std::runtime_error("Failed To Create Graphics Sync Objects For A Frame!");
			}

			if ((vkCreateSemaphore(device, &semaphoreInfo, nullptr, &computeFinishedSemaphores[i]) != VK_SUCCESS) ||
			(vkCreateFence(device, &fenceInfo, nullptr, &computeInFlightFences[i]) != VK_SUCCESS)) {
				throw std::runtime_error("Failed To Create Compute Sync Objects For A Frame!");
			}
		}
	}

    void InitVulkan() {
        CreateInstance();
		SetupDebugMessenger();
		CreateSurface();
		PickPhysicalDevice();
		CreateLogicalDevice();
		if (!OFFSCREENRENDER) {
			CreateSwapChain();
			CreateSwapChainImageViews();
		}
		CreateRenderPass();
		CreateDescriptorSetLayout();
		CreateGraphicsPipeline();
		CreateComputePipeline();
		CreateCommandPool();
		CreateVertexBuffer();
		CreateIndexBuffer();
		CreateUniformBuffer();
		CreateTexelBuffer();
		CreateTexelBufferView();
		CreateImages();
		CreateImageViews();
		CreateFramebuffers();
		CreateDescriptorPool();
		CreateDescriptorSet();
		CreateCommandBuffer();
		CreateSyncObjects();
    }

	void DarkStyle() {
		ImGuiStyle* style = &ImGui::GetStyle();

		style->Colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
		style->Colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
		style->Colors[ImGuiCol_WindowBg]               = ImVec4(0.04f, 0.04f, 0.04f, 0.94f);
		style->Colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
		style->Colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
		style->Colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
		style->Colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
		style->Colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
		style->Colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
		style->Colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
		style->Colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
		style->Colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
		style->Colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
		style->Colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
		style->Colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
		style->Colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
		style->Colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
		style->Colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
		style->Colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
		style->Colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
		style->Colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
		style->Colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
		style->Colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_Separator]              = style->Colors[ImGuiCol_Border];
		style->Colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
		style->Colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
		style->Colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
		style->Colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
		style->Colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
		style->Colors[ImGuiCol_Tab]                    = ImLerp(style->Colors[ImGuiCol_Header],       style->Colors[ImGuiCol_TitleBgActive], 0.80f);
		style->Colors[ImGuiCol_TabHovered]             = style->Colors[ImGuiCol_HeaderHovered];
		style->Colors[ImGuiCol_TabActive]              = ImLerp(style->Colors[ImGuiCol_HeaderActive], style->Colors[ImGuiCol_TitleBgActive], 0.60f);
		style->Colors[ImGuiCol_TabUnfocused]           = ImLerp(style->Colors[ImGuiCol_Tab],          style->Colors[ImGuiCol_TitleBg], 0.80f);
		style->Colors[ImGuiCol_TabUnfocusedActive]     = ImLerp(style->Colors[ImGuiCol_TabActive],    style->Colors[ImGuiCol_TitleBg], 0.40f);
		style->Colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
		style->Colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
		style->Colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
		style->Colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
		style->Colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
		style->Colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
		style->Colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
		style->Colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
		style->Colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
		style->Colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
		style->Colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
		style->Colors[ImGuiCol_NavHighlight]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
		style->Colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
		style->Colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
		style->Colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
	}

	void InitImGui() {
		VkDescriptorPoolSize poolSize[] =
		{
			{ VK_DESCRIPTOR_TYPE_SAMPLER, 1000 },
			{ VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000 },
			{ VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1000 },
			{ VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1000 },
			{ VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, 1000 },
			{ VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, 1000 },
			{ VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000 },
			{ VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1000 },
			{ VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 1000 },
			{ VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, 1000 },
			{ VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, 1000 }
		};

		VkDescriptorPoolCreateInfo poolInfo{};
		poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
		poolInfo.poolSizeCount = std::size(poolSize);
		poolInfo.pPoolSizes = poolSize;
		poolInfo.maxSets = 1000;
		poolInfo.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;

		if(vkCreateDescriptorPool(device, &poolInfo, nullptr, &imguiDescriptorPool) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Create ImGui Descriptor Pool!");
		}

		IMGUI_CHECKVERSION();

		ImGui::CreateContext();

		io = &ImGui::GetIO(); (void)io;
		io->ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

		DarkStyle();

		ImGui_ImplGlfw_InitForVulkan(window, true);

		ImGui_ImplVulkan_InitInfo initInfo{};
		initInfo.Instance = instance;
		initInfo.PhysicalDevice = physicalDevice;
		initInfo.Device = device;
		initInfo.Queue = graphicsQueue;
		initInfo.QueueFamily = FindQueueFamilies(physicalDevice).graphicsComputeFamily.value();
		initInfo.DescriptorPool = imguiDescriptorPool;
		initInfo.MinImageCount = static_cast<uint32_t>(swapChainImageViews.size());
		initInfo.ImageCount = static_cast<uint32_t>(swapChainImageViews.size());
		initInfo.MSAASamples = VK_SAMPLE_COUNT_1_BIT;
		initInfo.RenderPass = renderPass;
		initInfo.Subpass = 1;
		initInfo.UseDynamicRendering = false;

		ImGui_ImplVulkan_Init(&initInfo);

		ImGui_ImplVulkan_CreateFontsTexture();
	}

	void DefaultScene() {
		scene = nlohmann::ordered_json::parse(ReadFile("../scenes/scene0.json"));
	}

	void UpdateFromJSON() {
		camera.pos.x = scene["camera"]["position"][0];
		camera.pos.y = scene["camera"]["position"][1];
		camera.pos.z = scene["camera"]["position"][2];

		camera.angle.x = scene["camera"]["angle"][0];
		camera.angle.y = scene["camera"]["angle"][1];

		camera.ISO = scene["camera"]["ISO"];

		camera.size = scene["camera"]["size"];

		camera.apertureSize = scene["camera"]["apertureSize"];

		camera.apertureDist = scene["camera"]["apertureDistance"];

		camera.lensRadius = scene["camera"]["lensRadius"];

		camera.lensFocalLength = scene["camera"]["lensFocalLength"];

		camera.lensThickness = scene["camera"]["lensThickness"];

		camera.lensDistance = scene["camera"]["lensDistance"];

		spheres.resize(scene["sphere"].size());
		for (size_t i = 0; i < spheres.size(); i++) {
			spheres[i].pos[0] = scene["sphere"][i]["position"][0];
			spheres[i].pos[1] = scene["sphere"][i]["position"][1];
			spheres[i].pos[2] = scene["sphere"][i]["position"][2];

			spheres[i].radius = scene["sphere"][i]["radius"];

			spheres[i].materialID = scene["sphere"][i]["materialID"];
		}

		planes.resize(scene["plane"].size());
		for (size_t i = 0; i < planes.size(); i++) {
			planes[i].pos[0] = scene["plane"][i]["position"][0];
			planes[i].pos[1] = scene["plane"][i]["position"][1];
			planes[i].pos[2] = scene["plane"][i]["position"][2];

			planes[i].materialID = scene["plane"][i]["materialID"];
		}

		boxes.resize(scene["box"].size());
		for (size_t i = 0; i < boxes.size(); i++) {
			boxes[i].pos[0] = scene["box"][i]["position"][0];
			boxes[i].pos[1] = scene["box"][i]["position"][1];
			boxes[i].pos[2] = scene["box"][i]["position"][2];

			boxes[i].rotation[0] = scene["box"][i]["rotation"][0];
			boxes[i].rotation[1] = scene["box"][i]["rotation"][1];
			boxes[i].rotation[2] = scene["box"][i]["rotation"][2];

			boxes[i].size[0] = scene["box"][i]["size"][0];
			boxes[i].size[1] = scene["box"][i]["size"][1];
			boxes[i].size[2] = scene["box"][i]["size"][2];

			boxes[i].materialID = scene["box"][i]["materialID"];
		}

		lenses.resize(scene["lens"].size());
		for (size_t i = 0; i < lenses.size(); i++) {
			lenses[i].pos[0] = scene["lens"][i]["position"][0];
			lenses[i].pos[1] = scene["lens"][i]["position"][1];
			lenses[i].pos[2] = scene["lens"][i]["position"][2];

			lenses[i].rotation[0] = scene["lens"][i]["rotation"][0];
			lenses[i].rotation[1] = scene["lens"][i]["rotation"][1];
			lenses[i].rotation[2] = scene["lens"][i]["rotation"][2];

			lenses[i].radius = scene["lens"][i]["radius"];

			lenses[i].focalLength = scene["lens"][i]["focalLength"];

			lenses[i].thickness = scene["lens"][i]["thickness"];

			lenses[i].isConverging = scene["lens"][i]["isConverging"];

			lenses[i].materialID = scene["lens"][i]["materialID"];
		}

		cyclides.resize(scene["cyclide"].size());
		for (size_t i = 0; i < cyclides.size(); i++) {
			cyclides[i].pos[0] = scene["cyclide"][i]["position"][0];
			cyclides[i].pos[1] = scene["cyclide"][i]["position"][1];
			cyclides[i].pos[2] = scene["cyclide"][i]["position"][2];

			cyclides[i].rotation[0] = scene["cyclide"][i]["rotation"][0];
			cyclides[i].rotation[1] = scene["cyclide"][i]["rotation"][1];
			cyclides[i].rotation[2] = scene["cyclide"][i]["rotation"][2];

			cyclides[i].scale[0] = scene["cyclide"][i]["scale"][0];
			cyclides[i].scale[1] = scene["cyclide"][i]["scale"][1];
			cyclides[i].scale[2] = scene["cyclide"][i]["scale"][2];

			cyclides[i].a = scene["cyclide"][i]["a"];
			cyclides[i].b = scene["cyclide"][i]["b"];
			cyclides[i].c = scene["cyclide"][i]["c"];
			cyclides[i].d = scene["cyclide"][i]["d"];

			cyclides[i].brad = scene["cyclide"][i]["boundingRadius"];

			cyclides[i].materialID = scene["cyclide"][i]["materialID"];
		}

		sdfs.resize(scene["sdf"].size());
		for (size_t i = 0; i < sdfs.size(); i++) {
			sdfs[i].pos[0] = scene["sdf"][i]["position"][0];
			sdfs[i].pos[1] = scene["sdf"][i]["position"][1];
			sdfs[i].pos[2] = scene["sdf"][i]["position"][2];

			sdfs[i].size[0] = scene["sdf"][i]["boundingSize"][0];
			sdfs[i].size[1] = scene["sdf"][i]["boundingSize"][1];
			sdfs[i].size[2] = scene["sdf"][i]["boundingSize"][2];

			sdfs[i].glsl = scene["sdf"][i]["glsl"];
		}

		materials.resize(scene["material"].size());
		for (size_t i = 0; i < materials.size(); i++) {
			materials[i].reflection[0] = scene["material"][i]["reflection"]["peakWavelength"];
			materials[i].reflection[1] = scene["material"][i]["reflection"]["sigma"];
			materials[i].reflection[2] = (float)scene["material"][i]["reflection"]["isInvert"];

			materials[i].emission[0] = scene["material"][i]["emission"]["temperature"];
			materials[i].emission[1] = scene["material"][i]["emission"]["luminosity"];
		}
	}

	void UpdateToJSON() {
		scene = nlohmann::ordered_json();

		scene["camera"]["position"][0] = RoundDecimal((double)camera.pos.x, 1e5);
		scene["camera"]["position"][1] = RoundDecimal((double)camera.pos.y, 1e5);
		scene["camera"]["position"][2] = RoundDecimal((double)camera.pos.z, 1e5);

		scene["camera"]["angle"][0] = RoundDecimal((double)camera.angle.x, 1e5);
		scene["camera"]["angle"][1] = RoundDecimal((double)camera.angle.y, 1e5);

		scene["camera"]["ISO"] = camera.ISO;

		scene["camera"]["size"] = RoundDecimal((double)camera.size, 1e5);

		scene["camera"]["apertureSize"] = RoundDecimal((double)camera.apertureSize, 1e5);

		scene["camera"]["apertureDistance"] = RoundDecimal((double)camera.apertureDist, 1e5);

		scene["camera"]["lensRadius"] = RoundDecimal((double)camera.lensRadius, 1e5);

		scene["camera"]["lensFocalLength"] = RoundDecimal((double)camera.lensFocalLength, 1e5);

		scene["camera"]["lensThickness"] = RoundDecimal((double)camera.lensThickness, 1e5);

		scene["camera"]["lensDistance"] = RoundDecimal((double)camera.lensDistance, 1e5);

		for (size_t i = 0; i < spheres.size(); i++) {
			scene["sphere"][i]["position"][0] = RoundDecimal((double)spheres[i].pos[0], 1e5);
			scene["sphere"][i]["position"][1] = RoundDecimal((double)spheres[i].pos[1], 1e5);
			scene["sphere"][i]["position"][2] = RoundDecimal((double)spheres[i].pos[2], 1e5);;

			scene["sphere"][i]["radius"] = RoundDecimal((double)spheres[i].radius, 1e5);

			scene["sphere"][i]["materialID"] = spheres[i].materialID;
		}

		for (size_t i = 0; i < planes.size(); i++) {
			scene["plane"][i]["position"][0] = RoundDecimal((double)planes[i].pos[0], 1e5);
			scene["plane"][i]["position"][1] = RoundDecimal((double)planes[i].pos[1], 1e5);
			scene["plane"][i]["position"][2] = RoundDecimal((double)planes[i].pos[2], 1e5);

			scene["plane"][i]["materialID"] = planes[i].materialID;
		}

		for (size_t i = 0; i < boxes.size(); i++) {
			scene["box"][i]["position"][0] = RoundDecimal((double)boxes[i].pos[0], 1e5);
			scene["box"][i]["position"][1] = RoundDecimal((double)boxes[i].pos[1], 1e5);
			scene["box"][i]["position"][2] = RoundDecimal((double)boxes[i].pos[2], 1e5);

			scene["box"][i]["rotation"][0] = RoundDecimal((double)boxes[i].rotation[0], 1e5);
			scene["box"][i]["rotation"][1] = RoundDecimal((double)boxes[i].rotation[1], 1e5);
			scene["box"][i]["rotation"][2] = RoundDecimal((double)boxes[i].rotation[2], 1e5);

			scene["box"][i]["size"][0] = RoundDecimal((double)boxes[i].size[0], 1e5);
			scene["box"][i]["size"][1] = RoundDecimal((double)boxes[i].size[1], 1e5);
			scene["box"][i]["size"][2] = RoundDecimal((double)boxes[i].size[2], 1e5);

			scene["box"][i]["materialID"] = boxes[i].materialID;
		}

		for (size_t i = 0; i < lenses.size(); i++) {
			scene["lens"][i]["position"][0] = RoundDecimal((double)lenses[i].pos[0], 1e5);
			scene["lens"][i]["position"][1] = RoundDecimal((double)lenses[i].pos[1], 1e5);
			scene["lens"][i]["position"][2] = RoundDecimal((double)lenses[i].pos[2], 1e5);

			scene["lens"][i]["rotation"][0] = RoundDecimal((double)lenses[i].rotation[0], 1e5);
			scene["lens"][i]["rotation"][1] = RoundDecimal((double)lenses[i].rotation[1], 1e5);
			scene["lens"][i]["rotation"][2] = RoundDecimal((double)lenses[i].rotation[2], 1e5);

			scene["lens"][i]["radius"] = RoundDecimal((double)lenses[i].radius, 1e5);

			scene["lens"][i]["focalLength"] = RoundDecimal((double)lenses[i].focalLength, 1e5);

			scene["lens"][i]["thickness"] = RoundDecimal((double)lenses[i].thickness, 1e5);

			scene["lens"][i]["isConverging"] = lenses[i].isConverging;

			scene["lens"][i]["materialID"] = lenses[i].materialID;
		}

		for (size_t i = 0; i < cyclides.size(); i++) {
			scene["cyclide"][i]["position"][0] = RoundDecimal((double)cyclides[i].pos[0], 1e5);
			scene["cyclide"][i]["position"][1] = RoundDecimal((double)cyclides[i].pos[1], 1e5);
			scene["cyclide"][i]["position"][2] = RoundDecimal((double)cyclides[i].pos[2], 1e5);

			scene["cyclide"][i]["rotation"][0] = RoundDecimal((double)cyclides[i].rotation[0], 1e5);
			scene["cyclide"][i]["rotation"][1] = RoundDecimal((double)cyclides[i].rotation[1], 1e5);
			scene["cyclide"][i]["rotation"][2] = RoundDecimal((double)cyclides[i].rotation[2], 1e5);

			scene["cyclide"][i]["scale"][0] = RoundDecimal((double)cyclides[i].scale[0], 1e5);
			scene["cyclide"][i]["scale"][1] = RoundDecimal((double)cyclides[i].scale[1], 1e5);
			scene["cyclide"][i]["scale"][2] = RoundDecimal((double)cyclides[i].scale[2], 1e5);

			scene["cyclide"][i]["a"] = RoundDecimal((double)cyclides[i].a, 1e5);
			scene["cyclide"][i]["b"] = RoundDecimal((double)cyclides[i].b, 1e5);
			scene["cyclide"][i]["c"] = RoundDecimal((double)cyclides[i].c, 1e5);
			scene["cyclide"][i]["d"] = RoundDecimal((double)cyclides[i].d, 1e5);

			scene["cyclide"][i]["boundingRadius"] = RoundDecimal((double)cyclides[i].brad, 1e5);

			scene["cyclide"][i]["materialID"] = cyclides[i].materialID;
		}

		for (size_t i = 0; i < sdfs.size(); i++) {
			scene["sdf"][i]["position"][0] = RoundDecimal((double)sdfs[i].pos[0], 1e5);
			scene["sdf"][i]["position"][1] = RoundDecimal((double)sdfs[i].pos[1], 1e5);
			scene["sdf"][i]["position"][2] = RoundDecimal((double)sdfs[i].pos[2], 1e5);

			scene["sdf"][i]["boundingSize"][0] = RoundDecimal((double)sdfs[i].size[0], 1e5);
			scene["sdf"][i]["boundingSize"][1] = RoundDecimal((double)sdfs[i].size[1], 1e5);
			scene["sdf"][i]["boundingSize"][2] = RoundDecimal((double)sdfs[i].size[2], 1e5);

			scene["sdf"][i]["glsl"] = sdfs[i].glsl;
		}

		for (size_t i = 0; i < materials.size(); i++) {
			scene["material"][i]["reflection"]["peakWavelength"] = RoundDecimal((double)materials[i].reflection[0], 1e5);
			scene["material"][i]["reflection"]["sigma"] = RoundDecimal((double)materials[i].reflection[1], 1e5);
			scene["material"][i]["reflection"]["isInvert"] = (bool)materials[i].reflection[2];

			scene["material"][i]["emission"]["temperature"] = RoundDecimal((double)materials[i].emission[0], 1e5);
			scene["material"][i]["emission"]["luminosity"] = RoundDecimal((double)materials[i].emission[1], 1e5);
		}
	}

	void HandleEvents(glm::vec2& cursorPos, glm::vec2& cameraAngle, glm::vec3& deltaCamPos) {
		glfwPollEvents();

		if (!isCameraLocked) {
			glm::vec2 cursorPos1 = glm::vec2((float)(ImGui::GetMousePos().x) / (float)W, (float)(H - ImGui::GetMousePos().y) / (float)H);

			if (!isImGuiWindowFocused) {
				if (ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
					isReset = true;
					glm::vec2 dxdy = cursorPos1 - cursorPos;
					cameraAngle = cameraAngle - (360.0f * dxdy);
					if (cameraAngle.x > 360.0f) {
						cameraAngle.x = cameraAngle.x - 360.0f;
					}
					if (cameraAngle.x < 0.0f) {
						cameraAngle.x = 360.0f + cameraAngle.x;
					}
					if (cameraAngle.y > 90.0f) {
						cameraAngle.y = 90.0f;
					}
					if (cameraAngle.y < -90.0f) {
						cameraAngle.y = -90.0f;
					}
				}
			}

			cursorPos = cursorPos1;

			deltaCamPos.x = ((float)(ImGui::IsKeyDown(ImGuiKey_D)) - (float)(ImGui::IsKeyDown(ImGuiKey_A)));
			deltaCamPos.y = ((float)(ImGui::IsKeyDown(ImGuiKey_E)) - (float)(ImGui::IsKeyDown(ImGuiKey_Q)));
			deltaCamPos.z = ((float)(ImGui::IsKeyDown(ImGuiKey_W)) - (float)(ImGui::IsKeyDown(ImGuiKey_S)));

			if ((deltaCamPos.x != 0.0f) || (deltaCamPos.y != 0.0f) || (deltaCamPos.z != 0.0f)) {
				isReset = true;
			}
		}
    }

	void UpdateCameraPos(glm::vec3& cameraPos, glm::vec2 cameraAngle, glm::vec3 deltaCamPos) {
		// http://www.songho.ca/opengl/gl_anglestoaxes.html
		glm::vec2 theta = glm::vec2(-cameraAngle.y, cameraAngle.x);
		glm::mat3 mX = glm::mat3(1.0f, 0.0f, 0.0f, 0.0f, glm::cos(theta.x), -glm::sin(theta.x), 0.0f, glm::sin(theta.x), glm::cos(theta.x));
		glm::mat3 mY = glm::mat3(glm::cos(theta.y), 0.0f, glm::sin(theta.y), 0.0f, 1.0f, 0.0f, -glm::sin(theta.y), 0.0f, glm::cos(theta.y));
		glm::mat3 m = mX * mY;

		cameraPos = cameraPos + deltaCamPos * m;
	}

	void ItemsTable(const char* name, int& selection, int id, int size, bool isPrintID) {
		for (int i = id; i < (size + id); i++) {
			ImGui::PushID(i);
			ImGui::TableNextRow();
			ImGui::TableSetColumnIndex(0);

			std::string label;
			label.append(name);
			if (isPrintID) {
				label.append(std::to_string(i - id + 1));
			}

			bool isSelected = selection == i;

			if (ImGui::Selectable(label.data(), &isSelected, ImGuiSelectableFlags_SpanAllColumns)) {
				if (isSelected) {
					selection = i;
				}
			}

			ImGui::PopID();
		}
	}

	void ImGuiRender(std::vector<float>& framesGraph) {
		static sphere newSphere = { { 0.0f, 0.0f, 0.0f }, 1.0f, 1 };
		static plane newPlane = { { 0.0f, 0.0f, 0.0f }, 1 };
		static box newBox = { { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f }, 1 };
		static lens newLens = { { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, 1.0f, 1.0f, 0.0f, true, 1 };
		static cyclide newCyclide = { { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f }, 3.36, -3.17, -1.06, -1.50, 1 };
		static material newMaterial = { { 550.0f, 100.0f, 0 }, { 5500.0f, 0.0f } };
		static sdf newSDF = { { 0.0f, 0.0f, 0.0f }, { 1.0f, 1.0f, 1.0f }, R"(
float sdf(in vec3 p){
	return length(p) - 1.0;
}

float sdfmaterial(in vec3 p)
{
    return 0.0;
})"
		};

		static std::vector<float> spectrumGraph{};
		static std::vector<float> tonemapGraph{};

		ImGui_ImplVulkan_NewFrame();
		ImGui_ImplGlfw_NewFrame();
		ImGui::NewFrame();

		ImGuiWindowFlags WinFlags = ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize;

		{
			ImGui::Begin("Scene", NULL, WinFlags);
			ImGui::SetWindowPos(ImVec2(W - ImGui::GetWindowWidth(), 0));
			ImGui::Text("Render Time: %0.3f ms (%0.1f FPS)", 1000.0f * frameTime, 1.0f / frameTime);
			ImGui::PlotLines("", framesGraph.data(), (int)framesGraph.size(), 0, NULL, 0.0f, 30.0f, ImVec2(303, 100));
			ImGui::Text("Resolution: (%i, %i) px", W, H);
			ImGui::Text("Samples: %i", currentSamples);
			ImGui::Text("Camera Angle: (%0.3f, %0.3f)", camera.angle.x, camera.angle.y);
			ImGui::Text("Camera Pos: (%0.3f, %0.3f, %0.3f)", camera.pos.x, camera.pos.y, camera.pos.z);
			isVSyncChanged = ImGui::Checkbox("VSync", &VSync);
			ImGui::Checkbox("Lock Camera", &isCameraLocked);
			ImGui::DragFloat("Min Latency", &minFrameTime, 1.0f, 0.0f, 1e7f);
			isReset |= ImGui::DragInt("Samples/Frame", &samplesPerFrame, 0.02f, 1, 100);
			isReset |= ImGui::DragInt("Path Length", &pathLength, 0.02f, 1, 100000);
			isLoadScene |= ImGui::Button("Load Scene", ImVec2(303, 0));
			isSaveScene |= ImGui::Button("Save Scene", ImVec2(303, 0));
			isRecompile |= ImGui::Button("Recompile", ImVec2(303, 0));
			ImGui::Separator();

			if (ImGui::CollapsingHeader("Post Processing")) {
				if (ImGui::BeginTable("Tonemap Table", 1)) {
					ImGui::TableSetupColumn("Tonemap");
					ImGui::TableHeadersRow();
					ItemsTable("None", tonemap, 0, 1, false);
					ItemsTable("Reinhard", tonemap, 1, 1, false);
					ItemsTable("ACES Film", tonemap, 2, 1, false);
					ItemsTable("DEUCES", tonemap, 3, 1, false);
					ImGui::EndTable();
				}

				tonemapGraph.clear();
				for (int i = 1; i < 101; i++) {
					float x = 0.01f * (float)i;
					tonemapGraph.push_back(tonemapping(x, tonemap));
				}

				ImGui::PlotLines("", tonemapGraph.data(), (int)tonemapGraph.size(), 0, NULL, 0.0f, 1.0f, ImVec2(303, 100));
			}

			if (ImGui::CollapsingHeader("Camera")) {
				isReset |= ImGui::DragFloat("Persistence", &persistence, 0.00025f, 0.00000f, 1.00000f, "%0.5f");
				isReset |= ImGui::DragInt("ISO", &camera.ISO, 50, 50, 819200);
				isReset |= ImGui::DragFloat("Camera Size", &camera.size, 0.001f, 0.001f, 5.0f, "%0.3f");
				isReset |= ImGui::DragFloat("Aperture Size", &camera.apertureSize, 0.0001f, 0.0001f, 10.0f, "%0.4f");
				isReset |= ImGui::DragFloat("Aperture Dist", &camera.apertureDist, 0.001f, 0.001f, camera.lensDistance, "%0.3f");
				float fov = 2.0f * glm::degrees(::atan(0.5f * camera.size / camera.apertureDist));
				ImGui::Text("FOV: %0.0f", fov);
				ImGui::Separator();

				ImGui::Text("Lens");
				isReset |= ImGui::DragFloat("Radius", &camera.lensRadius, 0.0005f, 0.0005f, 10.0f, "%0.4f");
				isReset |= ImGui::DragFloat("Focal Length", &camera.lensFocalLength, 0.0005f, 0.0005f, 10.0f, "%0.4f");
				isReset |= ImGui::DragFloat("Thickness", &camera.lensThickness, 0.0005f, 0.0f, 1.0f, "%0.4f");
				isReset |= ImGui::DragFloat("Distance", &camera.lensDistance, 0.001f, 0.001f, 100.0f, "%0.3f");
			}
			ImGui::Separator();

			int numMaterials = (int)materials.size();

			if (ImGui::CollapsingHeader("Objects")) {
				int numSpheres = (int)spheres.size();
				int numPlanes = (int)planes.size();
				int numBoxes = (int)boxes.size();
				int numLenses = (int)lenses.size();
				int numCyclides = (int)cyclides.size();

				int id = objectSelection;
				if (IsInRange(id, 0, numSpheres - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Sphere %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", spheres[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("Radius", &spheres[id].radius, 0.01f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragInt("Material ID", &spheres[id].materialID, 0.02f, 1, numMaterials);
				}

				id -= numSpheres;
				if (IsInRange(id, 0, numPlanes - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Plane %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", planes[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragInt("Material ID", &planes[id].materialID, 0.02f, 1, numMaterials);
				}

				id -= numPlanes;
				if (IsInRange(id, 0, numBoxes - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Box %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", boxes[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat3("Rotation", boxes[id].rotation, 0.1f);
					isUpdateUBO |= ImGui::DragFloat3("Size", boxes[id].size, 0.01f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragInt("Material ID", &boxes[id].materialID, 0.02f, 1, numMaterials);
				}

				id -= numBoxes;
				if (IsInRange(id, 0, numLenses - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Lens %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", lenses[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat3("Rotation", lenses[id].rotation, 0.1f);
					isUpdateUBO |= ImGui::DragFloat("Radius", &lenses[id].radius, 0.001f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragFloat("Focal Length", &lenses[id].focalLength, 0.001f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragFloat("Thickness", &lenses[id].thickness, 0.001f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::Checkbox("Convex Lens", &lenses[id].isConverging);
					isUpdateUBO |= ImGui::DragInt("Material ID", &lenses[id].materialID, 0.02f, 1, numMaterials);
				}

				id -= numLenses;
				if (IsInRange(id, 0, numCyclides - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Cyclide %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", cyclides[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat3("Rotation", cyclides[id].rotation, 0.1f);
					isUpdateUBO |= ImGui::DragFloat3("Scale", cyclides[id].scale, 0.01f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragFloat("a", &cyclides[id].a, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("b", &cyclides[id].b, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("c", &cyclides[id].c, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("d", &cyclides[id].d, 0.01f);
					isUpdateUBO |= ImGui::DragFloat("Bounding Radius", &cyclides[id].brad, 0.01f, 0.0f, 1e7f);
					isUpdateUBO |= ImGui::DragInt("Material ID", &cyclides[id].materialID, 0.02f, 1, numMaterials);
				}

				id -= numCyclides;

				ImGui::Separator();

				if (ImGui::BeginTable("Objects Table", 1)) {
					ImGui::TableSetupColumn("Object");
					ImGui::TableHeadersRow();
					ItemsTable("Sphere ", objectSelection, 0, numSpheres, true);
					ItemsTable("Plane ", objectSelection, numSpheres, numPlanes, true);
					ItemsTable("Box ", objectSelection, numSpheres + numPlanes, numBoxes, true);
					ItemsTable("Lens ", objectSelection, numSpheres + numPlanes + numBoxes, numLenses, true);
					ItemsTable("Cyclide ", objectSelection, numSpheres + numPlanes + numBoxes + numLenses, numCyclides, true);
					ImGui::EndTable();
				}
				ImGui::Separator();

				if (ImGui::Button("Add New Sphere", ImVec2(303, 0))) {
					spheres.push_back(newSphere);

					objectSelection = numSpheres;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Add New Plane", ImVec2(303, 0))) {
					planes.push_back(newPlane);

					objectSelection = numSpheres + numPlanes;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Add New Box", ImVec2(303, 0))) {
					boxes.push_back(newBox);

					objectSelection = numSpheres + numPlanes + numBoxes;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Add New Lens", ImVec2(303, 0))) {
					lenses.push_back(newLens);

					objectSelection = numSpheres + numPlanes + numBoxes + numLenses;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Add New Cyclide", ImVec2(303, 0))) {
					cyclides.push_back(newCyclide);

					objectSelection = numSpheres + numPlanes + numBoxes + numLenses + numCyclides;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Delete Object", ImVec2(303, 0))) {
					id = objectSelection;
					if (IsInRange(id, 0, numSpheres - 1)) {
						spheres.erase(std::next(spheres.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					id -= numSpheres;
					if (IsInRange(id, 0, numPlanes - 1)) {
						planes.erase(std::next(planes.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					id -= numPlanes;
					if (IsInRange(id, 0, numBoxes - 1)) {
						boxes.erase(std::next(boxes.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					id -= numBoxes;
					if (IsInRange(id, 0, numLenses - 1)) {
						lenses.erase(std::next(lenses.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					id -= numLenses;
					if(IsInRange(id, 0, numCyclides - 1)) {
						cyclides.erase(std::next(cyclides.begin(), id));
						if (objectSelection > 0) {
							objectSelection--;
						}
					}

					isUpdateUBO = true;
				}
			}
			ImGui::Separator();

			if (ImGui::CollapsingHeader("SDFs")) {
				int numSDFs = (int)sdfs.size();

				int id = sdfSelection;
				if (IsInRange(id, 0, numSDFs - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "SDF %i", id + 1);
					isUpdateUBO |= ImGui::DragFloat3("Position", sdfs[id].pos, 0.01f);
					isUpdateUBO |= ImGui::DragFloat3("Bounding Box Size", sdfs[id].size, 0.01f, 0.0f, 1e7f);
					isLoadSDF |= ImGui::Button("Change SDF", ImVec2(303, 0));
					isSaveSDF |= ImGui::Button("Save SDF", ImVec2(303, 0));
				}

				ImGui::Separator();

				if (ImGui::BeginTable("SDFs Table", 1)) {
					ImGui::TableSetupColumn("SDF");
					ImGui::TableHeadersRow();
					ItemsTable("SDF ", sdfSelection, 0, numSDFs, true);
					ImGui::EndTable();
				}
				ImGui::Separator();

				if (ImGui::Button("Add New SDF", ImVec2(303, 0))) {
					sdfs.push_back(newSDF);

					sdfSelection = numSDFs;
					isUpdateUBO = true;
					isRecompile = true;
				}

				if (ImGui::Button("Delete SDF", ImVec2(303, 0))) {
					id = sdfSelection;
					if (IsInRange(id, 0, numSDFs - 1)) {
						sdfs.erase(std::next(sdfs.begin(), id));
						if (sdfSelection > 0) {
							sdfSelection--;
						}
					}

					isUpdateUBO = true;
					isRecompile = true;
				}
			}
			ImGui::Separator();

			if (ImGui::CollapsingHeader("Materials")) {
				if (IsInRange(materialSelection, 0, numMaterials - 1)) {
					ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Material %i", materialSelection + 1);
					ImGui::Text("Reflection");
					ImGui::PushID("Reflection");

					spectrumGraph.clear();
					for (int i = 1; i < 101; i++) {
						float x = 0.01f * float(i) * 330.0f + 390.0f;
						spectrumGraph.push_back(SpectralPowerDistribution(x, materials[materialSelection].reflection[0],
						materials[materialSelection].reflection[1], materials[materialSelection].reflection[2]));
					}

					ImGui::PlotLines("", spectrumGraph.data(), (int)spectrumGraph.size(), 0, NULL, 0.0f, 1.0f, ImVec2(303, 100));
					isUpdateUBO |= ImGui::DragFloat("Peak Lambda", &materials[materialSelection].reflection[0], 1.0f, 0.0f, 1200.0f);
					isUpdateUBO |= ImGui::DragFloat("Sigma", &materials[materialSelection].reflection[1], 0.5f, 0.0f, 100.0f);
					bool isInvertBool;
					isInvertBool = (bool)materials[materialSelection].reflection[2];
					isUpdateUBO |= ImGui::Checkbox("Invert", &isInvertBool);
					materials[materialSelection].reflection[2] = (float)isInvertBool;
					ImGui::PopID();

					ImGui::Text("Emission");
					ImGui::PushID("Emission");

					spectrumGraph.clear();
					for (int i = 1; i < 101; i++) {
						float x = float(i) * 12e-9f;
						spectrumGraph.push_back(BlackBodyRadiation(x, materials[materialSelection].emission[0]) / BlackBodyRadiationPeak(materials[materialSelection].emission[0]));
					}

					ImGui::PlotLines("", spectrumGraph.data(), (int)spectrumGraph.size(), 0, NULL, 0.0f, 1.0f, ImVec2(303, 100));
					isUpdateUBO |= ImGui::DragFloat("Temperature", &materials[materialSelection].emission[0], 5.0f, 0.0f, 1e5f);
					isUpdateUBO |= ImGui::DragFloat("Luminosity", &materials[materialSelection].emission[1], 0.1f, 0.0f, 1e5f);
					ImGui::PopID();
				}
				ImGui::Separator();

				if (ImGui::BeginTable("Materials Table", 1)) {
					ImGui::TableSetupColumn("Materials");
					ImGui::TableHeadersRow();
					ItemsTable("Material ", materialSelection, 0, numMaterials, true);
					ImGui::EndTable();
				}
				ImGui::Separator();

				if (ImGui::Button("Add New Material")) {
					materials.push_back(newMaterial);

					materialSelection = numMaterials;
					isUpdateUBO = true;
				}

				if (ImGui::Button("Delete Material")) {
					if (IsInRange(materialSelection, 0, numMaterials - 1)) {
						materials.erase(std::next(materials.begin(), materialSelection));

						for (sphere& sphere : spheres) {
							if ((sphere.materialID > materialSelection) && (sphere.materialID > 1)) {
								sphere.materialID--;
							}
						}

						for (plane& plane : planes) {
							if ((plane.materialID > materialSelection) && (plane.materialID > 1)) {
								plane.materialID--;
							}
						}

						for (box& box : boxes) {
							if ((box.materialID > materialSelection) && (box.materialID > 1)) {
								box.materialID--;
							}
						}

						for (lens& lens : lenses) {
							if ((lens.materialID > materialSelection) && (lens.materialID > 1)) {
								lens.materialID--;
							}
						}

						if (materialSelection > 0) {
							materialSelection--;
						}
					}

					isUpdateUBO = true;
				}
			}

			isImGuiWindowFocused = ImGui::IsWindowFocused();
			ImGui::End();
		}

		ImGui::Render();
	}

	void CleanUpImages() {
		for (VkFramebuffer framebuffer : framebuffers) {
			vkDestroyFramebuffer(device, framebuffer, nullptr);
		}

		if (OFFSCREENRENDER) {
			vkDestroyImage(device, saveImage, nullptr);
			vkFreeMemory(device, saveImageMemory, nullptr);
			vkDestroyImageView(device, processorImageView, nullptr);
			vkDestroyImage(device, processorImage, nullptr);
			vkFreeMemory(device, processorImageMemory, nullptr);
		} else {
			for (VkImageView imageView : swapChainImageViews) {
				vkDestroyImageView(device, imageView, nullptr);
			}

			vkDestroySwapchainKHR(device, swapChain, nullptr);
		}
	}

	void CleanUpTexelBuffer() {
		vkDestroyBufferView(device, texelBufferView, nullptr);
		vkDestroyBuffer(device, texelBuffer, nullptr);
		vkFreeMemory(device, texelBufferMemory, nullptr);
	}

	void LoadScene() {
		std::vector<std::string> sceneDir = pfd::open_file("Load Scene", "", {"All Files", "*"}, pfd::opt::none).result();

		if (!sceneDir.empty()) {
			scene = ReadJSON(sceneDir.at(0));
			UpdateFromJSON();

			objectSelection = 0;
			materialSelection = 0;
			isUpdateUBO = true;
			isRecompile = true;

			vkDeviceWaitIdle(device);

			CleanUpTexelBuffer();

			CreateTexelBuffer();
			CreateTexelBufferView();

			UpdateDescriptorSet();
		}
	}

	void SaveScene() {
		std::string sceneDir = pfd::save_file("Save Scene", "", {"All Files", "*"}, pfd::opt::force_overwrite).result();

		if (!sceneDir.empty()) {
			UpdateToJSON();
			SaveFile(sceneDir, scene.dump(4, (char)32, true));
		}
	}

	void LoadSDF() {
		std::vector<std::string> SDFDir = pfd::open_file("Load SDF", "", {"All Files", "*"}, pfd::opt::none).result();
		if (!SDFDir.empty()) {
			sdfs[sdfSelection].glsl = ReadFile(SDFDir.at(0));
			isRecompile = true;
		}
	}

	void SaveSDF() {
		std::string SDFDir = pfd::save_file("Save SDF", "", {"All Files", "*"}, pfd::opt::force_overwrite).result();

		if (!SDFDir.empty()) {
			std::cout << sdfs[sdfSelection].glsl << std::endl;
			SaveFile(SDFDir, sdfs[sdfSelection].glsl);
		}
	}

	void RecordGraphicsCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex) {
		VkCommandBufferBeginInfo beginInfo{};
		beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
		beginInfo.flags = 0;
		beginInfo.pInheritanceInfo = nullptr;

		if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Begin Recording Graphics Command Buffer!");
		}

		VkViewport viewport{};
		viewport.x = 0.0f;
		viewport.y = 0.0f;
		viewport.width = static_cast<float>(W);
		viewport.height = static_cast<float>(H);
		viewport.minDepth = 0.0f;
		viewport.maxDepth = 1.0f;

		vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

		VkRect2D scissor{};
		scissor.offset = {0, 0};
		scissor.extent.width = static_cast<uint32_t>(W);
		scissor.extent.height = static_cast<uint32_t>(H);

		vkCmdSetScissor(commandBuffer, 0, 1, &scissor);

		VkBuffer vertexBuffers[] = {vertexBuffer};
		VkDeviceSize offsets[] = {0};

		vkCmdBindVertexBuffers(commandBuffer, 0, 1, vertexBuffers, offsets);

		vkCmdBindIndexBuffer(commandBuffer, indexBuffer, 0, VK_INDEX_TYPE_UINT16);

		VkRenderPassBeginInfo renderPassBeginInfo{};
		renderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
		renderPassBeginInfo.renderPass = renderPass;
		renderPassBeginInfo.framebuffer = framebuffers[imageIndex];
		renderPassBeginInfo.renderArea.extent.width = static_cast<uint32_t>(W);
		renderPassBeginInfo.renderArea.extent.height = static_cast<uint32_t>(H);
		renderPassBeginInfo.renderArea.offset = {0, 0};
		renderPassBeginInfo.clearValueCount = 0;
		renderPassBeginInfo.pClearValues = nullptr;

		vkCmdBeginRenderPass(commandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

		vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

		vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
		graphicsPipelineLayout, 0, 1, &descriptorSets[currentFrame], 0, nullptr);

		vkCmdPushConstants(commandBuffer, graphicsPipelineLayout, VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(pushConstant), &pushConstant);

		vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(indices.size()), 1, 0, 0, 0);

		if (!OFFSCREENRENDER) {
			vkCmdNextSubpass(commandBuffer, VK_SUBPASS_CONTENTS_INLINE);

			ImGui_ImplVulkan_RenderDrawData(ImGui::GetDrawData(), commandBuffer);
		}

		vkCmdEndRenderPass(commandBuffer);

		if (OFFSCREENRENDER) {
			if (currentSamples >= numSamples) {
				std::array<VkImageMemoryBarrier, 2> imageMemoryBarrierTransfer1{};

				imageMemoryBarrierTransfer1[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
				imageMemoryBarrierTransfer1[0].image = processorImage;
				imageMemoryBarrierTransfer1[0].srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
				imageMemoryBarrierTransfer1[0].dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
				imageMemoryBarrierTransfer1[0].oldLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
				imageMemoryBarrierTransfer1[0].newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
				imageMemoryBarrierTransfer1[0].subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};

				imageMemoryBarrierTransfer1[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
				imageMemoryBarrierTransfer1[1].image = saveImage;
				imageMemoryBarrierTransfer1[1].srcAccessMask = 0;
				imageMemoryBarrierTransfer1[1].dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
				imageMemoryBarrierTransfer1[1].oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
				imageMemoryBarrierTransfer1[1].newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
				imageMemoryBarrierTransfer1[1].subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};

				vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,
				VK_DEPENDENCY_BY_REGION_BIT, 0, nullptr, 0, nullptr, 2, imageMemoryBarrierTransfer1.data());

				VkImageCopy region{};
				region.extent.width = static_cast<uint32_t>(W);
				region.extent.height = static_cast<uint32_t>(H);
				region.extent.depth = 1;
				region.srcOffset = {0, 0, 0};
				region.dstOffset = {0, 0, 0};
				region.srcSubresource = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 0, 1};
				region.dstSubresource = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 0, 1};

				VkClearColorValue clearColor = {{0.0f, 1.0f, 0.0f, 1.0f}};

				VkImageSubresourceRange range{};
				range.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
				range.baseArrayLayer = 0;
				range.layerCount = 1;
				range.baseMipLevel = 0;
				range.levelCount = 1;

				vkCmdCopyImage(commandBuffer, processorImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, saveImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);

				std::array<VkImageMemoryBarrier, 2> imageMemoryBarrierTransfer2{};

				imageMemoryBarrierTransfer2[0].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
				imageMemoryBarrierTransfer2[0].image = processorImage;
				imageMemoryBarrierTransfer2[0].srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
				imageMemoryBarrierTransfer2[0].dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
				imageMemoryBarrierTransfer2[0].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
				imageMemoryBarrierTransfer2[0].newLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
				imageMemoryBarrierTransfer2[0].subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};

				imageMemoryBarrierTransfer2[1].sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
				imageMemoryBarrierTransfer2[1].image = saveImage;
				imageMemoryBarrierTransfer2[1].srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
				imageMemoryBarrierTransfer2[1].dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;
				imageMemoryBarrierTransfer2[1].oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
				imageMemoryBarrierTransfer2[1].newLayout = VK_IMAGE_LAYOUT_GENERAL;
				imageMemoryBarrierTransfer2[1].subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};

				vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
				VK_DEPENDENCY_BY_REGION_BIT, 0, nullptr, 0, nullptr, 2, imageMemoryBarrierTransfer2.data());
			}
		}

		if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Record Graphics Command Buffer!");
		}
	}

	void RecordComputeCommandBuffer(VkCommandBuffer commandBuffer) {
		VkCommandBufferBeginInfo beginInfo{};
		beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
		beginInfo.flags = 0;
		beginInfo.pInheritanceInfo = nullptr;

		if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Begin Recording Compute Command Buffer!");
		}

		vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, computePipeline);

		vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE,
		computePipelineLayout, 0, 1, &descriptorSets[currentFrame], 0, nullptr);

		vkCmdPushConstants(commandBuffer, computePipelineLayout, VK_SHADER_STAGE_COMPUTE_BIT, 0, sizeof(pushConstant), &pushConstant);

		vkCmdDispatch(commandBuffer, static_cast<uint32_t>(std::ceil(W / 16.0)), static_cast<uint32_t>(std::ceil(H / 16.0)), 1);

		if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Record Compute Command Buffer!");
		}
	}

	void RecreateSwapChain() {
		vkDeviceWaitIdle(device);

		CleanUpImages();

		CreateSwapChain();
		CreateSwapChainImageViews();

		CreateImages();
		CreateImageViews();

		CreateFramebuffers();
	}

	void RecreateImages() {
		isWindowMinimized = (bool)glfwGetWindowAttrib(window, GLFW_ICONIFIED);

		while (glfwGetWindowAttrib(window, GLFW_ICONIFIED)) {
			glfwWaitEvents();
		}

		if (isWindowMinimized) {
			return;
		}

		RecreateSwapChain();

		CleanUpTexelBuffer();

		CreateTexelBuffer();
		CreateTexelBufferView();

		UpdateDescriptorSet();
	}

	void UpdateUniformBuffer() {
		if (isUpdateUBO) {
			std::array<float, 6> numObjects;
			std::vector<float> objectsArray;
			std::vector<float> sdfsArray;
			std::vector<float> materialsArray;

			numObjects[0] = (float)spheres.size();
			numObjects[1] = (float)planes.size();
			numObjects[2] = (float)boxes.size();
			numObjects[3] = (float)lenses.size();
			numObjects[4] = (float)cyclides.size();
			numObjects[5] = (float)sdfs.size();

			for (size_t i = 0; i < numObjects.size(); i++) {
				ubo.numObjects[i] = numObjects[i];
			}

			for (int i = 0; i < spheres.size(); i++) {
				objectsArray.push_back(spheres[i].pos[0]);
				objectsArray.push_back(spheres[i].pos[1]);
				objectsArray.push_back(spheres[i].pos[2]);
				objectsArray.push_back(spheres[i].radius);
				objectsArray.push_back((float)spheres[i].materialID);
			}

			for (int i = 0; i < planes.size(); i++) {
				objectsArray.push_back(planes[i].pos[0]);
				objectsArray.push_back(planes[i].pos[1]);
				objectsArray.push_back(planes[i].pos[2]);
				objectsArray.push_back((float)planes[i].materialID);
			}

			for (int i = 0; i < boxes.size(); i++) {
				objectsArray.push_back(boxes[i].pos[0]);
				objectsArray.push_back(boxes[i].pos[1]);
				objectsArray.push_back(boxes[i].pos[2]);
				objectsArray.push_back(boxes[i].rotation[0]);
				objectsArray.push_back(boxes[i].rotation[1]);
				objectsArray.push_back(boxes[i].rotation[2]);
				objectsArray.push_back(boxes[i].size[0]);
				objectsArray.push_back(boxes[i].size[1]);
				objectsArray.push_back(boxes[i].size[2]);
				objectsArray.push_back((float)boxes[i].materialID);
			}

			for (int i = 0; i < lenses.size(); i++) {
				objectsArray.push_back(lenses[i].pos[0]);
				objectsArray.push_back(lenses[i].pos[1]);
				objectsArray.push_back(lenses[i].pos[2]);
				objectsArray.push_back(lenses[i].rotation[0]);
				objectsArray.push_back(lenses[i].rotation[1]);
				objectsArray.push_back(lenses[i].rotation[2]);
				objectsArray.push_back(lenses[i].radius);
				objectsArray.push_back(lenses[i].focalLength);
				objectsArray.push_back(lenses[i].thickness);
				objectsArray.push_back((float)lenses[i].isConverging);
				objectsArray.push_back((float)lenses[i].materialID);
			}

			for (int i = 0; i < cyclides.size(); i++) {
				objectsArray.push_back(cyclides[i].pos[0]);
				objectsArray.push_back(cyclides[i].pos[1]);
				objectsArray.push_back(cyclides[i].pos[2]);
				objectsArray.push_back(cyclides[i].rotation[0]);
				objectsArray.push_back(cyclides[i].rotation[1]);
				objectsArray.push_back(cyclides[i].rotation[2]);
				objectsArray.push_back(cyclides[i].scale[0]);
				objectsArray.push_back(cyclides[i].scale[1]);
				objectsArray.push_back(cyclides[i].scale[2]);
				objectsArray.push_back(cyclides[i].a);
				objectsArray.push_back(cyclides[i].b);
				objectsArray.push_back(cyclides[i].c);
				objectsArray.push_back(cyclides[i].d);
				objectsArray.push_back(cyclides[i].brad * cyclides[i].brad *
					(glm::max(glm::max(cyclides[i].scale[0], cyclides[i].scale[1]), cyclides[i].scale[2]) *
					glm::max(glm::max(cyclides[i].scale[0], cyclides[i].scale[1]), cyclides[i].scale[2])));
				objectsArray.push_back((float)cyclides[i].materialID);
			}

			for (int i = 0; i < MAX_OBJECTS_SIZE; i++) {
				if (objectsArray.size() > i) {
					ubo.packedObjects[i] = objectsArray[i];
				} else {
					ubo.packedObjects[i] = 0.0f;
				}
			}

			for (int i = 0; i < sdfs.size(); i++) {
				sdfsArray.push_back(sdfs[i].pos[0]);
				sdfsArray.push_back(sdfs[i].pos[1]);
				sdfsArray.push_back(sdfs[i].pos[2]);
				sdfsArray.push_back(sdfs[i].size[0]);
				sdfsArray.push_back(sdfs[i].size[1]);
				sdfsArray.push_back(sdfs[i].size[2]);
			}

			for (int i = 0; i < MAX_SDFS_SIZE; i++) {
				if (sdfsArray.size() > i) {
					ubo.packedSdfs[i] = sdfsArray[i];
				} else {
					ubo.packedSdfs[i] = 0.0f;
				}
			}

			for (int i = 0; i < materials.size(); i++) {
				materialsArray.push_back(materials[i].reflection[0]);
				materialsArray.push_back(materials[i].reflection[1]);
				materialsArray.push_back(materials[i].reflection[2]);
				materialsArray.push_back(materials[i].emission[0]);
				materialsArray.push_back(materials[i].emission[1]);
			}

			for (int i = 0; i < MAX_MATERIALS_SIZE; i++) {
				if (materialsArray.size() > i) {
					ubo.packedMaterials[i] = materialsArray[i];
				} else {
					ubo.packedMaterials[i] = 0.0f;
				}
			}

			for (size_t k = 0; k < MAX_FRAMES_IN_FLIGHT; k++) {
				memcpy(uniformBuffersMapped[k], &ubo, sizeof(ubo));
			}

			isUpdateUBO = false;
		}
	}

	void UpdatePushConstant() {
		pushConstant.resolution = glm::ivec2(W, H);
		pushConstant.frame = frame;
		pushConstant.currentSamples = currentSamples;
		pushConstant.samplesPerFrame = samplesPerFrame;
		pushConstant.FPS = 1.0f / frameTime;
		pushConstant.persistence = persistence;
		pushConstant.pathLength = pathLength;
		pushConstant.cameraAngle = glm::vec2(-camera.angle.y, camera.angle.x);
		pushConstant.cameraPosX = camera.pos.x;
		pushConstant.cameraPosY = camera.pos.y;
		pushConstant.cameraPosZ = camera.pos.z;
		pushConstant.ISO = camera.ISO;
		pushConstant.cameraSize = camera.size;
		pushConstant.apertureSize = camera.apertureSize;
		pushConstant.apertureDist = camera.apertureDist;
		pushConstant.lensRadius = camera.lensRadius;
		pushConstant.lensFocalLength = camera.lensFocalLength;
		pushConstant.lensThickness = camera.lensThickness;
		pushConstant.lensDistance = camera.lensDistance;
		pushConstant.tonemap = tonemap;
	}

	void RecompileComputeShaders() {
		vkDestroyPipeline(device, computePipeline, nullptr);
		vkDestroyPipelineLayout(device, computePipelineLayout, nullptr);

		CreateComputePipeline();
	}

	void DrawFrame() {
		bool isGraphicsRender = (!OFFSCREENRENDER) || (OFFSCREENRENDER && (currentSamples >= numSamples));

		if (isRecompile) {
			for (int i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
				vkWaitForFences(device, 1, &computeInFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
				currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
			}
			RecompileComputeShaders();
			isRecompile = false;
		} else {
			vkWaitForFences(device, 1, &computeInFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
		}

		UpdateUniformBuffer();
		UpdatePushConstant();

		vkResetFences(device, 1, &computeInFlightFences[currentFrame]);
		vkResetCommandBuffer(computeCommandBuffers[currentFrame], 0);

		RecordComputeCommandBuffer(computeCommandBuffers[currentFrame]);

		VkSubmitInfo computeSubmitInfo{};
		computeSubmitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
		computeSubmitInfo.commandBufferCount = 1;
		computeSubmitInfo.pCommandBuffers = &computeCommandBuffers[currentFrame];

		if (isGraphicsRender) {
			computeSubmitInfo.signalSemaphoreCount = 1;
			computeSubmitInfo.pSignalSemaphores = &computeFinishedSemaphores[currentFrame];
		}

		if (vkQueueSubmit(computeQueue, 1, &computeSubmitInfo, computeInFlightFences[currentFrame]) != VK_SUCCESS) {
			throw std::runtime_error("Failed To Submit Compute Command Buffers!");
		}

		if (isGraphicsRender) {
			vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);
		}

		uint32_t imageIndex = 0;
		VkResult result;

		if (!OFFSCREENRENDER) {
			if (isVSyncChanged) {
				RecreateSwapChain();

				isVSyncChanged = false;
			}

			result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX,
			imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);

			if (result == VK_ERROR_OUT_OF_DATE_KHR) {
				RecreateImages();

				if (!isWindowMinimized) {
					frame = samplesPerFrame;
					currentSamples = samplesPerFrame;
				} else {
					isWindowMinimized = false;
				}

				return;
			} else if ((result != VK_SUCCESS) && (result != VK_SUBOPTIMAL_KHR)) {
				throw std::runtime_error("Failed To Acquire Swap Chain Image!");
			}
		}

		if (isGraphicsRender) {
			vkResetFences(device, 1, &inFlightFences[currentFrame]);

			vkResetCommandBuffer(graphicsCommandBuffers[currentFrame], 0);
			RecordGraphicsCommandBuffer(graphicsCommandBuffers[currentFrame], imageIndex);

			VkSubmitInfo submitInfo{};
			submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
			VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT};
			submitInfo.pWaitDstStageMask = waitStages;
			submitInfo.commandBufferCount = 1;
			submitInfo.pCommandBuffers = &graphicsCommandBuffers[currentFrame];

			std::vector<VkSemaphore> waitSemaphores;
			waitSemaphores.push_back(computeFinishedSemaphores[currentFrame]);
			if (OFFSCREENRENDER) {
				submitInfo.waitSemaphoreCount = static_cast<uint32_t>(waitSemaphores.size());
				submitInfo.pWaitSemaphores = waitSemaphores.data();
			} else {
				waitSemaphores.push_back(imageAvailableSemaphores[currentFrame]);
				submitInfo.waitSemaphoreCount = static_cast<uint32_t>(waitSemaphores.size());
				submitInfo.pWaitSemaphores = waitSemaphores.data();
				submitInfo.signalSemaphoreCount = 1;
				submitInfo.pSignalSemaphores = &renderFinishedSemaphores[currentFrame];
			}

			if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
				throw std::runtime_error("Failed To Submit Draw Command Buffer!");
			}
		}

		if (!OFFSCREENRENDER) {
			VkPresentInfoKHR presentInfo{};
			presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
			presentInfo.waitSemaphoreCount = 1;
			presentInfo.pWaitSemaphores = &renderFinishedSemaphores[currentFrame];
			VkSwapchainKHR swapChains[] = {swapChain};
			presentInfo.swapchainCount = 1;
			presentInfo.pSwapchains = swapChains;
			presentInfo.pImageIndices = &imageIndex;
			presentInfo.pResults = nullptr; // Checking If Presentation Was Successful For Multiple Swap Chains

			result = vkQueuePresentKHR(presentQueue, &presentInfo);

			if ((result == VK_ERROR_OUT_OF_DATE_KHR) || (result == VK_SUBOPTIMAL_KHR)) {
				RecreateImages();

				if (!isWindowMinimized) {
					frame = 0;
					currentSamples = 0;
				} else {
					isWindowMinimized = false;
				}
			} else if (result != VK_SUCCESS) {
				throw std::runtime_error("Failed To Present Swap Chain Image!");
			}
		}

		currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
	}

    void MainLoop() {
		double start = 0;
		double end = 0;
		double prevEnd = 0;

		if (OFFSCREENRENDER) {
			std::cout << "Number Of Samples: ";
			std::cin >> numSamples;
			std::cout << "Number Of Samples Per Frame: ";
			std::cin >> samplesPerFrame;
			std::cout << "Path Length: ";
			std::cin >> pathLength;

			start = glfwGetTime();
		}

		glm::vec2 cursorPos = glm::vec2(0.0f, 0.0f);
		glm::vec3 deltaCamPos = glm::vec3(0.0f, 0.0f, 0.0f);

		std::vector<float> framesGraph;

		if (OFFSCREENRENDER) {
			std::vector<std::string> sceneDir = pfd::open_file("Load Scene", "", {"All Files", "*"}, pfd::opt::none).result();

			if (sceneDir.empty()) {
				throw std::runtime_error("No Scene Has Been Selected!");
			} else {
				scene = ReadJSON(sceneDir.at(0));
			}
		} else {
			DefaultScene();
		}
		UpdateFromJSON();

        while (!glfwWindowShouldClose(window)) {
			if (!OFFSCREENRENDER) {
				HandleEvents(cursorPos, camera.angle, deltaCamPos);

				Sleep(minFrameTime);

				deltaCamPos *= 3.0f * frameTime;
				UpdateCameraPos(camera.pos, glm::radians(camera.angle), deltaCamPos);

				ImGuiRender(framesGraph);

				if (isLoadScene) {
					LoadScene();
					isLoadScene = false;
				}

				if (isSaveScene) {
					SaveScene();
					isSaveScene = false;
				}

				if (isLoadSDF) {
					LoadSDF();
					isLoadSDF = false;
				}

				if (isSaveSDF) {
					SaveSDF();
					isSaveSDF = false;
				}

				if (frame >= samplesPerFrame) {
					isReset |= isUpdateUBO;
					isReset |= isRecompile;
				}
			}

			frame += samplesPerFrame;
			if (isReset) {
				currentSamples = samplesPerFrame;
				isReset = false;
			} else {
				currentSamples += samplesPerFrame;
			}

			DrawFrame();

			if (OFFSCREENRENDER) {
				prevEnd = end;
				end = glfwGetTime();
				double dtime = end - prevEnd;
				double speed = (double)samplesPerFrame / dtime;
				double timeElapsed = end - start;
				double progress = (double)currentSamples / (double)numSamples;
				int percentage = (int)(100.0 * progress);
				double timeRemaining = timeElapsed * ((1.0 / progress) - 1.0);

				std::string progressBar;
				for (int i = 0; i < percentage; i++) {
					progressBar.push_back((char)219);
				}
				for (int i = percentage; i < 100; i++) {
					progressBar.push_back((char)32);
				}

				printf("Rendering: %i%%|%s| %i/%i [%0.1fs|%0.1fs, %0.3fSPP/s] \r", percentage, progressBar.data(), currentSamples, numSamples, timeElapsed, timeRemaining, speed);
				if (currentSamples >= numSamples) {
					std::cout << std::endl;
					printf("Rendering Completed In %0.3fs. \n", timeElapsed);
					break;
				}
			}

			if (!OFFSCREENRENDER) {
				frameTime = io->DeltaTime;

				if (framesGraph.size() >= 100) {
					framesGraph.erase(framesGraph.begin());
				}
				framesGraph.push_back(1000.0f * frameTime);
			}
        }

		vkDeviceWaitIdle(device);

		if (OFFSCREENRENDER) {
			VkImageSubresource subresource{};
			subresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
			VkSubresourceLayout subresourceLayout{};
			vkGetImageSubresourceLayout(device, saveImage, &subresource, &subresourceLayout);

			char* pixels = new char[W * H * 4];
			char* pixelsRGB = new char[W * H * 3];
			vkMapMemory(device, saveImageMemory, 0, VK_WHOLE_SIZE, 0, (void**)&pixels);

			for (int i = 0; i < (W * H); i++) {
				pixelsRGB[3*i] = pixels[4*i+2];
				pixelsRGB[3*i+1] = pixels[4*i+1];
				pixelsRGB[3*i+2] = pixels[4*i];
			}

			SavePPM("render.ppm", W, H, pixelsRGB);

			vkUnmapMemory(device, saveImageMemory);
			delete[] pixelsRGB;
			delete[] pixels;
		}
    }

    void CleanUp() {
		CleanUpImages();
		CleanUpTexelBuffer();

		if (!OFFSCREENRENDER) {
			ImGui_ImplVulkan_Shutdown();
			ImGui_ImplGlfw_Shutdown();
			ImGui::DestroyContext();
		}

		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			vkDestroyBuffer(device, uniformBuffers[i], nullptr);
			vkFreeMemory(device, uniformBuffersMemory[i], nullptr);
		}

		if (!OFFSCREENRENDER) {
			vkDestroyDescriptorPool(device, imguiDescriptorPool, nullptr);
		}

		vkDestroyDescriptorPool(device, descriptorPool, nullptr);

		vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr);

		vkDestroyBuffer(device, indexBuffer, nullptr);
		vkFreeMemory(device, indexBufferMemory, nullptr);

		vkDestroyBuffer(device, vertexBuffer, nullptr);
		vkFreeMemory(device, vertexBufferMemory, nullptr);

		for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
			vkDestroyFence(device, computeInFlightFences[i], nullptr);
			vkDestroySemaphore(device, computeFinishedSemaphores[i], nullptr);

			vkDestroyFence(device, inFlightFences[i], nullptr);
			vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr);
			vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr);
		}

		vkDestroyCommandPool(device, commandPool, nullptr);

		vkDestroyPipeline(device, computePipeline, nullptr);
		vkDestroyPipeline(device, graphicsPipeline, nullptr);
		vkDestroyPipelineLayout(device, computePipelineLayout, nullptr);
		vkDestroyPipelineLayout(device, graphicsPipelineLayout, nullptr);

		for (VkShaderModule shaderModule : shaderModules) {
			vkDestroyShaderModule(device, shaderModule, nullptr);
		}

		vkDestroyRenderPass(device, renderPass, nullptr);

		vkDestroyDevice(device, nullptr);

		if (isValidationLayersEnabled) {
			DestoryDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);
		}

		vkDestroySurfaceKHR(instance, surface, nullptr);
		vkDestroyInstance(instance, nullptr);

        glfwDestroyWindow(window);
		glfwTerminate();
    }
};

int main(int argc, char* argv[])
{
    App app;

    try {
        app.run();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return EXIT_FAILURE;
    }

	return EXIT_SUCCESS;
}
