#version 450

#extension GL_EXT_scalar_block_layout : require

precision highp float;

#define MINDIST 1e-5
#define MAXDIST 1e5
#define PI 3.141592653589792623810034526344
#define ONEBYTHREE 0.3333333
#define MAX_OBJECTS_SIZE 1024
#define MAX_SDFS_SIZE 768
#define MAX_MATERIALS_SIZE 783
#define MAX_LIGHTS_SIZE 128
#define MAX_LIGHTIDS_SIZE 64

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, std430) uniform ubo {
    float numObjects[7];
    float objects[MAX_OBJECTS_SIZE];
    float sdfs[MAX_SDFS_SIZE];
    float materials[MAX_MATERIALS_SIZE];
    float lights[MAX_LIGHTS_SIZE];
    float lightIDs[MAX_LIGHTIDS_SIZE];
    float CIELMS2006[1323];
};

layout(set = 0, binding = 1, rgba32f) uniform imageBuffer texelBuffer;

layout(push_constant) uniform PushConstants {
    ivec2 resolution;
    int frame;
    int currentSamples;
    int samplesPerFrame;
    float FPS;
    float persistence;
    int pathLength;
    vec2 cameraAngle;
    float cameraPosX;
    float cameraPosY;
    float cameraPosZ;
    int ISO;
    float cameraSize;
    float apertureSize;
    float apertureDist;
    float lensRadius;
    float lensFocalLength;
    float lensThickness;
    float lensDistance;
    int tonemap;
};

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct sphere {
    vec3 pos;
    float radius;
    int materialID;
    int lightID;
};

struct plane {
    vec3 pos;
    int materialID;
    int lightID;
};

struct box {
    vec3 pos;
    vec3 rotation;
    vec3 size;
    int materialID;
    int lightID;
};

struct sphereSlice {
    vec3 pos;
    float radius;
    float sliceSize;
    bool is1stSlice;
    vec3 rotation;
    int materialID;
    int lightID;
};

struct lens {
    vec3 pos;
    vec3 rotation;
    float radius;
    float focalLength;
    float thickness;
    bool isConverging;
    int materialID;
    int lightID;
};

struct cyclide {
    vec3 pos;
    vec3 rotation;
    vec3 scale;
    float a;
    float b;
    float c;
    float d;
    float brad;
    int materialID;
    int lightID;
};

struct sdf {
    vec3 pos;
    vec3 size;
};

struct material {
    vec3 reflection;
};

struct light {
    vec2 emission;
};

vec3 cameraPos = vec3(cameraPosX, cameraPosY, cameraPosZ);

vec3 WaveToLMS(in float wave) {
    // Conversion From Wavelength To XYZ Using CIEXYZ2006 Table
    vec3 XYZ = vec3(0.0);
    if ((wave >= 390.0) && (wave <= 830.0)) {
        // Finding The Appropriate Index Of The Table For Given Wavelength
        int index3 = 3 * int(floor(wave) - 390.0);
        vec3 t1 = vec3(CIELMS2006[index3], CIELMS2006[index3 + 1], CIELMS2006[index3 + 2]);
        vec3 t2 = vec3(CIELMS2006[index3 + 3], CIELMS2006[index3 + 4], CIELMS2006[index3 + 5]);
        XYZ = mix(t1, t2, wave - floor(wave));
    }
    return XYZ;
}

// http://www.songho.ca/opengl/gl_anglestoaxes.html
mat3 RotationMatrix(in vec3 angle) {
    // Builds Rotation Matrix Depending On Given Angle
    angle *= 0.0174532925199;
    vec3 sinxyz = sin(angle);
    vec3 cosxyz = cos(angle);
    mat3 mX = mat3(1.0, 0.0, 0.0, 0.0, cosxyz.x, -sinxyz.x, 0.0, sinxyz.x, cosxyz.x);
    mat3 mY = mat3(cosxyz.y, 0.0, sinxyz.y, 0.0, 1.0, 0.0, -sinxyz.y, 0.0, cosxyz.y);
    mat3 mZ = mat3(cosxyz.z, -sinxyz.z, 0.0, sinxyz.z, cosxyz.z, 0.0, 0.0, 0.0, 1.0);
    return mX * mY * mZ;
}

void UnpackSphere(inout sphere object, in int index) {
    // Unpack Sphere From Objects Array
    index *= 6;
    object.pos = vec3(objects[index], objects[index + 1], objects[index + 2]);
    object.radius = objects[index + 3];
    object.materialID = int(objects[index + 4]) - 1;
    object.lightID = int(objects[index + 5]) - 1;
}

void UnpackPlane(inout plane object, in int index, in int offset) {
    // Unpack Plane From Objects Array
    index *= 5;
    object.pos = vec3(objects[index + offset], objects[index + 1 + offset], objects[index + 2 + offset]);
    object.materialID = int(objects[index + 3 + offset]) - 1;
    object.lightID = int(objects[index + 4 + offset]) - 1;
}

void UnpackBox(inout box object, in int index, in int offset) {
    // Unpack Box From Objects Array
    index *= 11;
    object.pos = vec3(objects[index + offset], objects[index + 1 + offset], objects[index + 2 + offset]);
    object.rotation = vec3(objects[index + 3 + offset], objects[index + 4 + offset], objects[index + 5 + offset]);
    object.size = vec3(objects[index + 6 + offset], objects[index + 7 + offset], objects[index + 8 + offset]);
    object.materialID = int(objects[index + 9 + offset]) - 1;
    object.lightID = int(objects[index + 10 + offset]) - 1;
}

void UnpackLens(inout lens object, in int index, in int offset) {
    // Unpack Lens From Objects Array
    index *= 12;
    object.pos = vec3(objects[index + offset], objects[index + 1 + offset], objects[index + 2 + offset]);
    object.rotation = vec3(objects[index + 3 + offset], objects[index + 4 + offset], objects[index + 5 + offset]);
    object.radius = objects[index + 6 + offset];
    object.focalLength = objects[index + 7 + offset];
    object.thickness = objects[index + 8 + offset];
    object.isConverging = bool(objects[index + 9 + offset]);
    object.materialID = int(objects[index + 10 + offset]) - 1;
    object.lightID = int(objects[index + 11 + offset]) - 1;
}

void UnpackCyclide(inout cyclide object, in int index, in int offset) {
    // Unpack Cyclide From Objects Array
    index *= 16;
    object.pos = vec3(objects[index + offset], objects[index + offset + 1], objects[index + offset + 2]);
    object.rotation = vec3(objects[index + 3 + offset], objects[index + 4 + offset], objects[index + 5 + offset]);
    object.scale = vec3(objects[index + 6 + offset], objects[index + 7 + offset], objects[index + 8 + offset]);
    object.a = objects[index + 9 + offset];
    object.b = objects[index + 10 + offset];
    object.c = objects[index + 11 + offset];
    object.d = objects[index + 12 + offset];
    object.brad = objects[index + 13 + offset];
    object.materialID = int(objects[index + 14 + offset]) - 1;
    object.lightID = int(objects[index + 15 + offset]) - 1;
}

void UnpackSDF(inout sdf object, in int index) {
    // Unpack SDF From SDFs Array
    index *= 6;
    object.pos = vec3(sdfs[index], sdfs[index + 1], sdfs[index + 2]);
    object.size = vec3(sdfs[index + 3], sdfs[index + 4], sdfs[index + 5]);
}

void UnpackMaterial(inout material mat, in int index) {
    // Unpack Material From Materials Array
    index *= 3;
    mat.reflection.x = materials[index];
    mat.reflection.y = materials[index + 1];
    mat.reflection.z = materials[index + 2];
}

void UnpackLight(inout light lt, in int index) {
    // Unpack Light From Lights Array
    if (index == -1) {
        lt.emission.x = 5500.0;
        lt.emission.y = 0.0;
        return;
    }

    index *= 2;
    lt.emission.x = lights[index];
    lt.emission.y = lights[index + 1];
}

void GetMaterialMix(inout material mat, in float materialID) {
    // Gets Material By UnpackMaterial
    // Takes Material Mixture ID Then Interpolates The Materials
    material material1;
    material material2;
    UnpackMaterial(material1, int(floor(materialID)));
    UnpackMaterial(material2, int(ceil(materialID)));

    float x = materialID - floor(materialID);
    mat.reflection.x = mix(material1.reflection.x, material2.reflection.x, x);
    mat.reflection.y = mix(material1.reflection.y, material2.reflection.y, x);
    mat.reflection.z = mix(material1.reflection.z, material2.reflection.z, x);
}

void GetLightMix(inout light lt, in float lightID) {
    // Gets Light By UnpackLight
    UnpackLight(lt, int(lightID));
}

void SortMinMax(inout vec3 t1, inout vec3 t2) {
    vec3 temp_t1 = t1;
    vec3 temp_t2 = t2;
    t1 = min(temp_t1, temp_t2);
    t2 = max(temp_t1, temp_t2);
}

bool BoundingSphere(in Ray ray, in vec3 pos, in float radius2) {
    // Bounding Sphere To Check Whether Ray Is Going To Hit The Object
    // Checks Sign Of Discriminant To Check Sphere Visibility And Removes The Fake Sphere Visible In The Opposite Direction
    vec3 localorigin = ray.origin - pos;
    float b = dot(ray.dir, localorigin);
    float c = dot(localorigin, localorigin) - radius2;
    if ((b * b) < c) {
        return false;
    }
    if ((b >= 0.0) && (c >= 0.0)) {
        return false;
    }
    return true;
}

vec2 RayIntersectAABB(in vec3 origin, in vec3 invdir, in box object) {
    // Checks Whether The Ray Is Intersecting Given Box
    vec3 localorigin = origin - object.pos;
    vec3 tMin = fma(object.size, vec3(-0.5), -localorigin) * invdir;
    vec3 tMax = fma(object.size, vec3(0.5), -localorigin) * invdir;
    SortMinMax(tMin, tMax);
    float t1 = max(max(tMin.x, tMin.y), tMin.z);
    float t2 = min(min(tMax.x, tMax.y), tMax.z);
    return vec2(t1, t2);
}

bool SphereIntersection(in Ray ray, in sphere object, inout float hitdist, inout vec3 normal, inout float materialID, inout float lightID) {
    // Ray-Intersection Of Sphere
    // Built By Solving The Equation: x^2 + y^2 + z^2 = r^2
    vec3 localorigin = ray.origin - object.pos;
    float b = 2.0 * dot(ray.dir, localorigin);
    float c = dot(localorigin, localorigin) - (object.radius * object.radius);
    float discriminant = b * b - 4.0 * c;
    float t = 1e6;
    int isOutside = 1;
    if (discriminant < 0.0) {
        return false;
    }
    float sqrtD = sqrt(discriminant);
    float t1 = (-b - sqrtD) * 0.5;
    float t2 = (-b + sqrtD) * 0.5;
    t = (t1 > 0.0) ? t1 : t2;
    isOutside = (t1 > 0.0) ? 1 : -1;
    if (t < 1e-4) {
        return false;
    }
    if (t < hitdist) {
        hitdist = t;
        normal = normalize(fma(ray.dir, vec3(t), localorigin) * isOutside);
        materialID = float(object.materialID);
        lightID = float(object.lightID);
        return true;
    }
    return false;
}

bool PlaneIntersection(in Ray ray, in plane object, inout float hitdist, inout vec3 normal, inout float materialID, inout float lightID) {
    // Ray-Intersection Of Plane
    // Built By Solving The Equation: z = 0
    vec3 localorigin = ray.origin - object.pos;
    float t = -localorigin.y / ray.dir.y;
    if (t < 1e-4) {
        return false;
    }
    if (t < hitdist) {
        hitdist = t;
        normal = faceforward(vec3(0.0, 1.0, 0.0), ray.dir, vec3(0.0, 1.0, 0.0));
        materialID = float(object.materialID);
        lightID = float(object.lightID);
        return true;
    }
    return false;
}

bool BoxIntersection(in Ray ray, in box object, inout float hitdist, inout vec3 normal, inout float materialID, inout float lightID) {
    // Ray-Intersection Of Box
    mat3 matrix = RotationMatrix(object.rotation);
    vec3 localorigin = (ray.origin - object.pos) * matrix;
    ray.dir *= matrix;
    vec3 invdir = 1.0 / ray.dir;
    vec3 tMin = fma(object.size, vec3(-0.5), -localorigin) * invdir;
    vec3 tMax = fma(object.size, vec3(0.5), -localorigin) * invdir;
    SortMinMax(tMin, tMax);
    float t1 = max(max(tMin.x, tMin.y), tMin.z);
    float t2 = min(min(tMax.x, tMax.y), tMax.z);
    float t = (t1 < 0.0) ? t2 : t1;
    // Ray Didn't Intersect If (tMin.x > tMax.y) || (tMin.x > tMax.z) || (tMin.y > tMax.x) || (tMin.y > tMax.z) || (tMin.z > tMax.x) || (tMin.z > tMax.y)
    // Or If t1 And t2 Were Negative
    if ((t1 > t2) || (t < 1e-4)) {
        return false;
    }
    if (t < hitdist) {
        hitdist = t;
        // The Signed Component Of p Which Has Highest Magnitude Is The Normal
        vec3 p = abs((localorigin + ray.dir * t) / object.size);
        normal = matrix * (step(max(max(p.x, p.y), p.z), p) * -sign(ray.dir));
        materialID = float(object.materialID);
        lightID = float(object.lightID);
        return true;
    }
    return false;
}

bool SphereSliceIntersection(in Ray ray, in sphereSlice object, in float localSlicePos, in bool isSideInvert, inout float hitdist, inout vec3 normal, inout int isOutside, inout float materialID, inout float lightID) {
    // Ray-Intersection Of Sliced Sphere
    // Slicing Based On Parameters Slice Size And Slice Side
    // Slicing Is Done Using 1D Interval Checks
    // Built By Solving The Same Equation Of Sphere
    mat3 matrix = RotationMatrix(object.rotation);
    Ray localRay;
    float sliceOffset = object.radius - object.sliceSize;
    localRay.origin = ray.origin - object.pos;
    localRay.origin = localRay.origin * matrix;
    if (object.is1stSlice) {
        localRay.origin.x += localSlicePos - object.sliceSize - sliceOffset;
    } else {
        localRay.origin.x -= localSlicePos - object.sliceSize - sliceOffset;
    }
    localRay.dir = ray.dir * matrix;
    float b = 2.0 * dot(localRay.dir, localRay.origin);
    float c = dot(localRay.origin, localRay.origin) - (object.radius * object.radius);
    float discriminant = b * b - 4.0 * c;
    float t = 1e6;
    int isOut = 1;
    if (discriminant < 0.0) {
        return false;
    }
    float sqrtD = sqrt(discriminant);
    float t1 = (-b - sqrtD) * 0.5;
    float t2 = (-b + sqrtD) * 0.5;
    if (object.is1stSlice) {
        t1 = (fma(localRay.dir.x, t1, localRay.origin.x) > -sliceOffset) ? 1e6 : t1;
        t2 = (fma(localRay.dir.x, t2, localRay.origin.x) > -sliceOffset) ? 1e6 : t2;
    } else {
        t1 = (fma(localRay.dir.x, t1, localRay.origin.x) < sliceOffset) ? 1e6 : t1;
        t2 = (fma(localRay.dir.x, t2, localRay.origin.x) < sliceOffset) ? 1e6 : t2;
    }
    t = (t1 > 0.0) ? t1 : t;
    if (t2 < t) {
        t = t2;
        isOut = -1;
    }
    if (t < 1e-4) {
        return false;
    }
    if (t < hitdist) {
        hitdist = t;
        normal = matrix * normalize(fma(localRay.dir, vec3(t), localRay.origin) * isOut);
        isOutside = (!isSideInvert) ? isOut : -isOut;
        materialID = float(object.materialID);
        lightID = float(object.lightID);
        return true;
    }
    return false;
}

bool LensIntersection(in Ray ray, in lens object, inout float hitdist, inout vec3 normal, inout int isOutside, inout float materialID, inout float lightID) {
    // Ray-Intersection Of Lens
    // Done By Joining Two Slices Of Sphere
    // Thickness Of Lens Is Calculated By Using The Equation: thickness = 2(2f - sqrt(4f^2 - R^2))
    float lensThicknessHalf = 2.0 * object.focalLength - sqrt(4.0 * object.focalLength * object.focalLength - object.radius * object.radius);
    bool lensSlicePart[2] = {
            true,
            false
        };
    float lensSlicePos = 0.5 * (object.isConverging ? object.thickness : -object.thickness); // Gap Between Slices Of Lens
    if (object.isConverging) {
        lensSlicePos += lensThicknessHalf;
    }
    bool isIntersect = false;
    for (int i = 0; i < 2; i++) {
        sphereSlice slice;
        slice.pos = object.pos;
        slice.radius = 2.0 * object.focalLength;
        slice.sliceSize = lensThicknessHalf;
        slice.is1stSlice = lensSlicePart[i];
        slice.rotation = object.rotation;
        slice.materialID = object.materialID;
        slice.lightID = object.lightID;
        isIntersect = isIntersect || SphereSliceIntersection(ray, slice, lensSlicePos, !object.isConverging, hitdist, normal, isOutside, materialID, lightID);
    }

    return isIntersect;
}

float EvalQuadratic(in float a, in float b, in float c, in float x) {
    return x * (x * a + b) + c;
}

vec3 EvalQuadratic(in float a, in float b, in float c, in vec3 x) {
    return x * (x * a + b) + c;
}

float EvalCubic(in float a, in float b, in float c, in float d, in float x) {
    return x * (x * (x * a + b) + c) + d;
}

vec2 EvalCubic(in float a, in float b, in float c, in float d, in vec2 x) {
    return x * (x * (x * a + b) + c) + d;
}

vec3 EvalCubic(in float a, in float b, in float c, in float d, in vec3 x) {
    return x * (x * (x * a + b) + c) + d;
}

vec2 EvalQuartic(in float a, in float b, in float c, in float d, in float e, in vec2 x) {
    return x * (x * (x * (x * a + b) + c) + d) + e;
}

bvec3 SolveCubic(in float b, in float c, in float d, inout vec3 roots) {
    // https://arxiv.org/abs/1903.10041
    // Solves Cubic Equation By Combining Two Different Methods To Find Real Roots
    float bdiv3 = b * ONEBYTHREE;
    float Q = c * ONEBYTHREE - bdiv3 * bdiv3;
    float R = 0.5 * bdiv3 * c - bdiv3 * bdiv3 * bdiv3 - 0.5 * d;
    float D = Q * Q * Q + R * R;
    if (D > 0.0) {
        // Fix Issue In Calculating Signs Using pow For Cube Root
        float u = R + sqrt(D);
        float v = R - sqrt(D);
        float S = sign(u) * pow(abs(u), ONEBYTHREE);
        float T = sign(v) * pow(abs(v), ONEBYTHREE);
        roots.x = S + T - bdiv3;
        // Apply Newton Raphson Method 2 Times To Increase The Accuracy
        for (int i = 0; i < 2; i++) {
            roots.x -= EvalCubic(1.0, b, c, d, roots.x) / EvalQuadratic(3.0, 2.0 * b, c, roots.x);
        }
        return bvec3(true, false, false);
    }
    float sqrtnegQ = sqrt(-Q);
    float thetadiv3 = acos(R / (sqrtnegQ * sqrtnegQ * sqrtnegQ)) * ONEBYTHREE;
    float TWOPIBYTHREE = fma(2.0, PI, ONEBYTHREE);
    roots = 2.0 * sqrtnegQ * vec3(cos(thetadiv3), cos(thetadiv3 + TWOPIBYTHREE), cos(fma(2.0, TWOPIBYTHREE, thetadiv3))) - bdiv3;
    // Apply Newton Raphson Method 2 Times To Increase The Accuracy
    for (int i = 0; i < 2; i++) {
        roots -= EvalCubic(1.0, b, c, d, roots) / EvalQuadratic(3.0, 2.0 * b, c, roots);
    }
    return bvec3(true);
}

bvec4 SolveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {
    // https://www.mdpi.com/2227-7390/10/14/2377
    // Solves Quartic Equation By Using The Method Given In The Above Paper
    float inva = 1.0 / a;
    float inva2 = inva * 0.5;
    float inva2a2 = inva2 * inva2;
    float bb = b * b;
    float p = -1.5 * bb * inva2a2 + c * inva;
    float q = bb * b * inva2a2 * inva2 - b * c * inva * inva2 + d * inva;
    float r = -0.1875 * bb * bb * inva2a2 * inva2a2 + 0.5 * c * bb * inva2a2 * inva2 - b * d * inva2a2 + e * inva;
    vec3 s = vec3(0.0);
    SolveCubic(0.5 * -p, -r, 0.5 * p * r - 0.125 * q * q, s);
    float s2subp = 2.0 * s.x - p;
    if (s2subp < 0.0) {
        return bvec4(false);
    }
    float invs2subp = -2.0 * s.x - p;
    float sqrts2subp = sqrt(s2subp);
    float q2divsqrt = 2.0 * q / sqrts2subp;
    float invaddq2div = invs2subp + q2divsqrt;
    float invsubq2div = invs2subp - q2divsqrt;
    float bdiv4a = 0.25 * inva * b;
    bvec4 isReal = bvec4(false);
    if (invaddq2div >= 0.0) {
        roots.xy = 0.5 * (-sqrts2subp + vec2(1.0, -1.0) * sqrt(invaddq2div)) - bdiv4a;
        // Apply Newton Raphson Method To Increase The Accuracy
        roots.xy -= EvalQuartic(a, b, c, d, e, roots.xy) / EvalCubic(4.0 * a, 3.0 * b, 2.0 * c, d, roots.xy);
        isReal.xy = bvec2(true);
    }
    if (invsubq2div >= 0.0) {
        roots.zw = 0.5 * (sqrts2subp + vec2(1.0, -1.0) * sqrt(invsubq2div)) - bdiv4a;
        // Apply Newton Raphson Method To Increase The Accuracy
        roots.zw -= EvalQuartic(a, b, c, d, e, roots.zw) / EvalCubic(4.0 * a, 3.0 * b, 2.0 * c, d, roots.zw);
        isReal.zw = bvec2(true);
    }
    return isReal;
}

bool Thritorius(in Ray ray, inout float hitdist, inout vec3 normal, inout float materialID, inout float lightID) {
    // Equation: x^2(x^2 + 2y^2 - 6y + 2z^2) + y^2(y^2 + 2y + 2z^2) + z^2(10z^2 - 12) + 1 = 0
    // Substitute Light Ray Equation Into This Equation To Get The Polynomial In Terms Of t, Substitution Has Been Done Manually, Then Solve For t Using The Quartic Equation Solver.
    if (!BoundingSphere(ray, vec3(0.0, 0.0, 0.0), 4.05)) {
        return false;
    }
    vec3 o = ray.origin.xzy;
    vec3 d = ray.dir.xzy;
    float a4 = dot(vec3(d.x, d.y, 10.0 * d.z), d * d * d) + 2.0 * dot(d.xyz * d.xyz, d.yzx * d.yzx);
    float a3 = 4.0 * (dot(vec3(o.x, o.y, 10.0 * o.z), d * d * d) + dot(o * d, vec3(dot(d.yz, d.yz), dot(d.xz, d.xz), dot(d.xy, d.xy)))) + 2.0 * d.y * d.y * d.y - 6.0 * d.x * d.x * d.y;
    float a2 = 6.0 * dot(vec3(o.x, o.y, 10.0 * o.z), o * d * d) + 2.0 * (dot(o.xy * o.xy, d.yx * d.yx) + dot(o.xz * o.xz, d.zx * d.zx) + dot(o.yz * o.yz, d.zy * d.zy)) + 8.0 * dot(o.xxy * d.xxy, o.yzz * d.yzz) + 6.0 * o.y * d.y * d.y - 6.0 * o.y * d.x * d.x - 12.0 * o.x * d.x * d.y - 12.0 * d.z * d.z;
    float a1 = 4.0 * (dot(vec3(o.x, o.y, 10.0 * o.z) * o * o, d) + dot(o.xx * o.xx, o.yz * d.yz) + dot(o.yy * o.yy, o.xz * d.xz) + dot(o.zz * o.zz, o.xy * d.xy)) + 6.0 * o.y * o.y * d.y - 6.0 * o.x * o.x * d.y - 12.0 * o.x * o.y * d.x - 24.0 * o.z * d.z;
    float a0 = dot(vec3(o.x, o.y, 10.0 * o.z), o * o * o) + 2.0 * dot(o.xxy * o.xxy, o.yzz * o.yzz) + 2.0 * o.y * o.y * o.y - 6.0 * o.x * o.x * o.y - 12.0 * o.z * o.z + 1.0;

    vec4 roots = vec4(0.0);
    bvec4 isReal = SolveQuartic(a4, a3, a2, a1, a0, roots);

    float t = 1e6;
    for (int i = 0; i < 4; i++) {
        if (isReal[i]) {
            if ((roots[i] < t) && (roots[i] > 0.0)) {
                t = roots[i];
            }
        }
    }

    if (t < hitdist) {
        hitdist = t;
        // Find The Normals By Calculating The Unit Gradient Of The Equation, Gradient Has Been Written Manually Through The Equations
        // Unit Gradient = normalize(<∂f/∂x,∂f/∂y,∂f/∂z>)
        float x = o.x + d.x * t;
        float y = o.y + d.y * t;
        float z = o.z + d.z * t;
        normal.x = 4.0 * x * x * x + 4.0 * x * y * y - 12.0 * x * y + 4.0 * x * z * z;
        normal.y = 40.0 * z * z * z + 4.0 * x * x * z + 4.0 * y * y * z - 24.0 * z;
        normal.z = 4.0 * y * y * y + 4.0 * x * x * y - 6.0 * x * x + 6.0 * y * y + 4.0 * y * z * z;
        if ((o.x * o.x * (o.x * o.x + 2.0 * o.y * o.y - 6.0 * o.y + 2.0 * o.z * o.z) + o.y * o.y * (o.y * o.y + 2.0 * o.y + 2.0 * o.z * o.z) + o.z * o.z * (10.0 * o.z * o.z - 12.0) + 1.0) < 0.0) {
            normal *= -1.0;
        }
        normal = normalize(normal);
        materialID = 1.0;
        lightID = -1.0;
        return true;
    }
    return false;
}

bool SmoothCuboid(in Ray ray, inout float hitdist, inout vec3 normal, inout float materialID, inout float lightID) {
    // Equation: x^4 + y^4 + z^4 = 1
    // Substitute Light Ray Equation Into This Equation To Get The Polynomial In Terms Of t, Substitution Has Been Done Manually, Then Solve For t Using The Quartic Equation Solver.
    if (!BoundingSphere(ray, vec3(0.0, 0.0, 0.0), 1.80)) {
        return false;
    }
    vec3 o = ray.origin.xyz;
    vec3 d = ray.dir.xyz;
    float a4 = dot(d * d, d * d);
    float a3 = 4.0 * dot(o, d * d * d);
    float a2 = 6.0 * dot(o * o, d * d);
    float a1 = 4.0 * dot(o * o * o, d);
    float a0 = dot(o * o, o * o) - 1.0;

    vec4 roots = vec4(0.0);
    bvec4 isReal = SolveQuartic(a4, a3, a2, a1, a0, roots);

    float t = 1e6;
    for (int i = 0; i < 4; i++) {
        if (isReal[i]) {
            if ((roots[i] < t) && (roots[i] > 0.0)) {
                t = roots[i];
            }
        }
    }

    if (t < hitdist) {
        hitdist = t;
        // Find The Normals By Calculating The Unit Gradient Of The Equation, Gradient Has Been Written Manually Through The Equations
        // Unit Gradient = normalize(<∂f/∂x,∂f/∂y,∂f/∂z>)
        normal = fma(d, vec3(t), o);
        normal = normal * normal * normal;
        if (dot(o * o, o * o) < 1.0) {
            normal *= -1.0;
        }
        normal = normalize(normal);
        materialID = 3.0;
        lightID = -1.0;
        return true;
    }
    return false;
}

bool DupinCyclide(in Ray ray, in cyclide object, inout float hitdist, inout vec3 normal, inout float materialID, inout float lightID) {
    // Equation: (x^2 + y^2 + z^2 + b^2 - d^2)^2 = 4((ax - cd)^2 + (by)^2)
    // Substitute Light Ray Equation Into This Equation To Get The Polynomial In Terms Of t, Substitution Has Been Done Manually, Then Solve For t Using The Quartic Equation Solver.
    mat3 matrix = RotationMatrix(object.rotation);
    vec3 o = (((ray.origin - object.pos) * matrix) / object.scale).xzy;
    vec3 d = ((ray.dir * matrix) / object.scale).xzy;
    float a4 = dot(d * d, d * d) + 2.0 * dot(d * d, d.yzx * d.yzx);
    float a3 = 4.0 * (dot(o, d * d * d) + dot(o * d, d.yzx * d.yzx) + dot(o * d, d.zxy * d.zxy));
    float a2 = 6.0 * dot(o * o, d * d) + 8.0 * dot(o * d, o.yzx * d.yzx) + 2.0 * (dot(o * o, d.yzx * d.yzx) + dot(o * o, d.zxy * d.zxy)) + 2.0 * (object.b * object.b - object.d * object.d) * dot(d, d) - 4.0 * (object.a * object.a * d.x * d.x + object.b * object.b * d.y * d.y);
    float a1 = 4.0 * (dot(o * o * o, d) + dot(o * o, o.yzx * d.yzx) + dot(o * o, o.zxy * d.zxy) + 2.0 * object.a * object.c * object.d * d.x + (object.b * object.b - object.d * object.d) * dot(o, d) - 2.0 * (object.a * object.a * o.x * d.x + object.b * object.b * o.y * d.y));
    float a0 = dot(o * o, o * o) + 2.0 * dot(o * o, o.yzx * o.yzx) + object.b * object.b * object.b * object.b + object.d * object.d * object.d * object.d - 2.0 * object.b * object.b * object.d * object.d - 4.0 * object.c * object.c * object.d * object.d + 8.0 * object.a * object.c * object.d * o.x + 2.0 * (object.b * object.b - object.d * object.d) * dot(o, o) - 4.0 * (object.a * object.a * o.x * o.x + object.b * object.b * o.y * o.y);

    vec4 roots = vec4(0.0);
    bvec4 isReal = SolveQuartic(a4, a3, a2, a1, a0, roots);

    float t = 1e6;
    for (int i = 0; i < 4; i++) {
        if (isReal[i]) {
            if ((roots[i] < t) && (roots[i] > 0.0)) {
                t = roots[i];
            }
        }
    }

    if (t < hitdist) {
        hitdist = t;
        // Find The Normals By Calculating The Unit Gradient Of The Equation, Gradient Has Been Written Manually Through The Equations
        // Unit Gradient = normalize(<∂f/∂x,∂f/∂y,∂f/∂z>)
        float x = o.x + d.x * t;
        float y = o.y + d.y * t;
        float z = o.z + d.z * t;
        float term1 = x * x + y * y + z * z + object.b * object.b - object.d * object.d;
        normal.x = 4.0 * (x * term1 - 2.0 * object.a * (object.a * x - object.c * object.d));
        normal.y = 4.0 * z * term1;
        normal.z = 4.0 * y * (term1 - 2.0 * object.b * object.b);
        float term2 = dot(o, o) + object.b * object.b - object.d * object.d;
        float term3 = object.a * o.x - object.c * object.d;
        //if ((term2 * term2) < (4.0 * (term3 * term3 + object.b * object.b * o.y * o.y))) {
        //    normal *= -1.0;
        //}
        normal = normalize(normal);
        materialID = float(object.materialID);
        lightID = float(object.lightID);
        return true;
    }
    return false;
}

float minMaterial(float x, float y, float material1, float material2) {
    return (x < y) ? material1 : material2;
}

// https://iquilezles.org/articles/smin/
float smin(in float x, in float y) {
    float k = 0.02;
    k *= 6.0;
    float h = max(k - abs(x - y), 0.0) / k;
    float m = h * h * h * 0.5;
    float s = m * k * ONEBYTHREE;
    return min(x, y) - s;
}

vec2 smin(in vec2 x, in vec2 y) {
    float k = 0.02;
    k *= 6.0;
    float h = max(k - abs(x.x - y.x), 0.0) / k;
    float m = h * h * h * 0.5;
    float s = m * k * ONEBYTHREE;
    return (x.x < y.x) ? vec2(x.x - s, x.y + (y.y - x.y) * m) : vec2(y.x - s, x.y + (y.y - x.y) * (1.0 - m));
}

// All SDF Are Inserted Here

float SDF(in vec3 p, in uint set1, in uint set2, in uint set3, in uint set4) {
    float sdf = MAXDIST;
    // Put SDF Functions Here

    return sdf;
}

float SDFMATERIAL(in vec3 p, in uint set1, in uint set2, in uint set3, in uint set4) {
    float sdf = MAXDIST;
    float sdfmaterial = 0.0;
    // Put SDFMATERIAL Functions Here

    return sdfmaterial;
}

vec3 CalculateNumericalSDFNormals(in vec3 p, in uint set1, in uint set2, in uint set3, in uint set4) {
    float epsilon = 1e-4;
    vec2 h = vec2(epsilon, 0.0);
    // Normal = Unit Gradient = normalize(<∂f/∂x,∂f/∂y,∂f/∂z>)
    return normalize(vec3(
            SDF(p + h.xyy, set1, set2, set3, set4) - SDF(p - h.xyy, set1, set2, set3, set4),
            SDF(p + h.yxy, set1, set2, set3, set4) - SDF(p - h.yxy, set1, set2, set3, set4),
            SDF(p + h.yyx, set1, set2, set3, set4) - SDF(p - h.yyx, set1, set2, set3, set4)
        ));
}

bool SearchSDF(in vec3 p, in vec3 invdir, inout vec2 tMinMax, inout uint set1, inout uint set2, inout uint set3, inout uint set4) {
    bool isFoundSDF = false;
    // Program To Use set2, set3, set4 Not Yet Written
    set1 = 0;
    set2 = 0;
    set3 = 0;
    set4 = 0;
    for (int i = 0; i < numObjects[5]; i++) {
        box boundingBox;
        sdf sdf;
        UnpackSDF(sdf, i);
        boundingBox.pos = sdf.pos;
        boundingBox.size = sdf.size;
        vec2 boxMinMax = RayIntersectAABB(p, invdir, boundingBox);
        if ((boxMinMax.x > boxMinMax.y) || (boxMinMax.y < 0.0)) {
            continue;
        }
        if (boxMinMax.x < tMinMax.x) {
            isFoundSDF = true;
            if (boxMinMax.y < tMinMax.x) {
                tMinMax = boxMinMax;
                set1 = 1 << uint(i);
            } else {
                if (boxMinMax.y < tMinMax.y) {
                    tMinMax.x = boxMinMax.x;
                    set1 += 1 << uint(i);
                } else {
                    tMinMax = boxMinMax;
                    set1 += 1 << uint(i);
                }
            }
        } else {
            if (boxMinMax.x < tMinMax.y) {
                isFoundSDF = true;
                if (boxMinMax.y > tMinMax.y) {
                    tMinMax.y = boxMinMax.y;
                    set1 += 1 << uint(i);
                } else {
                    set1 += 1 << uint(i);
                }
            }
        }
    }

    return isFoundSDF;
}

bool SphereTracing(in Ray ray, inout float hitdist, inout vec3 normal, inout float materialID, inout float lightID) {
    float t = 1e-3;
    float insT = 0.0;
    float omegaMax = 1.70;
    float omegaSpeed = 0.20;
    float omega = omegaMax;
    float omegaSpeedFactor = 0.0;
    float previousRadius = 0.0;
    vec3 p = ray.origin;
    vec3 invdir = 1.0 / ray.dir;
    int points = 0;
    vec2 tMinMax = vec2(MAXDIST);
    uint set1 = 0;
    uint set2 = 0;
    uint set3 = 0;
    uint set4 = 0;
    if (SearchSDF(p, invdir, tMinMax, set1, set2, set3, set4)) {
        t = max(tMinMax.x, t);
        p = fma(ray.dir, vec3(t), ray.origin);
    } else {
        return false;
    }
    float k = sign(SDF(ray.origin, set1, set2, set3, set4));

    for (int i = 0; i < 512; i++) {
        // Calculate SDF
        float radius = SDF(p, set1, set2, set3, set4);
        // Over-Relaxation Sphere Tracing: https://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf
        if (insT > (abs(previousRadius) + abs(radius))) {
            t -= insT;
            omega = 1.0;

            insT = previousRadius * omega * k;
            t += insT;
            p = fma(ray.dir, vec3(t), ray.origin);
            continue;
        }
        // Minimum Distance
        if (abs(radius) < 1e-4) {
            break;
        }
        // Bounding Box Check
        if (t > tMinMax.y) {
            points += 1;
        } else {
            points = 0;
        }
        if (points >= 2) {
            t = tMinMax.y + 1e-3;
            tMinMax = vec2(MAXDIST);
            if (SearchSDF(fma(ray.dir, vec3(t), ray.origin), invdir, tMinMax, set1, set2, set3, set4)) {
                tMinMax += vec2(t); // We Need It To Be With Respect To Ray Origin
                t = max(tMinMax.x, t); // We Don't Want To Start The Ray From Back, Possible If tMinMax.x Is Negative
                p = fma(ray.dir, vec3(t), ray.origin);
                continue;
            } else {
                return false;
            }
        }
        // Update Distance
        insT = radius * omega * k;
        t += insT;
        // Update Variables
        p = fma(ray.dir, vec3(t), ray.origin);
        // 1 / (1 - eta) Is The Omega Derived For Plane Surfaces
        // But This Assumes It's Plane Surface And Omega * Radius Can't Be More than PreviousRadius + Radius
        // So, Set A Omega Maximum And The Speed At Which It Changes, Then Choose Best Values
        omegaSpeedFactor = min(radius / previousRadius, 0.99);
        omega += omegaSpeed * (min(1.0 / (1.0 - omegaSpeedFactor), omegaMax) - omega);
        previousRadius = radius;
    }

    if (t < hitdist) {
        hitdist = t - 1e-3;
        p = fma(ray.dir, vec3(t), ray.origin);
        normal = CalculateNumericalSDFNormals(p, set1, set2, set3, set4);
        materialID = SDFMATERIAL(p, set1, set2, set3, set4);
        lightID = -1.0;
        return true;
    }
    return false;
}

float Intersection(in Ray ray, inout vec3 normal, inout float materialID, inout float lightID) {
    // Finds The Ray-Intersection Of Every Object In The Scene
    float hitdist = MAXDIST;
    int offset = 0;

    // Iterate Over All The Spheres In The Scene
    for (int i = 0; i < numObjects[0]; i++) {
        sphere object;
        UnpackSphere(object, i);
        SphereIntersection(ray, object, hitdist, normal, materialID, lightID);
    }
    offset += 6 * int(numObjects[0]);

    // Iterate Over All The Planes In The Scene
    for (int i = 0; i < numObjects[1]; i++) {
        plane object;
        UnpackPlane(object, i, offset);
        PlaneIntersection(ray, object, hitdist, normal, materialID, lightID);
    }
    offset += 5 * int(numObjects[1]);

    // Iterate Over All The Boxes In The Scene
    for (int i = 0; i < numObjects[2]; i++) {
        box object;
        UnpackBox(object, i, offset);
        if (!BoundingSphere(ray, object.pos, 0.25 * dot(object.size, object.size))) {
            continue;
        }
        BoxIntersection(ray, object, hitdist, normal, materialID, lightID);
    }
    offset += 11 * int(numObjects[2]);

    // Iterate Over All The Lenses In The Scene
    for (int i = 0; i < numObjects[3]; i++) {
        lens object;
        UnpackLens(object, i, offset);
        int isOutside = 1;
        if (!BoundingSphere(ray, object.pos, (object.radius * object.radius) + (0.25 * object.thickness * object.thickness))) {
            continue;
        }
        LensIntersection(ray, object, hitdist, normal, isOutside, materialID, lightID);
    }
    offset += 12 * int(numObjects[3]);

    // Iterate Over All The Cyclides In The Scene
    for (int i = 0; i < numObjects[4]; i++) {
        cyclide object;
        UnpackCyclide(object, i, offset);
        if (!BoundingSphere(ray, object.pos, object.brad)) {
            continue;
        }
        DupinCyclide(ray, object, hitdist, normal, materialID, lightID);
    }
    offset += 16 * int(numObjects[4]);

    SphereTracing(ray, hitdist, normal, materialID, lightID);

    //ray.origin -= vec3(-3.0, 1.06, -6.0);
    //SmoothCuboid(ray, hitdist, normal, materialID, lightID);
    //ray.origin += vec3(-3.0, 1.06, -6.0);

    //ray.origin -= vec3(1.0, 1.06, -7.0);
    //Thritorius(ray, hitdist, normal, materialID, lightID);

    return hitdist;
}

// https://www.pcg-random.org/
void PCG32(inout uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    seed = (word >> 22u) ^ word;
}

float RandomFloatPCG32(inout uint seed) {
    PCG32(seed);
    return float(seed) / 0xFFFFFFFFu;
}

uint GenerateSeed(in uvec2 xy, in int k) {
    // Actually This Is Not The Correct Way To Generate Seed
    // This Is The Correct Implementation Which Has No Overlapping:
    /* uint seed = (resolution.x * resolution.y) * (frame - samplesPerFrame + k);  seed += xy.x + resolution.x * xy.y;*/
    // But Because This Seed Crosses 32-Bit Limit Quickly, And Implementing In 64-Bit Makes Path Tracer Much Slower,
    // That's Why I Implemented This Trick. Even If Pixels Seed Overlap With Other Pixels Somewhere, It Won't Affect The Result
    uint seed = uint(frame - samplesPerFrame + k);
    PCG32(seed);
    seed += xy.x + resolution.x * xy.y;
    return seed;
}

float SampleHeroWavelength(in float l_min, in float l_max, inout uint seed) {
    // Uniform Inverted CDF For Sampling
    return mix(l_min, l_max, RandomFloatPCG32(seed));
}

float InverseSampleWavelengthPDF(in float l_min, in float l_max) {
    // Inverse Of Uniform PDF
    return l_max - l_min;
}

// https://cgg.mff.cuni.cz/wp-content/uploads/2021/05/WNDWH14HWSS.pdf
vec4 SampleWavelengths(in float l_h) {
    // Generate Wavelengths By Applying Rotation Function On Hero Wavelength
    return 390.0 + mod(l_h - 390.0 + 0.25 * vec4(1.0, 2.0, 3.0, 4.0) * 330.0, 330.0);
}

vec2 SampleUniformUnitDisk(inout uint seed) {
    // Samples Uniformly Distributed Random Points On Unit Disk
    vec2 random = vec2(RandomFloatPCG32(seed), RandomFloatPCG32(seed));
    float phi = 2.0 * PI * random.y;
    float d = sqrt(random.x);
    return d * vec2(cos(phi), sin(phi));
}

vec3 SampleUniformUnitSphere(inout uint seed) {
    // Samples Uniformly Distributed Random Points On Unit Sphere
    // XYZ Coordinates Is Calculated Based On Longitude And Latitude
    // Longitude Is Generated Uniformly And Sin Of Latitude Is Generated Uniformly
    // Reason: If We Generate Latitude Uniformly, The Top And Bottom Of The Sphere Will Have More Points Than Other Regions
    vec2 random = vec2(RandomFloatPCG32(seed), RandomFloatPCG32(seed));
    float phi = 2.0 * PI * random.y;
    float sinTheta = 2.0 * random.x - 1.0;
    float cosTheta = sqrt(fma(-sinTheta, sinTheta, 1.0));
    float x = cos(phi) * cosTheta;
    float y = sin(phi) * cosTheta;
    float z = sinTheta;
    return vec3(x, y, z);
}

vec3 SampleCosineDirectionHemisphere(in vec3 normal, inout uint seed) {
    // Generate Cosine Distributed Random Vectors Within Normals Hemisphere
    vec3 sumvector = normal + SampleUniformUnitSphere(seed);
    return normalize(sumvector);
}

float CosineDirectionPDF(in float cosTheta) {
    // Idea: Integrating Over Cosine PDF Must Give 1
    // Solution: Divide Cosine By Pi
    // Note: Integrating Equation Is Solid Angle. Must Insert PDF Inside Integrals To Normalize
    return cosTheta / PI;
}

vec3 SampleCosineUnitCone(inout uint seed, in float cosThetaMax) {
    // Sampling Directions In Cone In Cosine Distribution
    vec2 random = vec2(RandomFloatPCG32(seed), RandomFloatPCG32(seed));
    float cosAlphaMax = 2.0 * cosThetaMax * cosThetaMax - 1.0;
    float phi = 2.0 * PI * random.y;
    float cosTheta = (1.0 - cosAlphaMax) * random.x + cosAlphaMax;
    float sinTheta = sqrt(fma(-cosTheta, cosTheta, 1.0));
    float x = cos(phi) * sinTheta;
    float y = sin(phi) * sinTheta;
    float z = cosTheta + 1.0;
    return normalize(vec3(x, y, z));
}

float CosineUnitConePDF(in float cosTheta, in float cosThetaMax) {
    // PDF For Sampling Directions In Cone In Cosine Distribution
    return cosTheta / (PI * (1.0 - cosThetaMax * cosThetaMax));
}

vec4 SpectralPowerDistribution(in vec4 l, in float l_peak, in float d, in int invert) {
    // Spectral Power Distribution Function Calculated On The Basis Of Peak Wavelength And Standard Deviation
    // Using Gaussian Function To Predict Spectral Radiance
    // In Reality, Spectral Radiance Function Has Different Shapes For Different Objects Also Looks Much Different Than This
    vec4 x = (l - l_peak) / (2.0 * d * d);
    vec4 radiance = exp(-x * x);
    radiance = mix(radiance, 1.0 - radiance, invert);
    return radiance;
}

vec4 BlackBodyRadiation(in vec4 l, in float T) {
    // Plank's Law
    return (1.1910429724e-16 * pow(l, vec4(-5.0))) / (exp(0.014387768775 / (l * T)) - 1.0);
}

float BlackBodyRadiationPeak(in float T) {
    // Derived By Substituting Wien's Displacement Law On Plank's Law
    return 4.0956746759e-6 * pow(T, 5.0);
}

vec4 Emit(in vec4 l, in light lt) {
    // Calculates Light Emittance Based On Given Material
    float temperature = max(lt.emission.x, 0.0);
    vec4 lightEmission = (BlackBodyRadiation(l * 1e-9, temperature) / BlackBodyRadiationPeak(temperature)) * max(lt.emission.y, 0.0);
    return lightEmission;
}

float RefractiveIndexWavelength(in float l, in float n, in float l_n, in float s) {
    // My Own Function For Refractive Index
    // Function Is Based On Observation How Graph Of Mathematrical Functions Look Like
    // Made To Produce Change In Refractive Index Based On Wavelength
    return fma(s, (l_n / l) - 1.0, n);
}

float RefractiveIndexBK7Glass(in float l) {
    // Sellmeier Equation For Refractive Index Of BK7 Glass
    l *= 1e-3;
    float l2 = l * l;
    float n2 = 1.0;
    n2 += (1.03961212 * l2) / (l2 - 6.00069867e-3);
    n2 += (0.231792344 * l2) / (l2 - 2.00179144e-2);
    n2 += (1.01046945 * l2) / (l2 - 1.03560653e2);
    return sqrt(n2);
}

vec4 EvaluateBRDF(in vec4 l, in vec3 inDir, in vec3 outDir, in vec3 normal, in material mat) {
    // Evaluate The BRDF
    // Lambertian BRDF For Diffuse Surface
    vec4 diffuse = SpectralPowerDistribution(l, mat.reflection.x, mat.reflection.y, int(mat.reflection.z)) / PI;
    return diffuse;
}

vec3 SampleBRDF(in vec3 inDir, in vec3 normal, inout uint seed) {
    // Sample Directions Of BRDF
    vec3 outDir = SampleCosineDirectionHemisphere(normal, seed);
    return outDir;
}

float BRDFPDF(in vec3 outDir, in vec3 normal) {
    // PDF For Sampling Directions Of BRDF
    return CosineDirectionPDF(dot(outDir, normal));
}

void OrthonormalBasis(inout vec3 b1, inout vec3 b2, in vec3 n) {
    // Creates Orthogonal Vectors To Each Other And Normal
    b1 = vec3(0.0, -1.0, 0.0);
    b2 = vec3(-1.0, 0.0, 0.0);
    if (n.z >= -0.9999999) {
        float a = 1.0 / (1.0 + n.z);
        float b = -n.x * n.y * a;
        b1 = vec3(1.0 - (n.x * n.x * a), b, -n.x);
        b2 = vec3(b, 1.0 - (n.y * n.y * a), -n.y);
    }
}

vec3 ToLocal(in vec3 v, in vec3 n) {
    // Convert World Space To Local Space Based On Normal Vector
    vec3 s = vec3(0.0);
    vec3 t = vec3(0.0);
    OrthonormalBasis(s, t, n);
    return vec3(dot(v, s), dot(v, t), dot(v, n));
}

vec3 ToWorld(in vec3 v, in vec3 n) {
    // Convert Local Space To World Space Based On Normal Vector
    vec3 s = vec3(0.0);
    vec3 t = vec3(0.0);
    OrthonormalBasis(s, t, n);
    return s * v.x + t * v.y + n * v.z;
}

bool LightSourceVisibilityCheck(in Ray ray, in int lightObjectID) {
    // Checks Whether The Light Source Is Occluded By The Objects In The Scene Or Not
    float hitdist = MAXDIST;
    vec3 normal = vec3(0.0);
    float materialID = 0.0;
    float lightID = -1.0;
    int objectID = -1;
    int offset = 0;
    int objectOffset = 0;

    // Iterate Over All The Spheres In The Scene
    for (int i = 0; i < numObjects[0]; i++) {
        sphere object;
        UnpackSphere(object, i);
        if (SphereIntersection(ray, object, hitdist, normal, materialID, lightID)) {
            objectID = i;
        }
    }
    offset += 6 * int(numObjects[0]);
    objectOffset += int(numObjects[0]);

    // Iterate Over All The Planes In The Scene
    for (int i = 0; i < numObjects[1]; i++) {
        plane object;
        UnpackPlane(object, i, offset);
        if (PlaneIntersection(ray, object, hitdist, normal, materialID, lightID)) {
            objectID = i + objectOffset;
        }
    }
    offset += 5 * int(numObjects[1]);
    objectOffset += int(numObjects[1]);

    // Iterate Over All The Boxes In The Scene
    for (int i = 0; i < numObjects[2]; i++) {
        box object;
        UnpackBox(object, i, offset);
        if (!BoundingSphere(ray, object.pos, 0.25 * dot(object.size, object.size))) {
            continue;
        }
        if (BoxIntersection(ray, object, hitdist, normal, materialID, lightID)) {
            objectID = i + objectOffset;
        }
    }
    offset += 11 * int(numObjects[2]);
    objectOffset += int(numObjects[2]);

    // Iterate Over All The Lenses In The Scene
    for (int i = 0; i < numObjects[3]; i++) {
        lens object;
        UnpackLens(object, i, offset);
        int isOutside = 1;
        if (!BoundingSphere(ray, object.pos, (object.radius * object.radius) + (0.25 * object.thickness * object.thickness))) {
            continue;
        }
        if (LensIntersection(ray, object, hitdist, normal, isOutside, materialID, lightID)) {
            objectID = i + objectOffset;
        }
    }
    offset += 12 * int(numObjects[3]);
    objectOffset += int(numObjects[3]);

    // Iterate Over All The Cyclides In The Scene
    for (int i = 0; i < numObjects[4]; i++) {
        cyclide object;
        UnpackCyclide(object, i, offset);
        if (!BoundingSphere(ray, object.pos, object.brad)) {
            continue;
        }
        if (DupinCyclide(ray, object, hitdist, normal, materialID, lightID)) {
            objectID = i + objectOffset;
        }
    }
    offset += 16 * int(numObjects[4]);
    objectOffset += int(numObjects[4]);

    if (SphereTracing(ray, hitdist, normal, materialID, lightID)) {
        objectID = -1;
    }

    //ray.origin -= vec3(-3.0, 1.06, -6.0);
    //if (SmoothCuboid(ray, hitdist, normal, materialID, lightID)) {
    //objectID = -1;
    //}
    //ray.origin += vec3(-3.0, 1.06, -6.0);

    //ray.origin -= vec3(1.0, 1.06, -7.0);
    //if (Thritorius(ray, hitdist, normal, materialID, lightID)) {
    //objectID = -1;
    //}

    if (objectID == lightObjectID) {
        return true;
    }

    return false;
}

int SampleRandomLightSource(inout uint seed, inout float boundingRadius, inout vec3 pos, inout float lightID) {
    // Samples Random Light Source Out Of Existing Light Sources
    int randomLight = int(floor(RandomFloatPCG32(seed) * numObjects[6]));
    int randomLightID = int(lightIDs[randomLight]);
    int offset = 0;

    if (randomLightID < int(numObjects[0])) {
        sphere object;
        UnpackSphere(object, randomLightID);
        boundingRadius = object.radius;
        pos = object.pos;
        lightID = float(object.lightID);
        return int(lightIDs[randomLight]);
    }
    randomLightID -= int(numObjects[0]);
    offset += 6 * int(numObjects[0]);

    if (randomLightID < int(numObjects[1])) {
        plane object;
        UnpackPlane(object, randomLightID, offset);
        boundingRadius = 1e5f;
        pos = object.pos;
        lightID = float(object.lightID);
        return int(lightIDs[randomLight]);
    }
    randomLightID -= int(numObjects[1]);
    offset += 5 * int(numObjects[1]);

    if (randomLightID < int(numObjects[2])) {
        box object;
        UnpackBox(object, randomLightID, offset);
        boundingRadius = 0.5 * length(object.size);
        pos = object.pos;
        lightID = float(object.lightID);
        return int(lightIDs[randomLight]);
    }
    randomLightID -= int(numObjects[2]);
    offset += 11 * int(numObjects[2]);

    if (randomLightID < int(numObjects[2])) {
        lens object;
        UnpackLens(object, randomLightID, offset);
        boundingRadius = sqrt((object.radius * object.radius) + (0.25 * object.thickness * object.thickness));
        pos = object.pos;
        lightID = float(object.lightID);
        return int(lightIDs[randomLight]);
    }
    randomLightID -= int(numObjects[3]);
    offset += 12 * int(numObjects[3]);

    if (randomLightID < int(numObjects[3])) {
        cyclide object;
        UnpackCyclide(object, randomLightID, offset);
        boundingRadius = sqrt(object.brad);
        pos = object.pos;
        lightID = float(object.lightID);
        return int(lightIDs[randomLight]);
    }

    return 0;
}

float SampleRandomLightSourcePDF() {
    // PDF For Randomly Selecting Light Source
    return 1.0 / numObjects[6];
}

// https://graphics.stanford.edu/papers/veach_thesis/thesis.pdf
float MISPowerHeuristicsBeta2(in float pdf1, in float pdf2) {
    // MIS Weights
    return pdf1 * pdf1 / (pdf1 * pdf1 + pdf2 * pdf2);
}

vec4 SampleLightSource(in vec4 l, in vec4 rayradiance, in Ray inRay, in Ray outRay, in vec3 normal, in material mat, inout uint seed, in float BRDFpdf, inout float MISBRDFWeight) {
    // Light Source Sampling Method
    // Samples The Rays Towards The Light Source
    float boundingRadius = 0.0;
    vec3 lightPos = vec3(0.0);
    float lightIDOut = -1.0;
    int lightObjectID = 0;
    float lightpdf = 0.0;
    if (numObjects[6] > 0) {
        // Pick Random Light Source
        lightObjectID = SampleRandomLightSource(seed, boundingRadius, lightPos, lightIDOut);
        // Find The Direction Of Center Of Light Source And Maximum Angle Subtended By The Light Source
        float invLightDistance = 1.0 / length(lightPos - outRay.origin);
        vec3 lightDir = (lightPos - outRay.origin) * invLightDistance;
        float sinthetaMax = min(boundingRadius * invLightDistance, 1.0);
        float costhetaMax = sqrt(1.0 - sinthetaMax * sinthetaMax);
        // Sample Rays In Cosine Distributed Cone
        outRay.dir = ToWorld(SampleCosineUnitCone(seed, costhetaMax), lightDir);
        // Light Source Sampling PDF And MIS
        lightpdf = SampleRandomLightSourcePDF();
        lightpdf *= CosineUnitConePDF(dot(outRay.dir, lightDir), costhetaMax);
        MISBRDFWeight = MISPowerHeuristicsBeta2(BRDFpdf, lightpdf);
        // We Can Avoid Visibility Test If costheta < 0 And Needed For Evaluating BRDF
        float costheta = dot(outRay.dir, normal);
        // Russian Roulette
        float deathProbability = 1.25 * max(MISBRDFWeight - 0.2, 0.0);
        if (costheta >= 0.0) {
            if (RandomFloatPCG32(seed) > deathProbability) {
                // Check The Whether The Ray Hits The Light Source
                bool isVisible = LightSourceVisibilityCheck(outRay, lightObjectID);
                if (isVisible) {
                    light lt;
                    GetLightMix(lt, lightIDOut);
                    // For Every Bounce Of The Ray, We Need To Evaluate BRDF
                    rayradiance *= EvaluateBRDF(l, inRay.dir, outRay.dir, normal, mat) * costheta / lightpdf;
                    return Emit(l, lt) * rayradiance * (1.0 - MISBRDFWeight);
                }
            } else {
                MISBRDFWeight = 1.0;
            }
        }
        return vec4(0.0);
    }
    MISBRDFWeight = MISPowerHeuristicsBeta2(BRDFpdf, lightpdf);
    return vec4(0.0);
}

vec4 TraceRay(in vec4 l, inout vec4 rayradiance, inout Ray inRay, inout uint seed, in int path, inout float MISBRDFWeight, inout bool isTerminate) {
    // Traces A Ray Along The Given Origin And Direction Then Calculates Light Interactions
    vec4 radiance = vec4(0.0);
    vec3 normal = vec3(0.0);
    float materialID = 0.0;
    float lightID = -1.0;
    float hitdist = Intersection(inRay, normal, materialID, lightID);
    material mat;
    light lt;
    GetMaterialMix(mat, materialID);
    GetLightMix(lt, lightID);
    Ray outRay = inRay;
    if (hitdist < MAXDIST) {
        // If The Ray Hits The Light Source
        if (lt.emission.y > 0.0) {
            radiance = Emit(l, lt) * rayradiance * MISBRDFWeight;
            // Terminate The Path If The Ray Hits The Light Source
            isTerminate = true;
            return radiance;
        }
        // Calculate The Next Ray's Origin And Direction
        outRay.origin = fma(inRay.dir, vec3(hitdist), inRay.origin);
        outRay.dir = SampleBRDF(inRay.dir, normal, seed);
        float BRDFpdf = BRDFPDF(outRay.dir, normal);
        // Sample The Light Source Every Bounce
        // Note: Light Source Sampling Happens 1 Bounce Prior Compared To BRDF Sampling
        radiance = SampleLightSource(l, rayradiance, inRay, outRay, normal, mat, seed, BRDFpdf, MISBRDFWeight);
        // Evaluate The BRDF
        float costheta = dot(outRay.dir, normal);
        rayradiance *= EvaluateBRDF(l, inRay.dir, outRay.dir, normal, mat) * costheta / BRDFpdf;
        // Russian Roulette
        // Probability Of The Ray Can Be Anything From 0 To 1
        float rayProbability = clamp(max(rayradiance.x, max(rayradiance.y, max(rayradiance.z, rayradiance.w))), 0.0, 0.99);
        if (RandomFloatPCG32(seed) > rayProbability) {
            // Randomly Terminate Ray Based On Probability
            isTerminate = true;
            return radiance;
        }
        // Add Energy Which Was Lost By Terminating Rays
        rayradiance *= 1.0 / rayProbability;
        inRay = outRay;
    }
    else {
        isTerminate = true;
    }
    return radiance;
}

vec4 TracePath(in vec4 l, in Ray ray, inout uint seed) {
    // Traces A Path Starting From The Given Origin And Direction
    // And Calculates Light Radiance
    vec4 radiance = vec4(0.0);
    vec4 rayradiance = vec4(1.0);
    float MISBRDFWeight = 1.0;
    bool isTerminate = false;
    for (int i = 0; i < pathLength; i++) {
        radiance += TraceRay(l, rayradiance, ray, seed, i, MISBRDFWeight, isTerminate);
        if (isTerminate) {
            break;
        }
    }
    return radiance;
}

void TracePathLens(in float l, inout Ray ray, in vec3 forwardDir) {
    // Trace The Path Through The BiConvex Lens
    lens object;
    object.radius = lensRadius;
    object.focalLength = lensFocalLength;
    object.thickness = lensThickness;
    object.isConverging = true;
    object.pos = cameraPos + forwardDir * lensDistance;
    object.rotation = vec3(0.0, 90.0 - cameraAngle.y, cameraAngle.x);
    object.materialID = 0;
    for (int i = 0; i < 2; i++) {
        float hitdist = 1e6;
        vec3 normal = vec3(0.0);
        int isOutside = 1;
        float materialID = 0.0;
        float lightID = -1.0;
        bool isIntersect = LensIntersection(ray, object, hitdist, normal, isOutside, materialID, lightID);
        // Calculate The Refractive Index
        float n1 = 1.0;
        float n2 = 1.0;
        if (isOutside == 1) {
            n1 = 1.0;
            n2 = RefractiveIndexBK7Glass(l);
        } else {
            n1 = RefractiveIndexBK7Glass(l);
            n2 = 1.0;
        }
        float n12 = n1 / n2;
        // Wavelength Changes As Refractive Index Changes
        // lambda = lamda_0 / n
        l = l * n12;
        // Calculate The Next Ray's Origin And Direction
        ray.origin = fma(ray.dir, vec3(hitdist), ray.origin);
        ray.dir = refract(ray.dir, normal, n12);
    }
}

vec3 Scene(in uvec2 xy, in vec2 uv, in int k) {
    uint seed = GenerateSeed(xy, k);
    // SSAA
    uv += vec2(2.0 * RandomFloatPCG32(seed) - 0.5, 2.0 * RandomFloatPCG32(seed) - 0.5) / resolution;

    // This Is A Simple Camera Made Up Of A BiConvex Lens And An Aperture
    // Ray Originates From The Pixel Of Camera Sensor
    // Then Passes Through The Area Of Aperture
    // Then It Passes Through A BiConvex Lens
    Ray ray;
    mat3 matrix = RotationMatrix(vec3(cameraAngle, 0.0));
    uv *= -cameraSize * 0.5;
    // Position Of Each Pixel On Sensor As Ray Origin
    ray.origin = cameraPos + (vec3(uv, 0.0) * matrix);
    // Generates Random Point On Aperture
    vec3 pointOnAperture = cameraPos + (vec3(0.5 * apertureSize * SampleUniformUnitDisk(seed), apertureDist) * matrix);
    // Compute Random Direction Which Passes Through The Area Of Aperture From Camera Sensor
    ray.dir = normalize(pointOnAperture - ray.origin);
    // Forward Direction For The Camera
    vec3 forwardDir = vec3(matrix[0][2], matrix[1][2], matrix[2][2]);

    vec3 color = vec3(0.0);
    float l_h = SampleHeroWavelength(390.0, 720.0, seed);
    // Trace Ray Through The Lens
    TracePathLens(l_h, ray, forwardDir);
    vec4 l = SampleWavelengths(l_h);
    // Reciprocal Of Number Of Wavelengths Per Ray
    float invNuml = 0.25;
    // Trace Path In The Scene
    vec4 radiance = TracePath(l, ray, seed);
    color += (radiance.x * WaveToLMS(l.x) + radiance.y * WaveToLMS(l.y) + radiance.z * WaveToLMS(l.z) + radiance.w * WaveToLMS(l.w)) * InverseSampleWavelengthPDF(390.0, 720.0) * invNuml;
    // Don't Include NaN Values
    if (color.x != color.x) {
        return vec3(0.0);
    }
    if (color.y != color.y) {
        return vec3(0.0);
    }
    if (color.z != color.z) {
        return vec3(0.0);
    }

    return color;
}

void Accumulate(in vec3 inColor, inout vec3 outColor) {
    // Temporal Accumulation Based On Given Parameters When Scene Is Dynamic And Accumulation When Scene Is Static
    // Simulation Of Persistance Using Temporal Accumulation
    // The Idea Is To Multiply Color Value By 1/256 In A Number Of Frames
    // Find The Constant Based On Given Parameters
    // Then We Get, x^numFrames = 2^(-8) Where x Is Multiply Constant
    // Also We Know That, numFrames = FPS * time(The Amount Of Time Will Be Needed To Reach 1/256)
    // Therefore, x = 2^(-8 / (FPS*time))
    if ((currentSamples == samplesPerFrame) && (frame > samplesPerFrame)) {
        float weight = pow(2.0, -8.0 / (FPS * persistence));
        outColor = ((1.0 - weight) * outColor) + (weight * inColor);
    } else {
        int unitSamples = currentSamples / samplesPerFrame;
        outColor = ((unitSamples - 1) * inColor + outColor) / unitSamples;
    }
}

vec3 Rendering(in vec3 inColor) {
    uvec2 xy = uvec2(gl_GlobalInvocationID.x, resolution.y - gl_GlobalInvocationID.y);
    vec2 uv = ((2.0 * vec2(xy) - resolution) / resolution.y);

    vec3 outColor = vec3(0.0);
    for (int i = 0; i < samplesPerFrame; i++) {
        outColor += Scene(xy, uv, i);
    }
    outColor /= samplesPerFrame;
    // Simulate Exposure Variance Depending On Aperture Size And ISO
    outColor *= apertureSize * apertureSize * ISO;
    Accumulate(inColor, outColor);

    return outColor;
}

void main() {
    if ((gl_GlobalInvocationID.x > resolution.x) || (gl_GlobalInvocationID.y > resolution.y)) {
        return;
    }
    int coords = int(gl_GlobalInvocationID.x) + resolution.x * int(gl_GlobalInvocationID.y);
    vec4 rendererColor = imageLoad(texelBuffer, coords);
    rendererColor = vec4(Rendering(rendererColor.xyz), 1.0);
    imageStore(texelBuffer, coords, rendererColor);
}
